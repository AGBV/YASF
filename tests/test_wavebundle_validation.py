"""
Validate wavebundle (Gaussian beam) implementation against CELES/MATLAB.

This test compares YASFPY's wavebundle initial field coefficients with
reference data generated by CELES.

To generate the test data:
    1. Run tests/matlab/generate_wavebundle_test_data.m in MATLAB with CELES
    2. The script will create tests/data/wavebundle_test_data.mat
    3. Run this test: pytest tests/test_wavebundle_validation.py -v

Requirements:
    - wavebundle_test_data.mat must exist in tests/data/
"""

import numpy as np
import numpy.testing as npt
import pytest
import scipy.io as sio

from yasfpy.initial_field import InitialField
from yasfpy.numerics import Numerics
from yasfpy.parameters import Parameters
from yasfpy.particles import Particles
from yasfpy.simulation import Simulation
from yasfpy.solver import Solver


@pytest.fixture
def matlab_data():
    """Load MATLAB reference data for wavebundle test."""
    try:
        data = sio.loadmat("tests/data/wavebundle_test_data.mat")
        return data
    except FileNotFoundError:
        pytest.skip(
            "MATLAB test data not found. "
            "Run tests/matlab/generate_wavebundle_test_data.m to generate it."
        )


def test_wavebundle_vs_matlab(matlab_data):
    """
    Test wavebundle implementation against CELES/MATLAB reference.

    Compares initial_field_coefficients computed by YASFPY with those
    from CELES for identical Gaussian beam configuration.
    """
    print("\n" + "=" * 70)
    print("WAVEBUNDLE VALIDATION vs CELES/MATLAB")
    print("=" * 70)

    # =========================================================================
    # 1. Extract MATLAB parameters
    # =========================================================================
    print("\n1. Loading MATLAB test data...")

    lmax = int(matlab_data["lmax"][0, 0])
    wavelength = np.array([float(matlab_data["wavelength"][0, 0])])
    medium_refractive_index = np.array(
        [float(matlab_data["mediumRefractiveIndex"][0, 0])]
    )

    # Particle data (convert to float64 for calculations)
    positions = matlab_data["particles_position"].astype(np.float64)
    radii = matlab_data["particles_radius"].flatten().astype(np.float64)
    refractive_indices = matlab_data["particles_refractiveIndex"].flatten()
    num_particles = int(matlab_data["particles_number"][0, 0])

    # Gaussian beam parameters
    beam_width = float(matlab_data["initial_field_beam_width"][0, 0])
    focal_point = matlab_data["initial_field_focal_point"].flatten()
    polar_angle = float(matlab_data["initial_field_polar_angle"][0, 0])
    azimuthal_angle = float(matlab_data["initial_field_azimuthal_angle"][0, 0])

    # MATLAB stores strings as arrays, need to convert
    polarization_array = matlab_data["initial_field_polarization"]
    if isinstance(polarization_array, np.ndarray):
        polarization = (
            str(polarization_array[0]) if polarization_array.size > 0 else "TE"
        )
    else:
        polarization = str(polarization_array)

    amplitude = float(matlab_data["initial_field_amplitude"][0, 0])

    # Angular grid (for wavebundle integration)
    polar_angles_matlab = matlab_data["polar_angles"].flatten()
    azimuthal_angles_matlab = matlab_data["azimuthal_angles"].flatten()

    # Reference coefficients from CELES
    matlab_coefficients = matlab_data["initial_field_coefficients"]

    print(f"   Particles: {num_particles}")
    print(f"   lmax: {lmax}")
    print(f"   Wavelength: {wavelength[0]} nm")
    print(f"   Beam width: {beam_width} nm")
    print(f"   Polarization: {polarization}")
    print(f"   Focal point: {focal_point}")
    print(
        f"   Angular grid: {len(azimuthal_angles_matlab)} × {len(polar_angles_matlab)}"
    )
    print(f"   MATLAB coefficients shape: {matlab_coefficients.shape}")

    # =========================================================================
    # 2. Set up YASFPY simulation with identical parameters
    # =========================================================================
    print("\n2. Setting up YASFPY simulation...")

    # Create particles
    particles = Particles(
        position=positions,
        r=radii,
        refractive_index=refractive_indices,
    )

    # Create Gaussian beam with same parameters
    initial_field = InitialField(
        beam_width=beam_width,
        focal_point=focal_point,
        polar_angle=polar_angle,
        azimuthal_angle=azimuthal_angle,
        polarization=polarization,
        amplitude=amplitude,
    )

    # Create parameters
    parameters = Parameters(
        wavelength=wavelength,
        medium_refractive_index=medium_refractive_index,
        particles=particles,
        initial_field=initial_field,
    )

    # Create numerics
    # IMPORTANT: Use the same angular grid as MATLAB for consistent integration
    # The polar_angles and azimuthal_angles will be set directly
    solver = Solver(solver_type="gmres", tolerance=1e-4, max_iter=1000, restart=1000)

    numerics = Numerics(
        lmax=lmax,
        polar_angles=polar_angles_matlab,
        azimuthal_angles=azimuthal_angles_matlab,
        particle_distance_resolution=1,
        gpu=False,
        solver=solver,
    )

    print(f"   ✓ Particles created: {particles.number}")
    print(f"   ✓ Gaussian beam configured")
    print(f"   ✓ Numerics with matching angular grid")

    # =========================================================================
    # 3. Compute initial field coefficients with YASFPY
    # =========================================================================
    print("\n3. Computing initial field coefficients with YASFPY...")

    simulation = Simulation(parameters, numerics)
    simulation.compute_mie_coefficients()
    simulation.compute_initial_field_coefficients()

    yasfpy_coefficients = simulation.initial_field_coefficients[
        :, :, 0
    ]  # Shape: (particles, nmax)

    print(f"   ✓ YASFPY coefficients shape: {yasfpy_coefficients.shape}")
    print(f"   ✓ Max magnitude: {np.max(np.abs(yasfpy_coefficients)):.3e}")

    # =========================================================================
    # 4. Compare results
    # =========================================================================
    print("\n4. Comparing YASFPY vs MATLAB...")

    # MATLAB format is (particles, nmax) - same as YASFPY
    assert matlab_coefficients.shape == yasfpy_coefficients.shape, (
        f"Shape mismatch: MATLAB {matlab_coefficients.shape} vs YASFPY {yasfpy_coefficients.shape}"
    )

    # Compute differences
    abs_diff = np.abs(yasfpy_coefficients - matlab_coefficients)
    rel_diff = abs_diff / (np.abs(matlab_coefficients) + 1e-10)

    max_abs_diff = np.max(abs_diff)
    max_rel_diff = np.max(rel_diff[np.abs(matlab_coefficients) > 1e-6])
    mean_rel_diff = np.mean(rel_diff[np.abs(matlab_coefficients) > 1e-6])

    print(f"\n   Absolute differences:")
    print(f"   Max: {max_abs_diff:.3e}")
    print(f"   Mean: {np.mean(abs_diff):.3e}")

    print(f"\n   Relative differences (for significant coefficients):")
    print(f"   Max: {max_rel_diff:.3e}")
    print(f"   Mean: {mean_rel_diff:.3e}")

    # Print some example coefficients for inspection
    print(f"\n   Sample coefficients comparison:")
    print(f"   {'Index':<8} {'MATLAB':<20} {'YASFPY':<20} {'Rel Diff':<12}")
    print(f"   {'-' * 8} {'-' * 20} {'-' * 20} {'-' * 12}")

    # Find indices with largest coefficients
    matlab_flat = matlab_coefficients.flatten()
    large_indices = np.argsort(np.abs(matlab_flat))[-5:][::-1]

    for idx in large_indices:
        matlab_val = matlab_flat[idx]
        yasfpy_val = yasfpy_coefficients.flatten()[idx]
        rel_diff_val = abs(yasfpy_val - matlab_val) / (abs(matlab_val) + 1e-10)

        print(
            f"   {idx:<8} {matlab_val.real:+.3e}{matlab_val.imag:+.3e}j  "
            f"{yasfpy_val.real:+.3e}{yasfpy_val.imag:+.3e}j  {rel_diff_val:.3e}"
        )

    # =========================================================================
    # 5. Assert correctness
    # =========================================================================
    print("\n5. Validation...")

    # Tolerances (may need adjustment based on numerical integration accuracy)
    rtol = 1e-2  # 1% relative tolerance
    atol = 1e-4  # Absolute tolerance for small values

    try:
        npt.assert_allclose(
            yasfpy_coefficients,
            matlab_coefficients,
            rtol=rtol,
            atol=atol,
            err_msg=f"Wavebundle coefficients don't match MATLAB (max rel diff: {max_rel_diff:.3e})",
        )
        print(f"\n   ✓ VALIDATION PASSED!")
        print(f"   All coefficients within tolerance (rtol={rtol}, atol={atol})")

    except AssertionError as e:
        print(f"\n   ✗ VALIDATION FAILED!")
        print(f"   {str(e)}")

        # Print additional diagnostics
        print(f"\n   Diagnostics:")
        print(f"   Number of coefficients: {yasfpy_coefficients.size}")
        failing_mask = rel_diff > rtol
        num_failing = np.sum(failing_mask)
        print(
            f"   Coefficients exceeding rtol: {num_failing} ({100 * num_failing / yasfpy_coefficients.size:.1f}%)"
        )

        raise

    print("\n" + "=" * 70)
    print("VALIDATION COMPLETE")
    print("=" * 70)


def test_wavebundle_planewave_comparison(matlab_data):
    """
    Optional test: Compare wavebundle vs plane wave using MATLAB data.

    This verifies that both YASFPY and MATLAB show similar differences
    between Gaussian beam and plane wave illumination.
    """
    # Check if plane wave data is available
    if "initial_field_coefficients_planewave" not in matlab_data:
        pytest.skip("Plane wave comparison data not available in MATLAB file")

    matlab_pw = matlab_data["initial_field_coefficients_planewave"]
    if matlab_pw.size == 0:
        pytest.skip("Plane wave coefficients not computed in MATLAB")

    print("\n" + "=" * 70)
    print("GAUSSIAN BEAM vs PLANE WAVE COMPARISON")
    print("=" * 70)

    # This test would compare the relative difference between wavebundle
    # and plane wave in both MATLAB and YASFPY
    # (Implementation can be added if needed)

    print("\n   ℹ Test implementation pending")


if __name__ == "__main__":
    # For manual testing
    print("\nLoading MATLAB data...")
    data = sio.loadmat("tests/data/wavebundle_test_data.mat")

    print("\n" + "=" * 70)
    print("WAVEBUNDLE VALIDATION TESTS")
    print("=" * 70)

    test_wavebundle_vs_matlab(data)

    print("\n" + "=" * 70)
    print("ALL VALIDATION TESTS PASSED!")
    print("=" * 70)
