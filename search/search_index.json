{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to YASF","text":"<p><code>YASF</code> is a Python implementation of the <code>Celes</code> framework (based on Matlab) and extends its functionality by providing optical parameters, similar to <code>MSTM</code> (based on Fortran).</p> <p>For installation instructions, please refer to the Installation page.</p>"},{"location":"coverage/","title":"Coverage","text":""},{"location":"todo/","title":"TODO","text":"<p>As of 01.07.2022. yasf only implements the celes functionality until the calculation of the scattering coefficients. These are needed for the new <code>optics</code> class to calculate parameters found in MSTM. Expanding the functionality of yasf and improving its code base will be tracked in the TODO list here. In the future, if needed, this will be presented more like a roadmap :)</p> <ul> <li> Create pages for the documentation</li> <li> Complete the documentation of the code</li> <li> Orient the created documentation around the Di\u00e1taxis framework</li> </ul>"},{"location":"todo_gen/","title":"TODO","text":"<p>As of 01.07.2022. yasf only implements the celes functionality until the calculation of the scattering coefficients. These are needed for the new <code>optics</code> class to calculate parameters found in MSTM. Expanding the functionality of yasf and improving its code base will be tracked in the TODO list here. In the future, if needed, this will be presented more like a roadmap :)</p> <ul> <li> Create pages for the documentation</li> <li> Complete the documentation of the code</li> <li> Orient the created documentation around the Di\u00e1taxis framework</li> </ul>"},{"location":"todo_gen/#source-list","title":"Source List","text":"<p>This is an auto-generated list of TODOs in the codebase.</p> <ul> <li>parameters.py:99: legcay, needs to be removed in future!</li> <li>particles.py:46: Keep it for now, remove later...</li> <li>simulation.py:126: new, could be error prone and is not tested yet!</li> <li>simulation.py:528: Look into performing this loop in parallel</li> <li>config.py:64: import of csv files (single column)</li> <li>config.py:84: move the interpolation of data into config and away from the YASF function</li> <li>optics.py:133: No idea why the pi is needed! Check with other frameworks. Else move to efficiency below.</li> <li>adda.py:48: this needs to take into account all wavelengths</li> <li>adda.py:88: clean folders</li> <li>cpu_numba.py:92: Needs further testing!</li> <li>cpu_numba.py:93: Make it go brrrr</li> <li>cuda_numba.py:6: Implement data batching for GPUs with smaller memory</li> <li>computer_cuda.py:8: Implement data batching for GPUs with smaller memory</li> </ul>"},{"location":"getting-started/install/","title":"Install","text":""},{"location":"getting-started/install/#pip","title":"pip","text":"<p>YASF is available on pypi. To install it, use:</p> <pre><code>pip install yasfpy\n</code></pre>"},{"location":"getting-started/install/#nvidiacuda-conda","title":"Nvidia/CUDA &amp; Conda","text":"<p>To run code on the GPU, the cudetoolkit is needed. This can be installed using a provided package by nvidia, or by using the conda package as described by the numba docs. An example environment file would be as follows:</p> <pre><code>name: yasf-env\nchannels:\n  - numba\n  - conda-forge\n  - defaults\nvariables:\n  NUMBA_DISABLE_INTEL_SVML: 0\n  NUMBA_CUDA_USE_NVIDIA_BINDING: 0\ndependencies:\n  - python=3.10\n  - cudatoolkit=11.4\n  - pip\n  - pip:\n      - -r requirements.txt\n</code></pre>"},{"location":"getting-started/usage/","title":"Usage","text":""},{"location":"getting-started/usage/#command-line-interface-work-in-progress","title":"Command Line Interface (Work in progress)","text":"<p>For those not familiar with the Python programming language, <code>YASF</code> provides a command line interface (CLI) to interact with the framework. The CLI is still in internal testing and will be provided in the future.</p> <p>The CLI will allow users to run simulations without writing any Python code. The CLI will be able to read input files and write output files, as well as provide a simple interface to run simulations.</p>"},{"location":"getting-started/usage/#api","title":"API","text":"<p>The Python API is outlined in our API documentation. Please visit our examples page for an outline of examples provided in the repository.</p>"},{"location":"reference/cli/","title":"Cli","text":""},{"location":"reference/cli/#cli.cli","title":"<code>cli</code>","text":"Source code in <code>yasfpy/cli.py</code> <pre><code>@click.group()\ndef cli() -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/cli/#cli.compute","title":"<code>compute</code>","text":"Source code in <code>yasfpy/cli.py</code> <pre><code>@cli.command()\n@click.option(\n    \"--config\",\n    required=True,\n    type=str,\n    help=\"Specify the path to the config file to be used.\",\n)\n@click.option(\n    \"--cluster\",\n    type=str,\n    default=\"\",\n    help=\"File path for particle cluster specifications. Overrides the provided path in the config.\",\n)\ndef compute(config: str, cluster: str) -&gt; None:\n    handler = YASF(config, path_cluster=cluster)\n    handler.run()\n</code></pre>"},{"location":"reference/config/","title":"Config","text":""},{"location":"reference/config/#config.Config","title":"<code>Config</code>","text":"Source code in <code>yasfpy/config.py</code> <pre><code>def __init__(\n    self, path_config: str, preprocess: bool = True, path_cluster: str = \"\"\n):\n    # if type(path_config) != str:\n    if not isinstance(path_config, str):\n        raise Exception(\"The config file path needs to be a string!\")\n    _path_config = Path(path_config)\n    # self.file_type = path_config.split(\".\")[-1]\n    self.file_type = _path_config.suffix\n    match self.file_type:\n        case \".json\":\n            with open(path_config) as data:\n                self.config = json.load(data)\n        case \".yaml\" | \".yml\":\n            with open(path_config) as data:\n                self.config = yaml.safe_load(data)\n        case _:\n            raise Exception(\n                \"The provided config file needs to be a json or yaml file!\"\n            )\n    if self.config is None:\n        raise Exception(\n            f\"Could not read config file {path_config}. Check if the file exists.\"\n        )\n    self.path_cluster = (\n        self.config[\"particles\"][\"geometry\"][\"file\"]\n        if path_cluster == \"\"\n        else path_cluster\n    )\n    if not self.path_cluster.startswith(\"/\"):\n        self.path_cluster = str(_path_config.parent / self.path_cluster)\n\n    self.log = logging.getLogger(self.__class__.__module__)\n    self.__read()\n    self.__folder()\n    if preprocess:\n        self.__interpolate()\n</code></pre>"},{"location":"reference/config/#config.Config.preprocess","title":"<code>preprocess: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.file_type","title":"<code>file_type = _path_config.suffix</code>  <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.config","title":"<code>config: dict = yaml.safe_load(data)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.path_cluster","title":"<code>path_cluster: str = self.config['particles']['geometry']['file'] if path_cluster == '' else path_cluster</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.log","title":"<code>log = logging.getLogger(self.__class__.__module__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/config/#config.Config.__read","title":"<code>__read</code>","text":"Source code in <code>yasfpy/config.py</code> <pre><code>def __read(self):\n    # TODO: import of csv files (single column)\n    # wavelength\n    if isinstance(self.config[\"parameters\"][\"wavelength\"][\"data\"], list):\n        self.wavelength = self.config[\"parameters\"][\"wavelength\"][\"data\"]\n    elif isinstance(self.config[\"parameters\"][\"wavelength\"][\"data\"], dict):\n        self.wavelength = np.arange(\n            self.config[\"parameters\"][\"wavelength\"][\"data\"][\"start\"],\n            self.config[\"parameters\"][\"wavelength\"][\"data\"][\"stop\"],\n            self.config[\"parameters\"][\"wavelength\"][\"data\"][\"step\"],\n        )\n    else:\n        raise Exception(\n            \"Please provide the wavelength data as an array, or the (start, stop, step) numpy.arange parameters.\"\n        )\n    self.wavelength_scale = (\n        self.config[\"parameters\"][\"wavelength\"][\"scale\"]\n        if \"scale\" in self.config[\"parameters\"][\"wavelength\"]\n        else 1\n    )\n\n    # TODO: move the interpolation of data into config and away from the YASF function\n    # NOTE: Kinda done, but needs to be checked!\n    # refractive indices of particles\n    self.material = generate_refractive_index_table(\n        [mat[\"url\"] for mat in self.config[\"particles\"][\"material\"]]\n    )\n    self.material_scale = [\n        mat[\"scale\"] for mat in self.config[\"particles\"][\"material\"]\n    ]\n\n    # refractive index of medium\n    medium_url = (\n        self.config[\"parameters\"][\"medium\"][\"url\"]\n        if \"url\" in self.config[\"parameters\"][\"medium\"]\n        else self.config[\"parameters\"][\"medium\"]\n    )\n    self.medium = Handler(url=medium_url)\n    # self.medium = generate_refractive_index_table([medium_url])\n    # self.medium_scale = (\n    #     self.config[\"parameters\"][\"medium\"][\"scale\"]\n    #     if \"scale\" in self.config[\"parameters\"][\"medium\"]\n    #     else 1\n    # )\n\n    # particle geometry\n    delim = (\n        self.config[\"particles\"][\"geometry\"][\"delimiter\"]\n        if \"delimiter\" in self.config[\"particles\"][\"geometry\"]\n        else \",\"\n    )\n    delim = r\"\\s+\" if delim == \"whitespace\" else delim\n    spheres = pd.read_csv(\n        # self.config[\"particles\"][\"geometry\"][\"file\"],\n        self.path_cluster,\n        header=None,\n        sep=delim,\n    )\n    if spheres.shape[1] &lt; 4:\n        raise Exception(\n            \"The particle geometry file needs at least 4 columns (x, y, z, r) and an optinal refractive index column\"\n        )\n    elif spheres.shape[1] == 4:\n        self.log.info(\n            \"4 columns have been provided. Implying that all particles belong to the same material.\"\n        )\n        spheres[4] = np.zeros((spheres.shape[0], 1))\n    elif spheres.shape[1] &gt;= 5:\n        self.log.warning(\n            \"More than 5 columns have been provided. Everything after the 5th will be ignored!\"\n        )\n    self.particles_scale = (\n        self.config[\"particles\"][\"geometry\"][\"scale\"]\n        if \"scale\" in self.config[\"particles\"][\"geometry\"]\n        else 1\n    )\n    self.spheres = spheres.to_numpy()\n    # NOTE: Scale the distnaces and radii to the wavelength\n    # This should make the size parameter correct\n    self.spheres[:, :4] = (\n        self.spheres[:, :4] * self.particles_scale / self.wavelength_scale\n    )\n    self.log.info(\n        f\"Particles have been scaled by {self.particles_scale / self.wavelength_scale} to match the wavelength\"\n    )\n\n    if \"optics\" in self.config:\n        self.config[\"optics\"] = (\n            self.config[\"optics\"]\n            if isinstance(self.config[\"optics\"], bool)\n            else True\n        )\n    else:\n        self.config[\"optics\"] = True\n\n    if \"points\" in self.config:\n        points = dict(x=np.array([0]), y=np.array([0]), z=np.array([0]))\n\n        for key, value in self.config[\"points\"].items():\n            if isinstance(value, Number):\n                points[key] = np.array([value])\n            elif isinstance(value, list):\n                points[key] = np.array(value)\n            elif isinstance(value, dict):\n                points[key] = np.arange(\n                    value[\"start\"], value[\"stop\"], value[\"step\"]\n                )\n            else:\n                raise Exception(\n                    f\"The key {key} is not a valid type. Numbers, list of numbers and arange dicts are permited\"\n                )\n        x, y, z = np.meshgrid(points[\"x\"], points[\"y\"], points[\"z\"], indexing=\"ij\")\n        points = dict(x=x.ravel(), y=y.ravel(), z=z.ravel())\n        self.config[\"points\"] = points\n        self.config[\"points_shape\"] = x.shape\n</code></pre>"},{"location":"reference/config/#config.Config.__folder","title":"<code>__folder</code>","text":"Source code in <code>yasfpy/config.py</code> <pre><code>def __folder(self):\n    folder = (\n        self.config[\"output\"][\"folder\"]\n        if \"folder\" in self.config[\"output\"]\n        else \".\"\n    )\n    folder = os.sep.join(folder.replace(\"\\\\\", \"/\").split(\"/\"))\n\n    extension = (\n        self.config[\"output\"][\"extension\"]\n        if \"extension\" in self.config[\"output\"]\n        else \"pbz2\"\n    )\n    # filename = \"\"\n    # if \"file\" in self.config[\"particles\"][\"geometry\"]:\n    #     filename = self.config[\"particles\"][\"geometry\"][\"file\"].split(os.sep)[-1]\n    #     filename = filename.split(\".\")[0]\n    filename = self.path_cluster.split(os.sep)[-1]\n    # filename = filename.split(\".\")[0]\n    filename = \".\".join(filename.split(\".\")[:-1])\n    filename = (\n        self.config[\"output\"][\"filename\"]\n        if \"filename\" in self.config[\"output\"]\n        else filename\n    )\n    filename = (\n        self.config[\"output\"]\n        if isinstance(self.config[\"output\"], str)\n        else filename\n    )\n    filename = (\n        f\"{filename}.{extension}\" if len(filename.split(\".\")) == 1 else filename\n    )\n    self.output_filename = (\n        os.path.join(folder, filename) if (filename is not None) else None\n    )\n</code></pre>"},{"location":"reference/config/#config.Config.__interpolate","title":"<code>__interpolate</code>","text":"Source code in <code>yasfpy/config.py</code> <pre><code>def __interpolate(self):\n    refractive_index_interpolated = np.zeros(\n        (len(self.material), self.wavelength.size),\n        dtype=complex,\n    )\n    for idx, data in enumerate(self.material):\n        table = data[\"ref_idx\"].to_numpy().astype(float)\n        refractive_index_interpolated[idx, :] = np.interp(\n            self.wavelength * self.wavelength_scale,\n            table[:, 0] * self.material_scale[idx],\n            table[:, 1] + 1j * table[:, 2],\n            left=table[0, 1] + 1j * table[0, 2],\n            right=table[-1, 1] + 1j * table[-1, 1],\n        )\n    self.refractive_index_interpolated = refractive_index_interpolated\n\n    self.medium_refractive_index = np.array(\n        self.medium.interpolate(\n            target=self.wavelength,\n            scale=self.wavelength_scale,\n            complex=True,\n        )\n    )\n    # self.medium_refractive_index = np.interp(\n    #     self.wavelength * self.wavelength_scale,\n    #     self.medium.nk[\"w\"],\n    #     self.medium.nk[\"n\"].to_numpy() + 1j * self.medium.nk[\"k\"].to_numpy(),\n    # )\n    # self.medium_refractive_index = np.interp(\n    #     self.wavelength * self.wavelength_scale,\n    #     self.medium[0][\"ref_idx\"][\"wavelength\"] * self.medium_scale,\n    #     self.medium[0][\"ref_idx\"][\"n\"] + 1j * self.medium[0][\"ref_idx\"][\"k\"],\n    # )\n    self.medium_refractive_index.imag = 0\n</code></pre>"},{"location":"reference/config/#config.Config.process","title":"<code>process</code>","text":"Source code in <code>yasfpy/config.py</code> <pre><code>def process(self, output_path: str = \"\") -&gt; None:\n    self.export(output_path)\n</code></pre>"},{"location":"reference/config/#config.Config.export","title":"<code>export</code>","text":"Source code in <code>yasfpy/config.py</code> <pre><code>def export(self, output_path: str = \"\") -&gt; None:\n    config = copy.deepcopy(self.config)\n    if output_path == \"\":\n        output_path = (\n            f\"{datetime.now().strftime('%Y-%m-%d_%H_%M_%S')}.{config.file_type}\"\n        )\n\n    config[\"particles\"] = dict(\n        position=self.spheres.tolist(),\n        ref_idx_real=self.refractive_index_interpolated.real.tolist(),\n        ref_idx_imag=self.refractive_index_interpolated.imag.tolist(),\n    )\n    config[\"initial_field\"][\"polarization\"] = \"TE\"\n    config[\"parameters\"][\"wavelength\"] = (\n        self.wavelength * self.wavelength_scale / self.particles_scale\n    ).tolist()\n    config[\"parameters\"][\"medium\"] = dict(\n        real=self.medium_refractive_index.real.tolist(),\n        imag=self.medium_refractive_index.imag.tolist(),\n    )\n    config[\"solver\"][\"type\"] = \"GMRES\"\n\n    for key, value in config[\"points\"].items():\n        config[\"points\"][key] = value.tolist()\n\n    file_type = output_path.split(\".\")[-1] if output_path else self.file_type\n    match file_type:\n        case \"json\":\n            with open(output_path, \"w\") as outfile:\n                json.dump(config, outfile)\n        case \"yaml\" | \"yml\":\n            with open(output_path, \"w\") as outfile:\n                yaml.dump(config, outfile, default_flow_style=False)\n        case \"bz2\":\n            with bz2.BZ2File(output_path, \"w\") as outfile:\n                _pickle.dump(config, outfile)\n        case _:\n            raise Exception(\n                \"The provided output file needs to be a json or yaml file!\"\n            )\n</code></pre>"},{"location":"reference/initial_field/","title":"Initial Field","text":""},{"location":"reference/initial_field/#initial_field.InitialField","title":"<code>InitialField</code>","text":"<p>Represents an object with various parameters for a beam of light.</p> <p>Initializes an object with various parameters for a beam of light.</p> <p>Parameters:</p> Name Type Description Default <code>beam_width</code> <code>float</code> <p>The beam width parameter represents the width of the beam. It determines the spread of the beam and is typically measured as the full width at half maximum (FWHM) of the beam intensity distribution.</p> required <code>focal_point</code> <code>tuple</code> <p>The focal point is the point in space where the beam is focused. It is a coordinate in three-dimensional space (x, y, z) that represents the position of the focal point.</p> required <code>field_type</code> <code>str</code> <p>The <code>field_type</code> parameter specifies the type of field for the beam. It can be set to \"gaussian\" or any other type of field that is supported by the code. Defaults to \"gaussian\".</p> <code>'gaussian'</code> <code>amplitude</code> <code>float</code> <p>The amplitude parameter represents the maximum value or intensity of the beam. It determines the overall strength or power of the beam. Defaults to 1.</p> <code>1</code> <code>polar_angle</code> <code>float</code> <p>The <code>polar_angle</code> parameter represents the angle between the positive z-axis and the direction of propagation of the beam. It is measured in radians. Defaults to 0.</p> <code>0</code> <code>azimuthal_angle</code> <code>float</code> <p>The azimuthal angle is a measure of the angle between the projection of the vector onto the xy-plane and the positive x-axis. It determines the orientation of the beam in the xy-plane. Defaults to 0.</p> <code>0</code> <code>polarization</code> <code>str</code> <p>The \"polarization\" parameter determines the polarization of the beam. It can have two possible values: \"TE\" for transverse electric polarization and \"TM\" for transverse magnetic polarization. Defaults to \"TE\".</p> <code>'TE'</code> Source code in <code>yasfpy/initial_field.py</code> <pre><code>def __init__(\n    self,\n    beam_width,\n    focal_point,\n    field_type: str = \"gaussian\",\n    amplitude: float = 1,\n    polar_angle: float = 0,\n    azimuthal_angle: float = 0,\n    polarization: str = \"TE\",\n):\n    \"\"\"Initializes an object with various parameters for a beam of light.\n\n    Args:\n        beam_width (float): The beam width parameter represents the width of the beam. It determines the spread of the beam\n            and is typically measured as the full width at half maximum (FWHM) of the beam intensity\n            distribution.\n        focal_point (tuple): The focal point is the point in space where the beam is focused. It is a coordinate in\n            three-dimensional space (x, y, z) that represents the position of the focal point.\n        field_type (str, optional): The `field_type` parameter specifies the type of field for the beam. It can be set to\n            \"gaussian\" or any other type of field that is supported by the code. Defaults to \"gaussian\".\n        amplitude (float, optional): The amplitude parameter represents the maximum value or intensity of the beam. It determines\n            the overall strength or power of the beam. Defaults to 1.\n        polar_angle (float, optional): The `polar_angle` parameter represents the angle between the positive z-axis and the direction\n            of propagation of the beam. It is measured in radians. Defaults to 0.\n        azimuthal_angle (float, optional): The azimuthal angle is a measure of the angle between the projection of the vector onto the\n            xy-plane and the positive x-axis. It determines the orientation of the beam in the xy-plane. Defaults to 0.\n        polarization (str, optional): The \"polarization\" parameter determines the polarization of the beam. It can have two possible\n            values: \"TE\" for transverse electric polarization and \"TM\" for transverse magnetic polarization. Defaults to \"TE\".\n    \"\"\"\n    self.field_type = field_type\n    self.amplitude = amplitude\n    self.polar_angle = polar_angle\n    self.azimuthal_angle = azimuthal_angle\n    self.polarization = polarization\n    self.beam_width = beam_width\n    self.focal_point = focal_point\n\n    # self.log = log.scattering_logger(__name__)\n    self.log = logging.getLogger(self.__class__.__module__)\n    self.__setup()\n</code></pre>"},{"location":"reference/initial_field/#initial_field.InitialField.field_type","title":"<code>field_type = field_type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/initial_field/#initial_field.InitialField.amplitude","title":"<code>amplitude = amplitude</code>  <code>instance-attribute</code>","text":""},{"location":"reference/initial_field/#initial_field.InitialField.polar_angle","title":"<code>polar_angle = polar_angle</code>  <code>instance-attribute</code>","text":""},{"location":"reference/initial_field/#initial_field.InitialField.azimuthal_angle","title":"<code>azimuthal_angle = azimuthal_angle</code>  <code>instance-attribute</code>","text":""},{"location":"reference/initial_field/#initial_field.InitialField.polarization","title":"<code>polarization = polarization</code>  <code>instance-attribute</code>","text":""},{"location":"reference/initial_field/#initial_field.InitialField.beam_width","title":"<code>beam_width = beam_width</code>  <code>instance-attribute</code>","text":""},{"location":"reference/initial_field/#initial_field.InitialField.focal_point","title":"<code>focal_point = focal_point</code>  <code>instance-attribute</code>","text":""},{"location":"reference/initial_field/#initial_field.InitialField.log","title":"<code>log = logging.getLogger(self.__class__.__module__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/initial_field/#initial_field.InitialField.__set_pol_idx","title":"<code>__set_pol_idx</code>","text":"<p>Sets the polarization index based on the polarization type.</p> <p>The polarization index is determined based on the value of the <code>polarization</code> attribute. If the <code>polarization</code> is \"unp\" or 0, the polarization index is set to 0. If the <code>polarization</code> is \"te\" or 1, the polarization index is set to 1. If the <code>polarization</code> is \"tm\" or 2, the polarization index is set to 2. If the <code>polarization</code> is not a valid value, the polarization index is set to 0 and a warning message is logged.</p> Source code in <code>yasfpy/initial_field.py</code> <pre><code>def __set_pol_idx(self):\n    \"\"\"\n    Sets the polarization index based on the polarization type.\n\n    The polarization index is determined based on the value of the `polarization` attribute.\n    If the `polarization` is \"unp\" or 0, the polarization index is set to 0.\n    If the `polarization` is \"te\" or 1, the polarization index is set to 1.\n    If the `polarization` is \"tm\" or 2, the polarization index is set to 2.\n    If the `polarization` is not a valid value, the polarization index is set to 0 and a warning message is logged.\n    \"\"\"\n    if (\n        isinstance(self.polarization, str) and self.polarization.lower() == \"unp\"\n    ) or (isinstance(self.polarization, int) and self.polarization == 0):\n        # Unpolarized is also present in the MSTM output\n        self.pol = 0\n    elif (\n        isinstance(self.polarization, str) and self.polarization.lower() == \"te\"\n    ) or (isinstance(self.polarization, int) and self.polarization == 1):\n        # Coresponds to the perpendicular value found in MSTM\n        self.pol = 1\n    elif (\n        isinstance(self.polarization, str) and self.polarization.lower() == \"tm\"\n    ) or (isinstance(self.polarization, int) and self.polarization == 2):\n        # Coresponds to the parallel value found in MSTM\n        self.pol = 2\n    else:\n        self.pol = 0\n        self.log.warning(\n            \"%s is not a valid polarization type. Please use TE or TM. Reverting to unpolarized\",\n            self.polarization,\n        )\n</code></pre>"},{"location":"reference/initial_field/#initial_field.InitialField.__set_normal_incidence","title":"<code>__set_normal_incidence</code>","text":"<p>Sets the normal incidence flag based on the polar angle.</p> <p>This method checks the value of the polar angle and determines if it is close to zero. If the absolute value of the sine of the polar angle is less than 1e-5, the normal incidence flag is set to True. Otherwise, the normal incidence flag is set to False.</p> Source code in <code>yasfpy/initial_field.py</code> <pre><code>def __set_normal_incidence(self):\n    \"\"\"\n    Sets the normal incidence flag based on the polar angle.\n\n    This method checks the value of the polar angle and determines if it is close to zero.\n    If the absolute value of the sine of the polar angle is less than 1e-5, the normal incidence flag is set to True.\n    Otherwise, the normal incidence flag is set to False.\n    \"\"\"\n    self.normal_incidence = np.abs(np.sin(self.polar_angle)) &lt; 1e-5\n</code></pre>"},{"location":"reference/initial_field/#initial_field.InitialField.__setup","title":"<code>__setup</code>","text":"<p>Performs the initial setup of the field.</p> <p>This method sets the polarization index and normal incidence for the field.</p> Source code in <code>yasfpy/initial_field.py</code> <pre><code>def __setup(self):\n    \"\"\"\n    Performs the initial setup of the field.\n\n    This method sets the polarization index and normal incidence for the field.\n    \"\"\"\n    self.__set_pol_idx()\n    self.__set_normal_incidence()\n</code></pre>"},{"location":"reference/log/","title":"Log","text":""},{"location":"reference/log/#log.NUMERICS","title":"<code>NUMERICS = 15</code>  <code>module-attribute</code>","text":""},{"location":"reference/log/#log.SCATTER","title":"<code>SCATTER = 25</code>  <code>module-attribute</code>","text":""},{"location":"reference/log/#log.scattering_logger","title":"<code>scattering_logger</code>","text":"<p>Create a logger with custom log levels for scattering-related logging.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger.</p> required <p>Returns:</p> Type Description <code>Logger</code> <p>The logger object.</p> Source code in <code>yasfpy/log.py</code> <pre><code>def scattering_logger(name):\n    \"\"\"\n    Create a logger with custom log levels for scattering-related logging.\n\n    Args:\n        name (str): The name of the logger.\n\n    Returns:\n        (logging.Logger): The logger object.\n\n    \"\"\"\n    levels = [\"NUMERICS\", \"SCATTER\"]\n    methods = [_log_for_numerics, _log_for_scatter]\n    for i, level in enumerate(levels):\n        level_name = level\n        level_value = globals()[level]\n        method_name = level_name.lower()\n        if hasattr(logging, level_name):\n            # print('{} already defined in logging module'.format(level_name))\n            continue\n        if hasattr(logging, method_name):\n            # print('{} already defined in logging module'.format(method_name))\n            continue\n        if hasattr(logging.getLoggerClass(), method_name):\n            # print('{} already defined in logger class'.format(method_name))\n            continue\n\n        logging.addLevelName(level_value, level_name)\n        setattr(logging, level_name, level_value)\n        setattr(logging.getLoggerClass(), method_name, methods[i])\n        # setattr(logging, method_name, _log_to_root)\n\n    logger = logging.getLogger(name)\n    if not logger.hasHandlers():\n        formatter = logging.Formatter(fmt=\"%(levelname)s (%(name)s): %(message)s\")\n        handler = logging.StreamHandler()\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        # logger.handlers.clear()\n    logger.propagate = False\n\n    return logger\n</code></pre>"},{"location":"reference/numerics/","title":"Numerics","text":""},{"location":"reference/numerics/#numerics.Numerics","title":"<code>Numerics</code>","text":"<p>The <code>Numerics</code> class is used for numerical computations in the YASF (Yet Another Scattering Framework) library, providing methods for computing associated Legendre polynomials, translation tables, Fibonacci sphere points, and spherical unity vectors.</p> <p>The <code>__init__</code> function initializes the Numerics class with various parameters and sets up the necessary attributes.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics expansion.</p> required <code>sampling_points_number</code> <code>Union[int, ndarray]</code> <p>The <code>sampling_points_number</code> parameter specifies the number of sampling points on the unit sphere. It can be either an integer or a numpy array. If it is an integer, it represents the total number of sampling points. If it is a numpy array, it can have one or two dimensions. If</p> <code>100</code> <code>polar_angles</code> <code>ndarray</code> <p>An array containing the polar angles of the sampling points on the unit sphere.</p> <code>None</code> <code>polar_weight_func</code> <code>Callable</code> <p>The <code>polar_weight_func</code> parameter is a callable function that takes a single argument <code>x</code> and returns a value. This function is used as a weight function for the polar angles of the sampling points on the unit sphere. By default, it is set to <code>lambda x: x</code>, which</p> <code>lambda x: x</code> <code>azimuthal_angles</code> <code>ndarray</code> <p>An array containing the azimuthal angles of the sampling points on the unit sphere.</p> <code>None</code> <code>gpu</code> <code>bool</code> <p>A flag indicating whether to use GPU acceleration. If set to True, the computations will be performed on a GPU if available. If set to False, the computations will be performed on the CPU.</p> <code>False</code> <code>particle_distance_resolution</code> <code>float</code> <p>The parameter \"particle_distance_resolution\" represents the resolution of the particle distance. It determines the accuracy of the numerical computations related to particle distances in the code. The value of this parameter is set to 10.0 by default.</p> <code>10.0</code> <code>solver</code> <code>Solver</code> <p>The <code>solver</code> parameter is an optional argument that specifies the solver to use for the numerical computations. It is used to solve the scattering problem and obtain the scattering amplitudes. If no solver is provided, the default solver will be used.</p> <code>None</code> Source code in <code>yasfpy/numerics.py</code> <pre><code>def __init__(\n    self,\n    lmax: int,\n    sampling_points_number: Union[int, np.ndarray] = 100,\n    polar_angles: np.ndarray = None,\n    polar_weight_func: Callable = lambda x: x,\n    azimuthal_angles: np.ndarray = None,\n    gpu: bool = False,\n    particle_distance_resolution=10.0,\n    solver=None,\n):\n    \"\"\"The `__init__` function initializes the Numerics class with various parameters and sets up the\n    necessary attributes.\n\n    Args:\n        lmax (int): The maximum degree of the spherical harmonics expansion.\n        sampling_points_number (Union[int, np.ndarray], optional): The `sampling_points_number` parameter specifies the number of sampling points on the unit\n            sphere. It can be either an integer or a numpy array. If it is an integer, it represents the\n            total number of sampling points. If it is a numpy array, it can have one or two dimensions. If\n        polar_angles (np.ndarray): An array containing the polar angles of the sampling points on the unit sphere.\n        polar_weight_func (Callable): The `polar_weight_func` parameter is a callable function that takes a single argument `x` and\n            returns a value. This function is used as a weight function for the polar angles of the sampling\n            points on the unit sphere. By default, it is set to `lambda x: x`, which\n        azimuthal_angles (np.ndarray): An array containing the azimuthal angles of the sampling points on the unit sphere.\n        gpu (bool, optional): A flag indicating whether to use GPU acceleration. If set to True, the computations will be\n            performed on a GPU if available. If set to False, the computations will be performed on the CPU.\n        particle_distance_resolution (float): The parameter \"particle_distance_resolution\" represents the resolution of the particle\n            distance. It determines the accuracy of the numerical computations related to particle distances\n            in the code. The value of this parameter is set to 10.0 by default.\n        solver (Solver): The `solver` parameter is an optional argument that specifies the solver to use for the\n            numerical computations. It is used to solve the scattering problem and obtain the scattering\n            amplitudes. If no solver is provided, the default solver will be used.\n\n    \"\"\"\n    # self.log = log.scattering_logger(__name__)\n    self.log = logging.getLogger(self.__class__.__module__)\n    self.lmax = lmax\n\n    self.sampling_points_number = np.squeeze(sampling_points_number)\n\n    if (polar_angles is None) or (azimuthal_angles is None):\n        if self.sampling_points_number.size == 0:\n            self.sampling_points_number = np.array([100])\n            self.log.warning(\n                \"Number of sampling points cant be an empty array. Reverting to 100 points (Fibonacci sphere).\"\n            )\n        elif self.sampling_points_number.size &gt; 2:\n            self.sampling_points_number = np.array([sampling_points_number[0]])\n            self.log.warning(\n                \"Number of sampling points with more than two dimensions is not supported. Reverting to the first element in the provided array (Fibonacci sphere).\"\n            )\n\n        if self.sampling_points_number.size == 1:\n            (\n                _,\n                polar_angles,\n                azimuthal_angles,\n            ) = Numerics.compute_fibonacci_sphere_points(sampling_points_number[0])\n        elif self.sampling_points_number.size == 2:\n            # if polar_weight_func is None:\n            #   polar_weight_func = lambda x: x\n            self.polar_angles_linspace = np.pi * polar_weight_func(\n                np.linspace(0, 1, sampling_points_number[1])\n            )\n            self.azimuthal_angles_linspace = (\n                2 * np.pi * np.linspace(0, 1, sampling_points_number[0] + 1)[:-1]\n            )\n\n            polar_angles, azimuthal_angles = np.meshgrid(\n                self.polar_angles_linspace,\n                self.azimuthal_angles_linspace,\n                indexing=\"xy\",\n            )\n\n            polar_angles = polar_angles.ravel()\n            azimuthal_angles = azimuthal_angles.ravel()\n\n    else:\n        self.sampling_points_number = None\n\n    self.polar_angles = polar_angles\n    self.azimuthal_angles = azimuthal_angles\n    self.gpu = gpu\n    self.particle_distance_resolution = particle_distance_resolution\n    self.solver = solver\n\n    if self.gpu:\n        from numba import cuda\n\n        if not cuda.is_available():\n            self.log.warning(\n                \"No supported GPU in numba detected! Falling back to the CPU implementation.\"\n            )\n            self.gpu = False\n\n    self.__setup()\n</code></pre>"},{"location":"reference/numerics/#numerics.Numerics.log","title":"<code>log = logging.getLogger(self.__class__.__module__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/numerics/#numerics.Numerics.lmax","title":"<code>lmax = lmax</code>  <code>instance-attribute</code>","text":""},{"location":"reference/numerics/#numerics.Numerics.sampling_points_number","title":"<code>sampling_points_number = np.squeeze(sampling_points_number)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/numerics/#numerics.Numerics.polar_angles_linspace","title":"<code>polar_angles_linspace = np.pi * polar_weight_func(np.linspace(0, 1, sampling_points_number[1]))</code>  <code>instance-attribute</code>","text":""},{"location":"reference/numerics/#numerics.Numerics.azimuthal_angles_linspace","title":"<code>azimuthal_angles_linspace = 2 * np.pi * np.linspace(0, 1, sampling_points_number[0] + 1)[:-1]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/numerics/#numerics.Numerics.polar_angles","title":"<code>polar_angles = polar_angles</code>  <code>instance-attribute</code>","text":""},{"location":"reference/numerics/#numerics.Numerics.azimuthal_angles","title":"<code>azimuthal_angles = azimuthal_angles</code>  <code>instance-attribute</code>","text":""},{"location":"reference/numerics/#numerics.Numerics.gpu","title":"<code>gpu = gpu</code>  <code>instance-attribute</code>","text":""},{"location":"reference/numerics/#numerics.Numerics.particle_distance_resolution","title":"<code>particle_distance_resolution = particle_distance_resolution</code>  <code>instance-attribute</code>","text":""},{"location":"reference/numerics/#numerics.Numerics.solver","title":"<code>solver = solver</code>  <code>instance-attribute</code>","text":""},{"location":"reference/numerics/#numerics.Numerics.__compute_nmax","title":"<code>__compute_nmax</code>","text":"<p>The function computes the maximum number of coefficients based on the values of lmax.</p> Source code in <code>yasfpy/numerics.py</code> <pre><code>def __compute_nmax(self):\n    \"\"\"\n    The function computes the maximum number of coefficients based on the values of lmax.\n    \"\"\"\n    self.nmax = 2 * self.lmax * (self.lmax + 2)\n</code></pre>"},{"location":"reference/numerics/#numerics.Numerics.__plm_coefficients","title":"<code>__plm_coefficients</code>","text":"<p>The function computes the coefficients for the associated Legendre polynomials using the sympy library.</p> Source code in <code>yasfpy/numerics.py</code> <pre><code>def __plm_coefficients(self):\n    \"\"\"\n    The function computes the coefficients for the associated Legendre polynomials using the sympy\n    library.\n    \"\"\"\n    import sympy as sym\n\n    self.plm_coeff_table = np.zeros(\n        (2 * self.lmax + 1, 2 * self.lmax + 1, self.lmax + 1)\n    )\n\n    ct = sym.Symbol(\"ct\")\n    st = sym.Symbol(\"st\")\n    plm = legendre_normalized_trigon(2 * self.lmax, ct, y=st)\n\n    for l in range(2 * self.lmax + 1):\n        for m in range(l + 1):\n            cf = sym.poly(plm[l, m], ct, st).coeffs()\n            self.plm_coeff_table[l, m, 0 : len(cf)] = cf\n</code></pre>"},{"location":"reference/numerics/#numerics.Numerics.__setup","title":"<code>__setup</code>","text":"<p>The function performs the setup for numerical computations.</p> Source code in <code>yasfpy/numerics.py</code> <pre><code>def __setup(self):\n    \"\"\"The function performs the setup for numerical computations.\"\"\"\n    self.__compute_nmax()\n</code></pre>"},{"location":"reference/numerics/#numerics.Numerics.compute_plm_coefficients","title":"<code>compute_plm_coefficients</code>","text":"<p>The function computes the coefficients for the associated Legendre polynomials.</p> Source code in <code>yasfpy/numerics.py</code> <pre><code>def compute_plm_coefficients(self):\n    \"\"\"\n    The function computes the coefficients for the associated Legendre polynomials.\n    \"\"\"\n    self.__plm_coefficients()\n</code></pre>"},{"location":"reference/numerics/#numerics.Numerics.compute_translation_table","title":"<code>compute_translation_table</code>","text":"<p>The function computes a translation table using Wigner 3j symbols and stores the results in a numpy array.</p> Source code in <code>yasfpy/numerics.py</code> <pre><code>def compute_translation_table(self, force_compute=False):\n    \"\"\"\n    The function computes a translation table using Wigner 3j symbols and stores the results in a\n    numpy array.\n    \"\"\"\n\n    # dpath = Path(f\"{files(__package__) / 'data'}\")\n    dpath = Path.home() / \".cache\" / \"yasfpy\" / self.__class__.__name__\n    if not os.path.exists(dpath):\n        os.makedirs(dpath)\n\n    if os.path.isfile(dpath / f\"lmax{self.lmax}.pickle\") and not force_compute:\n        data_raw = dpath.joinpath(Path(f\"lmax{self.lmax}.pickle\")).read_bytes()\n        data = pickle.loads(data_raw)\n        self.translation_ab5 = data[\"wig\"]\n        self.log.info(\"Found translation table and loaded it!\")\n    else:\n        if not force_compute:\n            self.log.warning(\n                f\"Didnt find translation_ab5 table in specified directory: {dpath}\"\n            )\n\n        self.log.info(\"Computing the translation table\")\n        jmax = jmult_max(1, self.lmax)\n        self.translation_ab5 = np.zeros(\n            (jmax, jmax, 2 * self.lmax + 1), dtype=complex\n        )\n\n        # No idea why or how this value for max_two_j works,\n        # but got it through trial and error.\n        # If you get any Wigner errors, change this value (e.g. 4*lmax or lmax**2)\n        max_two_j = 3 * self.lmax + 1\n        wig.wig_table_init(max_two_j, 3)\n        wig.wig_temp_init(max_two_j)\n\n        # Could be paralilized around jmax^2!\n        # Speed-up using the index lookup table (compute_idx_lookups) instead of single_index2multi.\n        for j in range(0, jmax**2):\n            j1 = j // jmax\n            j2 = j % jmax\n            _, tau1, l1, m1 = single_index2multi(j1, self.lmax)\n            _, tau2, l2, m2 = single_index2multi(j2, self.lmax)\n            for p in range(0, 2 * self.lmax + 1):\n                if tau1 == tau2:\n                    self.translation_ab5[j1, j2, p] = (\n                        np.power(\n                            1j,\n                            abs(m1 - m2) - abs(m1) - abs(m2) + l2 - l1 + p,\n                        )\n                        * np.power(-1.0, m1 - m2)\n                        * np.sqrt(\n                            (2 * l1 + 1)\n                            * (2 * l2 + 1)\n                            / (2 * l1 * (l1 + 1) * l2 * (l2 + 1))\n                        )\n                        * (l1 * (l1 + 1) + l2 * (l2 + 1) - p * (p + 1))\n                        * np.sqrt(2 * p + 1)\n                        * wig.wig3jj_array(\n                            2 * np.array([l1, l2, p, m1, -m2, -m1 + m2])\n                        )\n                        * wig.wig3jj_array(2 * np.array([l1, l2, p, 0, 0, 0]))\n                    )\n                elif p &gt; 0:\n                    self.translation_ab5[j1, j2, p] = (\n                        np.power(\n                            1j,\n                            abs(m1 - m2) - abs(m1) - abs(m2) + l2 - l1 + p,\n                        )\n                        * np.power(-1.0, m1 - m2)\n                        * np.sqrt(\n                            (2 * l1 + 1)\n                            * (2 * l2 + 1)\n                            / (2 * l1 * (l1 + 1) * l2 * (l2 + 1))\n                        )\n                        * np.lib.scimath.sqrt(\n                            (l1 + l2 + 1 + p)\n                            * (l1 + l2 + 1 - p)\n                            * (p + l1 - l2)\n                            * (p - l1 + l2)\n                            * (2 * p + 1)\n                        )\n                        * wig.wig3jj_array(\n                            2 * np.array([l1, l2, p, m1, -m2, -m1 + m2])\n                        )\n                        * wig.wig3jj_array(2 * np.array([l1, l2, p - 1, 0, 0, 0]))\n                    )\n\n        wig.wig_table_free()\n        wig.wig_temp_free()\n\n        res = {\"wig\": self.translation_ab5}\n        with open(dpath / f\"lmax{self.lmax}.pickle\", \"wb\") as f:\n            pickle.dump(res, f)\n        self.log.info(\"Calculated translation table!\")\n</code></pre>"},{"location":"reference/numerics/#numerics.Numerics.compute_fibonacci_sphere_points","title":"<code>compute_fibonacci_sphere_points</code>  <code>staticmethod</code>","text":"<p>Computes the points on a Fibonacci sphere using the given number of points.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of points to be computed on the Fibonacci sphere. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>ndarray</code> <p>A tuple containing: - points (np.ndarray): The Cartesian points of the Fibonacci sphere. - theta (np.ndarray): The polar angles of the points on the Fibonacci sphere. - phi (np.ndarray): The azimuthal angles of the points on the Fibonacci sphere.</p> Source code in <code>yasfpy/numerics.py</code> <pre><code>@staticmethod\ndef compute_fibonacci_sphere_points(n: int = 100):\n    \"\"\"Computes the points on a Fibonacci sphere using the given number of points.\n\n    Args:\n        n (int, optional): The number of points to be computed on the Fibonacci sphere.\n            Defaults to 100.\n\n    Returns:\n        tuple (np.ndarray): A tuple containing:\n            - points (np.ndarray): The Cartesian points of the Fibonacci sphere.\n            - theta (np.ndarray): The polar angles of the points on the Fibonacci sphere.\n            - phi (np.ndarray): The azimuthal angles of the points on the Fibonacci sphere.\n    \"\"\"\n    golden_ratio = (1 + 5**0.5) / 2\n    i = np.arange(0, n)\n    phi = 2 * np.pi * (i / golden_ratio % 1)\n    theta = np.arccos(1 - 2 * i / n)\n\n    return (\n        np.stack(\n            (\n                np.sin(theta) * np.cos(phi),\n                np.sin(theta) * np.sin(phi),\n                np.cos(theta),\n            ),\n            axis=1,\n        ),\n        theta,\n        phi,\n    )\n</code></pre>"},{"location":"reference/numerics/#numerics.Numerics.compute_spherical_unity_vectors","title":"<code>compute_spherical_unity_vectors</code>","text":"<p>The function computes the spherical unity vectors e_r, e_theta, and e_phi based on the given polar and azimuthal angles.</p> Source code in <code>yasfpy/numerics.py</code> <pre><code>def compute_spherical_unity_vectors(self):\n    \"\"\"\n    The function computes the spherical unity vectors e_r, e_theta, and e_phi based on the given\n    polar and azimuthal angles.\n    \"\"\"\n    self.e_r = np.stack(\n        (\n            np.sin(self.polar_angles) * np.cos(self.azimuthal_angles),\n            np.sin(self.polar_angles) * np.sin(self.azimuthal_angles),\n            np.cos(self.polar_angles),\n        ),\n        axis=1,\n    )\n\n    self.e_theta = np.stack(\n        (\n            np.cos(self.polar_angles) * np.cos(self.azimuthal_angles),\n            np.cos(self.polar_angles) * np.sin(self.azimuthal_angles),\n            -np.sin(self.polar_angles),\n        ),\n        axis=1,\n    )\n\n    self.e_phi = np.stack(\n        (\n            -np.sin(self.azimuthal_angles),\n            np.cos(self.azimuthal_angles),\n            np.zeros_like(self.azimuthal_angles),\n        ),\n        axis=1,\n    )\n</code></pre>"},{"location":"reference/optics/","title":"Optics","text":""},{"location":"reference/optics/#optics.Optics","title":"<code>Optics</code>","text":"<p>The optics class handles the calculation of the optical scattering properties like scattering and extinction cross-sections.</p> <p>Initializes the Optics object.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>An instance of the Simulation class.</p> required Source code in <code>yasfpy/optics.py</code> <pre><code>def __init__(self, simulation: Simulation):\n    \"\"\"\n    Initializes the Optics object.\n\n    Args:\n        simulation (Simulation): An instance of the Simulation class.\n\n    \"\"\"\n    self.simulation = simulation\n\n    self.c_ext = np.zeros_like(simulation.parameters.wavelength, dtype=complex)\n    self.c_sca = np.zeros_like(simulation.parameters.wavelength, dtype=complex)\n\n    self.log = logging.getLogger(self.__class__.__module__)\n</code></pre>"},{"location":"reference/optics/#optics.Optics.simulation","title":"<code>simulation = simulation</code>  <code>instance-attribute</code>","text":""},{"location":"reference/optics/#optics.Optics.c_ext","title":"<code>c_ext = np.zeros_like(simulation.parameters.wavelength, dtype=complex)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/optics/#optics.Optics.c_sca","title":"<code>c_sca = np.zeros_like(simulation.parameters.wavelength, dtype=complex)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/optics/#optics.Optics.log","title":"<code>log = logging.getLogger(self.__class__.__module__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/optics/#optics.Optics.compute_cross_sections","title":"<code>compute_cross_sections</code>","text":"<p>Compute the scattering and extinction cross sections.</p> <p>This method calculates the scattering and extinction cross sections for the simulation. It uses the initial field coefficients and scattered field coefficients to perform the calculations.</p> Source code in <code>yasfpy/optics.py</code> <pre><code>def compute_cross_sections(self):\n    \"\"\"\n    Compute the scattering and extinction cross sections.\n\n    This method calculates the scattering and extinction cross sections for the simulation.\n    It uses the initial field coefficients and scattered field coefficients to perform the calculations.\n    \"\"\"\n    a = self.simulation.initial_field_coefficients\n    f = self.simulation.scattered_field_coefficients\n\n    c_ext = np.zeros(self.simulation.parameters.wavelengths_number, dtype=complex)\n    c_ext -= np.sum(np.conjugate(a) * f, axis=(0, 1))\n    # self.c_ext -= (\n    #     np.sum(np.conjugate(a) * f, axis=(0, 1))\n    #     / np.power(self.simulation.parameters.k_medium, 2)\n    #     * np.pi\n    # )\n\n    lmax = self.simulation.numerics.lmax\n    particle_number = self.simulation.parameters.particles.number\n    wavelengths = self.simulation.parameters.k_medium.shape[0]\n    translation_table = self.simulation.numerics.translation_ab5\n    associated_legendre_lookup = self.simulation.plm\n    spherical_bessel_lookup = self.simulation.sph_j\n    e_j_dm_phi_loopup = self.simulation.e_j_dm_phi\n\n    idx_lookup = self.simulation.idx_lookup\n\n    if self.simulation.numerics.gpu:\n        jmax = particle_number * 2 * lmax * (lmax + 2)\n        c_sca_real = np.zeros((jmax, wavelengths), dtype=float)\n        # c_sca_real = np.zeros(wavelengths, dtype=float)\n        c_sca_imag = np.zeros_like(c_sca_real)\n\n        idx_device = cuda.to_device(idx_lookup)\n        sfc_device = cuda.to_device(f)\n        c_sca_real_device = cuda.to_device(c_sca_real)\n        c_sca_imag_device = cuda.to_device(c_sca_imag)\n        translation_device = cuda.to_device(translation_table)\n        associated_legendre_device = cuda.to_device(associated_legendre_lookup)\n        spherical_bessel_device = cuda.to_device(spherical_bessel_lookup)\n        e_j_dm_phi_device = cuda.to_device(e_j_dm_phi_loopup)\n\n        threads_per_block = (16, 16, 2)\n        blocks_per_grid_x = ceil(jmax / threads_per_block[0])\n        blocks_per_grid_y = ceil(jmax / threads_per_block[1])\n        blocks_per_grid_z = ceil(wavelengths / threads_per_block[2])\n        blocks_per_grid = (blocks_per_grid_x, blocks_per_grid_y, blocks_per_grid_z)\n\n        compute_scattering_cross_section_gpu[blocks_per_grid, threads_per_block](\n            lmax,\n            particle_number,\n            idx_device,\n            sfc_device,\n            translation_device,\n            associated_legendre_device,\n            spherical_bessel_device,\n            e_j_dm_phi_device,\n            c_sca_real_device,\n            c_sca_imag_device,\n        )\n        c_sca_real = c_sca_real_device.copy_to_host()\n        c_sca_imag = c_sca_imag_device.copy_to_host()\n        c_sca_real = np.sum(c_sca_real, axis=0)\n        c_sca_imag = np.sum(c_sca_imag, axis=0)\n        c_sca = c_sca_real + 1j * c_sca_imag\n\n    else:\n        # from numba_progress import ProgressBar\n        # num_iterations = jmax * jmax * wavelengths\n        # progress = ProgressBar(total=num_iterations)\n        c_sca = compute_scattering_cross_section(\n            lmax,\n            particle_number,\n            idx_lookup,\n            f,\n            translation_table,\n            associated_legendre_lookup,\n            spherical_bessel_lookup,\n            e_j_dm_phi_loopup,\n        )\n\n    k_medium_abs_squared = np.power(np.abs(self.simulation.parameters.k_medium), 2)\n    c_sca /= k_medium_abs_squared\n    c_ext /= k_medium_abs_squared\n\n    # TODO: No idea why the pi is needed! Check with other frameworks. Else move to efficiency below.\n    self.c_ext = np.real(c_ext) * np.pi\n    self.c_sca = np.abs(c_sca) * np.pi\n\n    self.albedo = self.c_sca / self.c_ext\n</code></pre>"},{"location":"reference/optics/#optics.Optics.compute_efficiencies","title":"<code>compute_efficiencies</code>","text":"Source code in <code>yasfpy/optics.py</code> <pre><code>def compute_efficiencies(self):\n    self.q_sca = (\n        self.c_sca / self.simulation.parameters.particles.geometric_projection\n    )\n    self.q_ext = (\n        self.c_ext / self.simulation.parameters.particles.geometric_projection\n    )\n\n    self.q_ext *= np.abs(self.simulation.parameters.medium_refractive_index)\n    self.q_sca *= np.abs(self.simulation.parameters.medium_refractive_index)\n</code></pre>"},{"location":"reference/optics/#optics.Optics.compute_phase_funcition","title":"<code>compute_phase_funcition</code>","text":"<p>The function <code>compute_phase_function</code> calculates various polarization components and phase function coefficients for a given simulation.</p> <p>Parameters:</p> Name Type Description Default <code>legendre_coefficients_number</code> <code>int</code> <p>The number of Legendre coefficients to compute for the phase function. These coefficients are used to approximate the phase function using Legendre polynomials. The higher the number of coefficients, the more accurate the approximation will be.</p> <code>15</code> <code>c_and_b</code> <code>Union[bool, tuple]</code> <p>A boolean value or a tuple. If <code>True</code>, it indicates that the <code>c</code> and <code>b</code> bounds should be computed. If <code>False</code>, the function will return without computing the <code>c</code> and <code>b</code> bounds.</p> <code>False</code> Source code in <code>yasfpy/optics.py</code> <pre><code>def compute_phase_funcition(\n    self,\n    legendre_coefficients_number: int = 15,\n    c_and_b: Union[bool, tuple] = False,\n    check_phase_function: bool = False,\n):\n    \"\"\"The function `compute_phase_function` calculates various polarization components and phase\n    function coefficients for a given simulation.\n\n    Args:\n        legendre_coefficients_number (int, optional): The number of Legendre coefficients to compute\n            for the phase function. These coefficients are used to approximate the phase function\n            using Legendre polynomials. The higher the number of coefficients, the more accurate\n            the approximation will be.\n        c_and_b (Union[bool, tuple], optional): A boolean value or a tuple. If `True`, it indicates\n            that the `c` and `b` bounds should be computed. If `False`, the function will return\n            without computing the `c` and `b` bounds.\n    \"\"\"\n    pilm, taulm = spherical_functions_trigon(\n        self.simulation.numerics.lmax, self.simulation.numerics.polar_angles\n    )\n\n    if self.simulation.numerics.gpu:\n        jmax = (\n            self.simulation.parameters.particles.number\n            * self.simulation.numerics.nmax\n        )\n        angles = self.simulation.numerics.azimuthal_angles.size\n        wavelengths = self.simulation.parameters.k_medium.size\n        e_field_theta_real = np.zeros(\n            (\n                self.simulation.numerics.azimuthal_angles.size,\n                self.simulation.parameters.k_medium.size,\n            ),\n            dtype=float,\n        )\n        e_field_theta_imag = np.zeros_like(e_field_theta_real)\n        e_field_phi_real = np.zeros_like(e_field_theta_real)\n        e_field_phi_imag = np.zeros_like(e_field_theta_real)\n\n        particles_position_device = cuda.to_device(\n            self.simulation.parameters.particles.position\n        )\n        idx_device = cuda.to_device(self.simulation.idx_lookup)\n        sfc_device = cuda.to_device(self.simulation.scattered_field_coefficients)\n        k_medium_device = cuda.to_device(self.simulation.parameters.k_medium)\n        azimuthal_angles_device = cuda.to_device(\n            self.simulation.numerics.azimuthal_angles\n        )\n        e_r_device = cuda.to_device(self.simulation.numerics.e_r)\n        pilm_device = cuda.to_device(pilm)\n        taulm_device = cuda.to_device(taulm)\n        e_field_theta_real_device = cuda.to_device(e_field_theta_real)\n        e_field_theta_imag_device = cuda.to_device(e_field_theta_imag)\n        e_field_phi_real_device = cuda.to_device(e_field_phi_real)\n        e_field_phi_imag_device = cuda.to_device(e_field_phi_imag)\n\n        sizes = (jmax, angles, wavelengths)\n        threads_per_block = (16, 16, 2)\n        # blocks_per_grid = tuple(\n        #     [\n        #         ceil(sizes[k] / threads_per_block[k])\n        #         for k in range(len(threads_per_block))\n        #     ]\n        # )\n        blocks_per_grid = tuple(\n            ceil(sizes[k] / threads_per_block[k])\n            for k in range(len(threads_per_block))\n        )\n        # blocks_per_grid = (\n        #   ceil(jmax / threads_per_block[0]),\n        #   ceil(angles / threads_per_block[1]),\n        #   ceil(wavelengths / threads_per_block[2]))\n\n        # print(f\"{blocks_per_grid = }\")\n\n        compute_electric_field_angle_components_gpu[\n            blocks_per_grid, threads_per_block\n        ](\n            self.simulation.numerics.lmax,\n            particles_position_device,\n            idx_device,\n            sfc_device,\n            k_medium_device,\n            azimuthal_angles_device,\n            e_r_device,\n            pilm_device,\n            taulm_device,\n            e_field_theta_real_device,\n            e_field_theta_imag_device,\n            e_field_phi_real_device,\n            e_field_phi_imag_device,\n        )\n\n        e_field_theta_real = e_field_theta_real_device.copy_to_host()\n        e_field_theta_imag = e_field_theta_imag_device.copy_to_host()\n        e_field_phi_real = e_field_phi_real_device.copy_to_host()\n        e_field_phi_imag = e_field_phi_imag_device.copy_to_host()\n        e_field_theta = e_field_theta_real + 1j * e_field_theta_imag\n        e_field_phi = e_field_phi_real + 1j * e_field_phi_imag\n\n        intensity = np.zeros_like(e_field_theta_real)\n        dop = np.zeros_like(e_field_theta_real)\n        dolp = np.zeros_like(e_field_theta_real)\n        dolq = np.zeros_like(e_field_theta_real)\n        dolu = np.zeros_like(e_field_theta_real)\n        docp = np.zeros_like(e_field_theta_real)\n\n        intensity_device = cuda.to_device(intensity)\n        dop_device = cuda.to_device(dop)\n        dolp_device = cuda.to_device(dolp)\n        dolq_device = cuda.to_device(dolq)\n        dolu_device = cuda.to_device(dolu)\n        docp_device = cuda.to_device(docp)\n\n        sizes = (angles, wavelengths)\n        threads_per_block = (32, 32)\n        # blocks_per_grid = tuple(\n        #     [\n        #         ceil(sizes[k] / threads_per_block[k])\n        #         for k in range(len(threads_per_block))\n        #     ]\n        # )\n        blocks_per_grid = tuple(\n            ceil(sizes[k] / threads_per_block[k])\n            for k in range(len(threads_per_block))\n        )\n        compute_polarization_components_gpu[blocks_per_grid, threads_per_block](\n            self.simulation.parameters.k_medium.size,\n            self.simulation.numerics.azimuthal_angles.size,\n            e_field_theta_real_device,\n            e_field_theta_imag_device,\n            e_field_phi_real_device,\n            e_field_phi_imag_device,\n            intensity_device,\n            dop_device,\n            dolp_device,\n            dolq_device,\n            dolu_device,\n            docp_device,\n        )\n\n        intensity = intensity_device.copy_to_host()\n        dop = dop_device.copy_to_host()\n        dolp = dolp_device.copy_to_host()\n        dolq = dolq_device.copy_to_host()\n        dolu = dolu_device.copy_to_host()\n        docp = docp_device.copy_to_host()\n    else:\n        e_field_theta, e_field_phi = compute_electric_field_angle_components(\n            self.simulation.numerics.lmax,\n            self.simulation.parameters.particles.position,\n            self.simulation.idx_lookup,\n            self.simulation.scattered_field_coefficients,\n            self.simulation.parameters.k_medium,\n            self.simulation.numerics.azimuthal_angles,\n            self.simulation.numerics.e_r,\n            pilm,\n            taulm,\n        )\n\n        intensity, dop, dolp, dolq, dolu, docp = compute_polarization_components(\n            self.simulation.parameters.k_medium.size,\n            self.simulation.numerics.azimuthal_angles.size,\n            e_field_theta,\n            e_field_phi,\n        )\n\n    self.scattering_angles = self.simulation.numerics.polar_angles\n    k_medium = self.simulation.parameters.k_medium\n    if type(self.simulation.parameters.k_medium) == pd.core.series.Series:\n        k_medium = k_medium.to_numpy()\n    self.phase_function_3d = (\n        intensity\n        * 4\n        * np.pi\n        / np.power(np.abs(k_medium), 2)\n        / self.c_sca[np.newaxis, :]\n    )\n    if check_phase_function:\n        res = self.__check_phase_function()\n        assert (\n            res is True\n        ), \"The phase function does have the desired precision. Please increase the amount of angles used.\"\n\n    self.phase_function_legendre_coefficients = np.polynomial.legendre.legfit(\n        np.cos(self.scattering_angles),\n        self.phase_function_3d,\n        legendre_coefficients_number,\n    )\n\n    self.degree_of_polarization_3d = dop\n    self.degree_of_linear_polarization_3d = dolp\n    self.degree_of_linear_polarization_q_3d = dolq\n    self.degree_of_linear_polarization_u_3d = dolu\n    self.degree_of_circular_polarization_3d = docp\n\n    if (self.simulation.numerics.sampling_points_number is not None) and (\n        self.simulation.numerics.sampling_points_number.size == 2\n    ):\n        self.phase_function = np.mean(\n            np.reshape(\n                self.phase_function_3d,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n\n        self.degree_of_polarization = np.mean(\n            np.reshape(\n                dop,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n        self.degree_of_linear_polarization = np.mean(\n            np.reshape(\n                dolp,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n        self.degree_of_linear_polarization_q = np.mean(\n            np.reshape(\n                dolq,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n        self.degree_of_linear_polarization_u = np.mean(\n            np.reshape(\n                dolu,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n        self.degree_of_circular_polarization = np.mean(\n            np.reshape(\n                docp,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n\n        self.scattering_angles = np.reshape(\n            self.scattering_angles, self.simulation.numerics.sampling_points_number\n        )\n        self.scattering_angles = self.scattering_angles[0, :]\n    else:\n        self.phase_function = self.phase_function_3d\n\n        self.degree_of_polarization = dop\n        self.degree_of_linear_polarization = dolp\n        self.degree_of_linear_polarization_q = dolq\n        self.degree_of_linear_polarization_u = dolu\n        self.degree_of_circular_polarization = docp\n\n    self.c_and_b_bounds = c_and_b\n    if isinstance(c_and_b, bool):\n        if c_and_b:\n            self.c_and_b_bounds = ([-1, 0], [1, 1])\n        else:\n            return\n\n    self.__compute_c_and_b()\n</code></pre>"},{"location":"reference/optics/#optics.Optics.__check_phase_function","title":"<code>__check_phase_function</code>","text":"Source code in <code>yasfpy/optics.py</code> <pre><code>def __check_phase_function(self, precision=1e-4) -&gt; bool:\n    integral = 0\n    delta_phi = (\n        len(self.simulation.numerics.azimuthal_angles)\n        / self.simulation.numerics.sampling_points_number[0]\n    )\n    delta_theta = (\n        len(self.simulation.numerics.polar_angles)\n        / self.simulation.numerics.sampling_points_number[1]\n    )\n    for idx in self.simulation.numerics.azimuthal_angles:\n        integral += (\n            self.phase_function_3d[idx, :]\n            * delta_phi\n            * np.sin(self.simulation.numerics.azimuthal_angles[idx])\n            * delta_theta\n        )\n    if 1 - integral / (4 * np.pi) &gt; precision:\n        return False\n    return True\n</code></pre>"},{"location":"reference/optics/#optics.Optics.compute_asymmetry","title":"<code>compute_asymmetry</code>","text":"<p>Computes the asymmetry parameter by numerical integration over the phase function. Therefore depends on the chosen sampling points. Accuracy depends on the number of sampling points. ACCURACY CURRENTLY VERY MUCH IN QUESTION</p> Source code in <code>yasfpy/optics.py</code> <pre><code>def compute_asymmetry(self):\n    \"\"\"Computes the asymmetry parameter by numerical integration over the phase function.\n    Therefore depends on the chosen sampling points. Accuracy depends on the number of\n    sampling points. **ACCURACY CURRENTLY VERY MUCH IN QUESTION**\n    \"\"\"\n    sum = 0\n    delta_phi = (2 * np.pi) / self.simulation.numerics.sampling_points_number[0]\n    delta_theta = np.pi / self.simulation.numerics.sampling_points_number[1]\n    for idx in range(len(self.simulation.numerics.azimuthal_angles)):\n        rn = np.cos(self.simulation.numerics.polar_angles[idx])\n        a = (\n            self.phase_function_3d[idx, :]\n            * rn\n            * delta_phi\n            * np.sin(self.simulation.numerics.polar_angles[idx])\n            * delta_theta\n        )\n        sum += a\n    g = sum / (4 * np.pi)\n    self.g = g\n</code></pre>"},{"location":"reference/optics/#optics.Optics.__compute_correction","title":"<code>__compute_correction</code>","text":"<p>Naive implementation of a correction term to lessen the underestimation of a spheres surface via numerical integration. Does not adequately correct the result, but does improve it.</p> <p>Returns:</p> Name Type Description <code>correction_term</code> <code>float</code> <p>Computed error term</p> Source code in <code>yasfpy/optics.py</code> <pre><code>def __compute_correction(self) -&gt; float:\n    \"\"\"Naive implementation of a correction term to lessen the underestimation of a spheres surface\n    via numerical integration. Does not adequately correct the result, but does improve it.\n\n    Returns:\n        correction_term (float): Computed error term\n    \"\"\"\n    integral = 0\n    delta_phi = (2 * np.pi) / self.simulation.numerics.sampling_points_number[0]\n    delta_theta = np.pi / self.simulation.numerics.sampling_points_number[1]\n    for idx in range(len(self.simulation.numerics.azimuthal_angles)):\n        integral += (\n            np.sin(self.simulation.numerics.polar_angles[idx])\n            * delta_theta\n            * delta_phi\n        )\n    error = 1 - integral / (4 * np.pi)\n    return 12 * error / len(self.simulation.numerics.azimuthal_angles) ** 2\n</code></pre>"},{"location":"reference/optics/#optics.Optics.compute_asymmetry_corrected","title":"<code>compute_asymmetry_corrected</code>","text":"<p>Computes asymmetry parameter via numerical integration over the phase function. Makes use of a correction term for the surface to compensate for underestimation of the spaces surface area. Therefore depends on the chosen sampling points. Accuracy depends on the number of sampling points. ACCURACY CURRENTLY VERY MUCH IN QUESTION</p> Source code in <code>yasfpy/optics.py</code> <pre><code>def compute_asymmetry_corrected(self):\n    \"\"\"Computes asymmetry parameter via numerical integration over the phase function.\n    Makes use of a correction term for the surface to compensate for underestimation\n    of the spaces surface area. Therefore depends on the chosen sampling points.\n    Accuracy depends on the number of sampling points.\n    **ACCURACY CURRENTLY VERY MUCH IN QUESTION**\n    \"\"\"\n    correction_term = self.__compute_correction()\n    print(correction_term)\n    sum = 0\n    delta_phi = (2 * np.pi) / self.simulation.numerics.sampling_points_number[0]\n    delta_theta = np.pi / self.simulation.numerics.sampling_points_number[1]\n    for idx in range(len(self.simulation.numerics.azimuthal_angles)):\n        rn = np.cos(self.simulation.numerics.polar_angles[idx])\n        a = (\n            self.phase_function_3d[idx, :]\n            * rn\n            * delta_phi\n            * np.sin(self.simulation.numerics.polar_angles[idx])\n            * delta_theta\n        )\n        correction = self.phase_function_3d[idx, :] * rn * correction_term\n        sum += a\n        sum += correction\n    g = sum / (4 * np.pi)\n    self.g_corr = g\n</code></pre>"},{"location":"reference/optics/#optics.Optics.compute_asymmetry_coeff","title":"<code>compute_asymmetry_coeff</code>","text":"<p>WIP: Tried using the scattered field coefficients p &amp; q to calculate the asymmetry parameter. Does not work. Might however be subject to further investigation, to achievce more reliable results.</p> Source code in <code>yasfpy/optics.py</code> <pre><code>def compute_asymmetry_coeff(self):\n    \"\"\"WIP: Tried using the scattered field coefficients p &amp; q to calculate the asymmetry parameter.\n    Does **not** work. Might however be subject to further investigation,\n    to achievce more reliable results.\n    \"\"\"\n    A = self.simulation.scattered_field_coefficients\n    a_i = []\n    b_i = []\n    for n in range(A.shape[1]):\n        _, tau, _, _ = single_index2multi(n, self.simulation.numerics.lmax)\n        if tau == 1:\n            a_i.append(A[:, n, :])\n        else:\n            b_i.append(A[:, n, :])\n\n    g = []\n    for wv in range(self.simulation.parameters.wavelength.shape[0]):\n        sum_term = 0\n        for i_n in range(len(a_i) - 1):\n            n = i_n + 1\n            a_n = np.squeeze(a_i[i_n][:, wv])\n            b_n = np.squeeze(b_i[i_n][:, wv])\n            a_n2 = np.squeeze(a_i[i_n + 1][:, wv])\n            b_n2 = np.squeeze(b_i[i_n + 1][:, wv])\n            p1 = (\n                np.dot(a_n, np.conj(a_n2)) + np.dot(b_n, np.conj(b_n2))\n            ).real  # *((n*(n+2))/(n+1))\n            p2 = (np.dot(a_n, np.conj(b_n))).real  # *((2*n+1)/(n*(n+1)))\n            sum_term += p1 + p2\n        g_wv = (\n            (4 * np.pi)\n            / (\n                np.power(np.abs(self.simulation.parameters.k_particle[:, wv]), 2)\n                * self.c_sca[wv]\n            )\n        ) * sum_term\n        g.append(g_wv)\n    self.g = g\n    return g\n</code></pre>"},{"location":"reference/optics/#optics.Optics.compute_double_henyey_greenstein","title":"<code>compute_double_henyey_greenstein</code>  <code>staticmethod</code>","text":"<p>Calculates the scattering phase function using the double Henyey-Greenstein model.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>ndarray</code> <p>A numpy array representing the scattering angle. It contains the values at which you want to compute the double Henyey-Greenstein phase function.</p> required <code>cb</code> <code>ndarray</code> <p>A numpy array that represents the coefficients of the double Henyey-Greenstein phase function. It should have a size of either 2 or 3.</p> required <p>Returns:</p> Name Type Description <code>p</code> <code>ndarray</code> <p>Computed Henyey-Greenstein phase function.</p> Source code in <code>yasfpy/optics.py</code> <pre><code>@staticmethod\ndef compute_double_henyey_greenstein(theta: np.ndarray, cb: np.ndarray):\n    \"\"\"\n    Calculates the scattering phase function using the double Henyey-Greenstein model.\n\n    Args:\n        theta (np.ndarray): A numpy array representing the scattering angle. It contains the\n            values at which you want to compute the double Henyey-Greenstein phase function.\n        cb (np.ndarray): A numpy array that represents the coefficients of the double\n            Henyey-Greenstein phase function. It should have a size of either 2 or 3.\n\n    Returns:\n        p (np.ndarray): Computed Henyey-Greenstein phase function.\n    \"\"\"\n    cb = np.squeeze(cb)\n    if cb.size &lt; 2:\n        cb = np.array([0, 0.5, 0.5])\n    elif cb.size == 2:\n        cb = np.append(cb, cb[1])\n    elif cb.size &gt; 3:\n        cb = cb[:2]\n\n    p1 = (1 - cb[1] ** 2) / np.power(\n        1 - 2 * cb[1] * np.cos(theta) + cb[1] ** 2, 3 / 2\n    )\n    p2 = (1 - cb[2] ** 2) / np.power(\n        1 + 2 * cb[2] * np.cos(theta) + cb[2] ** 2, 3 / 2\n    )\n    return (1 - cb[0]) / 2 * p1 + (1 + cb[0]) / 2 * p2\n</code></pre>"},{"location":"reference/optics/#optics.Optics.__compute_c_and_b","title":"<code>__compute_c_and_b</code>","text":"<p>The function computes the values of parameters 'b' and 'c' using the double Henyey-Greenstein phase function.</p> Source code in <code>yasfpy/optics.py</code> <pre><code>def __compute_c_and_b(self):\n    \"\"\"The function computes the values of parameters 'b' and 'c' using the double Henyey-Greenstein\n    phase function.\n    \"\"\"\n    # double henyey greenstein\n    if len(self.c_and_b_bounds[0]) not in [2, 3]:\n        self.c_and_b_bounds = ([-1, 0], [1, 1])\n        self.log.warning(\n            \"Number of parameters need to be 2 (b,c) or 3 (b1,b2,c). Reverting to two parameters (b,c) and setting the bounds to standard: b in [0, 1] and c in [-1, 1]\"\n        )\n\n    from scipy.optimize import least_squares\n\n    if len(self.c_and_b_bounds) == 2:\n        bc0 = np.array([0, 0.5])\n    else:\n        bc0 = np.array([0, 0.5, 0.5])\n\n    self.cb = np.empty((self.phase_function.shape[1], len(self.c_and_b_bounds)))\n    for w in range(self.phase_function.shape[1]):\n        # def dhg_optimization(bc):\n        #     return (\n        #         Optics.compute_double_henyey_greenstein(self.scattering_angles, bc)\n        #         - self.phase_function[:, w]\n        #     )\n\n        # bc = least_squares(\n        #     dhg_optimization, bc0, jac=\"2-point\", bounds=self.c_and_b_bounds\n        # )\n\n        bc = least_squares(\n            lambda bc: Optics.compute_double_henyey_greenstein(\n                self.scattering_angles, bc\n            )\n            - self.phase_function[:, w],\n            bc0,\n            jac=\"2-point\",\n            bounds=self.c_and_b_bounds,\n        )\n        self.cb[w, :] = bc.x\n</code></pre>"},{"location":"reference/optics/#optics.Optics.compute_phase_function","title":"<code>compute_phase_function</code>","text":"<p>Generalized batching for phase function computation</p> <p>Parameters:</p> Name Type Description Default <code>legendre_coefficients_number</code> <code>int</code> <p>The number of Legendre coefficients to compute for the phase function. These coefficients are used to approximate the phase function using Legendre polynomials. The higher the number of coefficients, the more accurate the approximation will be.</p> <code>15</code> <code>c_and_b</code> <code>Union[bool, tuple]</code> <p>A boolean value or a tuple. If <code>True</code>, it indicates that the <code>c</code> and <code>b</code> bounds should be computed. If <code>False</code>, the function will return without computing the <code>c</code> and <code>b</code> bounds.</p> <code>False</code> Source code in <code>yasfpy/optics.py</code> <pre><code>def compute_phase_function(\n    self,\n    legendre_coefficients_number: int = 15,\n    c_and_b: Union[bool, tuple] = False,\n    check_phase_function: bool = False,\n):\n    \"\"\"Generalized batching for phase function computation\n\n    Args:\n        legendre_coefficients_number (int, optional): The number of Legendre coefficients to compute\n            for the phase function. These coefficients are used to approximate the phase function\n            using Legendre polynomials. The higher the number of coefficients, the more accurate\n            the approximation will be.\n        c_and_b (Union[bool, tuple], optional): A boolean value or a tuple. If `True`, it indicates\n            that the `c` and `b` bounds should be computed. If `False`, the function will return\n            without computing the `c` and `b` bounds.\n    \"\"\"\n    pilm, taulm = spherical_functions_trigon(\n        self.simulation.numerics.lmax, self.simulation.numerics.polar_angles\n    )\n\n    if self.simulation.numerics.gpu:\n        jmax = (\n            self.simulation.parameters.particles.number\n            * self.simulation.numerics.nmax\n        )\n        angles = self.simulation.numerics.azimuthal_angles.size\n        wavelengths = self.simulation.parameters.k_medium.size\n        e_field_theta_real = np.zeros(\n            (\n                self.simulation.numerics.azimuthal_angles.size,\n                self.simulation.parameters.k_medium.size,\n            ),\n            dtype=float,\n        )\n        e_field_theta_imag = np.zeros_like(e_field_theta_real)\n        e_field_phi_real = np.zeros_like(e_field_theta_real)\n        e_field_phi_imag = np.zeros_like(e_field_theta_real)\n\n        # stuff we need in full for every iteration\n        device_data = [\n            self.simulation.parameters.particles.position,\n            self.simulation.idx_lookup,\n            self.simulation.scattered_field_coefficients,\n            self.simulation.parameters.k_medium,\n        ]\n\n        sizes = (jmax, angles, wavelengths)\n        threads_per_block = (16, 16, 2)\n\n        blocks_per_grid = tuple(\n            ceil(sizes[k] / threads_per_block[k])\n            for k in range(len(threads_per_block))\n        )\n        to_split = [\n            np.ascontiguousarray(self.simulation.numerics.azimuthal_angles),\n            np.ascontiguousarray(self.simulation.numerics.e_r),\n            np.ascontiguousarray(pilm),\n            np.ascontiguousarray(taulm),\n            np.ascontiguousarray(e_field_theta_real),\n            np.ascontiguousarray(e_field_theta_imag),\n            np.ascontiguousarray(e_field_phi_real),\n            np.ascontiguousarray(e_field_phi_imag),\n        ]\n\n        idx_to_split = self.simulation.numerics.azimuthal_angles.shape[0]\n\n        idx_per_array = []\n        for array in to_split:\n            idx_per_array.append(\n                np.where(np.array(array.shape) == idx_to_split)[0][0]\n            )\n\n        threads_per_block = (1, 16 * 16, 2)\n        external_args = [self.simulation.numerics.lmax]\n        sizes_idx_split = 1\n        res = self.__data_batching(\n            external_args,\n            device_data,\n            to_split,\n            sizes,\n            sizes_idx_split,\n            idx_to_split,\n            idx_per_array,\n            compute_electric_field_angle_components_gpu,\n            threads_per_block,\n        )\n        e_field_theta_real = res[4]\n        e_field_theta_imag = res[5]\n        e_field_phi_real = res[6]\n        e_field_phi_imag = res[7]\n\n        e_field_theta = e_field_theta_real + 1j * e_field_theta_imag\n        e_field_phi = e_field_phi_real + 1j * e_field_phi_imag\n\n        print(\"...................................................\")\n        print(\"Done with e field calculations...\")\n        print(\"...................................................\")\n        # continue with next calculation\n\n        intensity = np.zeros_like(e_field_theta_real)\n        dop = np.zeros_like(e_field_theta_real)\n        dolp = np.zeros_like(e_field_theta_real)\n        dolq = np.zeros_like(e_field_theta_real)\n        dolu = np.zeros_like(e_field_theta_real)\n        docp = np.zeros_like(e_field_theta_real)\n\n        to_split = [\n            np.ascontiguousarray(e_field_theta_real),\n            np.ascontiguousarray(e_field_theta_imag),\n            np.ascontiguousarray(e_field_phi_real),\n            np.ascontiguousarray(e_field_phi_imag),\n            np.ascontiguousarray(intensity),\n            np.ascontiguousarray(dop),\n            np.ascontiguousarray(dolp),\n            np.ascontiguousarray(dolq),\n            np.ascontiguousarray(dolu),\n            np.ascontiguousarray(docp),\n        ]\n        threads_per_block = (\n            1024,\n            1,\n        )  # this allows ~65000 wavelengths, limits required batching\n\n        idx_per_array = [0] * len(to_split)\n\n        sizes = (angles, wavelengths)\n        size_idx_split = 0\n\n        external_args = [\n            self.simulation.parameters.k_medium.size,\n            self.simulation.numerics.azimuthal_angles.size,\n        ]\n        res = self.__data_batching(\n            external_args,\n            [],\n            to_split,\n            sizes,\n            size_idx_split,\n            idx_to_split,\n            idx_per_array,\n            compute_polarization_components_gpu,\n            threads_per_block,\n        )\n\n        intensity = res[4]\n        dop = res[5]\n        dolp = res[6]\n        dolq = res[7]\n        dolu = res[8]\n        docp = res[9]\n\n    else:\n        e_field_theta, e_field_phi = compute_electric_field_angle_components(\n            self.simulation.numerics.lmax,\n            self.simulation.parameters.particles.position,\n            self.simulation.idx_lookup,\n            self.simulation.scattered_field_coefficients,\n            self.simulation.parameters.k_medium,\n            self.simulation.numerics.azimuthal_angles,\n            self.simulation.numerics.e_r,\n            pilm,\n            taulm,\n        )\n\n        intensity, dop, dolp, dolq, dolu, docp = compute_polarization_components(\n            self.simulation.parameters.k_medium.size,\n            self.simulation.numerics.azimuthal_angles.size,\n            e_field_theta,\n            e_field_phi,\n        )\n\n    self.scattering_angles = self.simulation.numerics.polar_angles\n    k_medium = self.simulation.parameters.k_medium\n    if type(self.simulation.parameters.k_medium) == pd.core.series.Series:\n        k_medium = k_medium.to_numpy()\n    self.phase_function_3d = (\n        intensity\n        * 4\n        * np.pi\n        / np.power(np.abs(k_medium), 2)\n        / self.c_sca[np.newaxis, :]\n    )\n    if check_phase_function:\n        res = self.__check_phase_function()\n        assert (\n            res is True\n        ), \"The phase function does have the desired precision. Please increase the amount of angles used.\"\n\n    self.phase_function_legendre_coefficients = np.polynomial.legendre.legfit(\n        np.cos(self.scattering_angles),\n        self.phase_function_3d,\n        legendre_coefficients_number,\n    )\n\n    self.degree_of_polarization_3d = dop\n    self.degree_of_linear_polarization_3d = dolp\n    self.degree_of_linear_polarization_q_3d = dolq\n    self.degree_of_linear_polarization_u_3d = dolu\n    self.degree_of_circular_polarization_3d = docp\n\n    if (self.simulation.numerics.sampling_points_number is not None) and (\n        self.simulation.numerics.sampling_points_number.size == 2\n    ):\n        self.phase_function = np.mean(\n            np.reshape(\n                self.phase_function_3d,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n\n        self.degree_of_polarization = np.mean(\n            np.reshape(\n                dop,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n        self.degree_of_linear_polarization = np.mean(\n            np.reshape(\n                dolp,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n        self.degree_of_linear_polarization_q = np.mean(\n            np.reshape(\n                dolq,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n        self.degree_of_linear_polarization_u = np.mean(\n            np.reshape(\n                dolu,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n        self.degree_of_circular_polarization = np.mean(\n            np.reshape(\n                docp,\n                np.append(\n                    self.simulation.numerics.sampling_points_number,\n                    self.simulation.parameters.k_medium.size,\n                ),\n            ),\n            axis=0,\n        )\n\n        self.scattering_angles = np.reshape(\n            self.scattering_angles, self.simulation.numerics.sampling_points_number\n        )\n        self.scattering_angles = self.scattering_angles[0, :]\n    else:\n        self.phase_function = self.phase_function_3d\n\n        self.degree_of_polarization = dop\n        self.degree_of_linear_polarization = dolp\n        self.degree_of_linear_polarization_q = dolq\n        self.degree_of_linear_polarization_u = dolu\n        self.degree_of_circular_polarization = docp\n\n    self.c_and_b_bounds = c_and_b\n    if isinstance(c_and_b, bool):\n        if c_and_b:\n            self.c_and_b_bounds = ([-1, 0], [1, 1])\n        else:\n            return\n\n    self.__compute_c_and_b()\n</code></pre>"},{"location":"reference/optics/#optics.Optics.__data_batching","title":"<code>__data_batching</code>","text":"Source code in <code>yasfpy/optics.py</code> <pre><code>def __data_batching(\n    self,\n    external_args: list,\n    device_data: list[np.ndarray],\n    to_split: list[np.ndarray],\n    sizes: tuple,\n    size_split_idx: int,\n    idx_to_split: int,\n    idx_per_array: list[int],\n    cuda_kernel: Callable,\n    threads_per_block: tuple,\n):\n    total_bytes = 0\n    for array in to_split:\n        total_bytes += array.size * array.itemsize\n    # put device data onto array\n    device_data2 = []\n    for arr in device_data:\n        device_data2.append(cuda.to_device(arr))\n\n    start_idx = 0\n    split_idx = 0\n    done = False\n\n    # build arrays for results\n    # axis along which we split needs to be zero\n    res = []\n    for i, item in enumerate(to_split):\n        needed_shape = list(item.shape)\n        needed_shape[idx_per_array[i]] = 0\n        needed_shape = tuple(needed_shape)\n        res.append(np.empty(needed_shape, float))\n\n    print(f\"Need to process {total_bytes*1e-9} GB of data\")\n\n    while not done:\n        split_idx = self.__compute_data_split(\n            to_split,\n            idx_list=idx_per_array,\n            threads_per_block=threads_per_block[size_split_idx],\n        )\n        if split_idx &lt; 1:\n            break\n        if split_idx + start_idx &gt; idx_to_split:\n            print(\"End, reset split_idx\")\n            split_idx = idx_to_split - start_idx\n\n        split_data = []\n        for i, item in enumerate(to_split):\n            split_data.append(\n                np.take(\n                    item,\n                    range(start_idx, start_idx + split_idx),\n                    axis=idx_per_array[i],\n                )\n            )\n\n        # check total size of data to be put on GPU\n        used_bytes = 0\n        for array in split_data:\n            used_bytes += array.size * array.itemsize\n        total_bytes -= used_bytes\n        print(f\"{total_bytes*1e-9} GB of data remaining\")\n\n        # modify number of blocks per grid needed for kernel with current split\n        sizes2 = list(sizes)\n        sizes2[size_split_idx] = len(range(start_idx, (start_idx + split_idx)))\n        sizes = tuple(sizes2)\n        blocks_per_grid = tuple(\n            ceil(sizes[k] / threads_per_block[k])\n            for k in range(len(threads_per_block))\n        )\n\n        # send data to device\n        batched_device_data = []\n        for i in range(len(to_split)):\n            batched_device_data.append(cuda.to_device(split_data[i]))\n\n        # call kernel\n        arg_list = external_args + device_data2 + batched_device_data\n        cuda_kernel[blocks_per_grid, threads_per_block](*arg_list)\n\n        # receive batched data results\n        for i, item in enumerate(batched_device_data):\n            res[i] = np.append(\n                res[i],\n                np.array(item.copy_to_host()),\n                axis=idx_per_array[i],\n            )\n\n        # deallocate objects that use data on gpu so that cuda will deallocate memory\n        del batched_device_data, split_data, arg_list\n\n        # update start_idx\n        start_idx += split_idx\n        if start_idx &gt;= idx_to_split:\n            done = True\n\n    return res\n</code></pre>"},{"location":"reference/optics/#optics.Optics.__compute_data_split","title":"<code>__compute_data_split</code>","text":"Source code in <code>yasfpy/optics.py</code> <pre><code>def __compute_data_split(\n    self, data: list[np.ndarray], idx_list: list, threads_per_block: int\n) -&gt; int:\n    device = cuda.select_device(0)\n    handle = cuda.cudadrv.devices.get_context()\n    mem_info = cuda.cudadrv.driver.Context(device, handle).get_memory_info()\n    buffer = 0.05 * mem_info.total  # buffer to accomodate for varying GPU mem usage\n    free_bytes = mem_info.free - buffer\n    total_data_bytes = 0\n    for array in data:\n        total_data_bytes += array.size * array.itemsize\n\n    print(\"---------------------------------------------------\")\n    idx = data[0].shape[idx_list[0]]\n    num = idx\n    while total_data_bytes &gt; free_bytes:\n        new_data_bytes = 0\n        num -= 1000\n        for i, item in enumerate(data):\n            temp_shape = item.shape\n            temp_size = 1\n            for s in temp_shape:\n                if s == idx:\n                    temp_size *= num\n                else:\n                    temp_size *= s\n            new_data_bytes += temp_size * item.itemsize\n        total_data_bytes = new_data_bytes\n\n    print(f\"{free_bytes*1e-9} GB of data available on GPU\")\n    print(f\"Unused GPU memory: {(free_bytes-total_data_bytes)*1e-6} MB\")\n\n    if num // threads_per_block &gt; 2**16 - 1:\n        num = (2**16 - 1) * threads_per_block\n        print(\n            \"Need to limit number of blocks due to limited number of blocks per grid!\"\n        )\n\n    print(\"---------------------------------------------------\")\n    return num\n</code></pre>"},{"location":"reference/parameters/","title":"Parameters","text":""},{"location":"reference/parameters/#parameters.Parameters","title":"<code>Parameters</code>","text":"<p>The Parameters class represents the parameters for a simulation, including wavelength, refractive indices, scattering particles, and initial field, and provides methods for computing angular frequency and wave vectors.</p> <p>Initializes the class with the given parameters and sets up the necessary variables.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>array</code> <p>An array that represents the wavelengths of the light being used. It contains the values of the wavelengths at which the simulation will be performed.</p> required <code>medium_refractive_index</code> <code>array</code> <p>An array that represents the refractive index of the medium in which the particles are located. It contains the refractive index values at different wavelengths.</p> required <code>particles</code> <code>Particles</code> <p>An instance of the \"Particles\" class. It represents the particles present in the medium.</p> required <code>initial_field</code> <code>InitialField</code> <p>An object of the <code>InitialField</code> class. It represents the initial field configuration for the simulation.</p> required Source code in <code>yasfpy/parameters.py</code> <pre><code>def __init__(\n    self,\n    wavelength: np.ndarray,\n    medium_refractive_index: np.ndarray,\n    particles: Particles,\n    initial_field: InitialField,\n):\n    \"\"\"Initializes the class with the given parameters and sets up the necessary variables.\n\n    Args:\n        wavelength (np.array): An array that represents the wavelengths of the light being used.\n            It contains the values of the wavelengths at which the simulation will be performed.\n        medium_refractive_index (np.array): An array that represents the refractive index of the\n            medium in which the particles are located. It contains the refractive index values at different\n            wavelengths.\n        particles (Particles): An instance of the \"Particles\" class. It represents the particles\n            present in the medium.\n        initial_field (InitialField): An object of the `InitialField` class. It represents the\n            initial field configuration for the simulation.\n    \"\"\"\n    self.wavelength = np.array(wavelength)\n    self.medium_refractive_index = medium_refractive_index\n    self.wavelengths_number = wavelength.size\n    self.particles = particles\n    self.initial_field = initial_field\n\n    self.__setup()\n</code></pre>"},{"location":"reference/parameters/#parameters.Parameters.wavelength","title":"<code>wavelength = np.array(wavelength)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/parameters/#parameters.Parameters.medium_refractive_index","title":"<code>medium_refractive_index = medium_refractive_index</code>  <code>instance-attribute</code>","text":""},{"location":"reference/parameters/#parameters.Parameters.wavelengths_number","title":"<code>wavelengths_number = wavelength.size</code>  <code>instance-attribute</code>","text":""},{"location":"reference/parameters/#parameters.Parameters.particles","title":"<code>particles = particles</code>  <code>instance-attribute</code>","text":""},{"location":"reference/parameters/#parameters.Parameters.initial_field","title":"<code>initial_field = initial_field</code>  <code>instance-attribute</code>","text":""},{"location":"reference/parameters/#parameters.Parameters.__setup","title":"<code>__setup</code>","text":"<p>The function sets up the necessary computations for omega and ks.</p> Source code in <code>yasfpy/parameters.py</code> <pre><code>def __setup(self):\n    \"\"\"The function sets up the necessary computations for omega and ks.\"\"\"\n    self.__compute_omega()\n    self.__compute_ks()\n</code></pre>"},{"location":"reference/parameters/#parameters.Parameters.__compute_omega","title":"<code>__compute_omega</code>","text":"<p>The function calculates the value of omega using the wavelength.</p> Source code in <code>yasfpy/parameters.py</code> <pre><code>def __compute_omega(self):\n    \"\"\"The function calculates the value of omega using the wavelength.\"\"\"\n    self.omega = 2 * np.pi / self.wavelength\n</code></pre>"},{"location":"reference/parameters/#parameters.Parameters.__interpolate_refractive_index_from_table","title":"<code>__interpolate_refractive_index_from_table</code>","text":"<p>Interpolates the refractive index values from a table for different wavelengths.</p> <p>Returns:</p> Name Type Description <code>refractive_index_interpolated</code> <code>array</code> <p>An array that contains the interpolated refractive index values for the particles at different wavelengths.</p> Source code in <code>yasfpy/parameters.py</code> <pre><code>def __interpolate_refractive_index_from_table(self):\n    \"\"\"Interpolates the refractive index values from a table for different wavelengths.\n\n    Returns:\n        refractive_index_interpolated (np.array): An array that contains the interpolated refractive index values for the particles\n            at different wavelengths.\n    \"\"\"\n    refractive_index_interpolated = np.zeros(\n        (self.particles.num_unique_refractive_indices, self.wavelength.size),\n        dtype=complex,\n    )\n    for idx, data in enumerate(self.particles.refractive_index_table):\n        table = data[\"ref_idx\"].to_numpy().astype(float)\n        n = np.interp(\n            self.wavelength,\n            table[:, 0],\n            table[:, 1],\n            left=table[0, 1],\n            right=table[-1, 1],\n        )\n        k = np.interp(\n            self.wavelength,\n            table[:, 0],\n            table[:, 2],\n            left=table[0, 2],\n            right=table[-1, 2],\n        )\n        refractive_index_interpolated[idx, :] = n + 1j * k\n    return refractive_index_interpolated\n</code></pre>"},{"location":"reference/parameters/#parameters.Parameters.__index_to_table","title":"<code>__index_to_table</code>","text":"Todo <p>do all the idx to value conversion here</p> Source code in <code>yasfpy/parameters.py</code> <pre><code>def __index_to_table(self):\n    \"\"\"\n    Todo:\n        do all the idx to value conversion here\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/parameters/#parameters.Parameters.__compute_ks","title":"<code>__compute_ks</code>","text":"<p>Computes the values of k_medium and k_particle based on the refractive index of the medium and particles.</p> Source code in <code>yasfpy/parameters.py</code> <pre><code>def __compute_ks(self):\n    \"\"\"Computes the values of k_medium and k_particle based on the refractive index of the\n    medium and particles.\n    \"\"\"\n    self.k_medium = self.omega * self.medium_refractive_index\n    if self.particles.refractive_index_table is None:\n        self.ref_idx_table = None\n        self.k_particle = np.outer(self.particles.refractive_index, self.omega)\n    else:\n        if isinstance(self.particles.refractive_index_table, list):\n            # TODO: legcay, needs to be removed in future!\n            self.ref_idx_table = self.__interpolate_refractive_index_from_table()\n        else:\n            self.ref_idx_table = self.particles.refractive_index_table\n\n        self.k_particle = (\n            np.take(self.ref_idx_table, self.particles.refractive_index, axis=0)\n            * np.array(self.omega)[np.newaxis, :]\n        )\n\n        unique_radius_index_pairs = np.zeros(\n            (\n                self.particles.unique_radius_index_pairs.shape[0],\n                self.wavelength.size + 1,\n            ),\n            dtype=complex,\n        )\n        unique_radius_index_pairs[:, 0] = self.particles.unique_radius_index_pairs[\n            :, 0\n        ]\n        unique_radius_index_pairs[:, 1:] = np.take(\n            self.ref_idx_table,\n            self.particles.unique_radius_index_pairs[:, 1].astype(int),\n            axis=0,\n        )\n\n        self.particles.unique_radius_index_pairs = unique_radius_index_pairs\n</code></pre>"},{"location":"reference/particles/","title":"Particles","text":""},{"location":"reference/particles/#particles.Particles","title":"<code>Particles</code>","text":"<p>The <code>Particles</code> class represents a collection of particles with various properties such as position, radius, and refractive index, and provides methods for computing unique properties and characteristics of the particles.</p> <p>Initializes an object with position, radius, refractive index, refractive index table, and shape type attributes.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>array</code> <p>A numpy array representing the position of the shape.</p> required <code>r</code> <code>array</code> <p>A numpy array containing the radius values for each shape in the system.</p> required <code>refractive_index</code> <code>array</code> <p>A numpy array representing the refractive index of the shape. It can be either a complex number or a two-column matrix.</p> required <code>refractive_index_table</code> <code>list</code> <p>A list containing the refractive index values for different materials. Each element in the list represents a material, and the refractive index values for that material are stored as a complex number.</p> <code>None</code> <code>shape_type</code> <code>str</code> <p>A string specifying the type of shape for the object. Defaults to \"sphere\" or any other supported shape type.</p> <code>'sphere'</code> Source code in <code>yasfpy/particles.py</code> <pre><code>def __init__(\n    self,\n    position: np.ndarray,\n    r: np.ndarray,\n    refractive_index: np.ndarray,\n    refractive_index_table: list = None,\n    shape_type: str = \"sphere\",\n):\n    \"\"\"Initializes an object with position, radius, refractive index, refractive index table, and shape type attributes.\n\n    Args:\n        position (np.array): A numpy array representing the position of the shape.\n        r (np.array): A numpy array containing the radius values for each shape in the system.\n        refractive_index (np.array): A numpy array representing the refractive index of the shape.\n            It can be either a complex number or a two-column matrix.\n        refractive_index_table (list): A list containing the refractive index values for different materials.\n            Each element in the list represents a material, and the refractive index values for that material are stored as a complex number.\n        shape_type (str, optional): A string specifying the type of shape for the object.\n            Defaults to \"sphere\" or any other supported shape type.\n\n    \"\"\"\n    self.position = position\n    self.r = r\n    self.refractive_index = refractive_index\n    self.type = shape_type\n\n    # self.log = log.scattering_logger(__name__)\n    self.log = logging.getLogger(self.__class__.__module__)\n\n    # TODO: Keep it for now, remove later...\n    self.refractive_index_table = refractive_index_table\n\n    if refractive_index_table is None:\n        if len(refractive_index.shape) &gt; 2:\n            raise Exception(\n                \"Refractive index should be either an integer array, complex array, or a two column float matrix!\"\n            )\n        elif (len(refractive_index.shape) == 2) and (\n            self.refractive_index.shape[1] &gt; 2\n        ):\n            raise Exception(\n                \"Refractive index should be either an integer array, complex array, or a two column float matrix!\"\n            )\n\n        elif (len(refractive_index.shape) &gt; 1) and (refractive_index.shape[1] == 2):\n            self.refractive_index = (\n                refractive_index[:, 0] + 1j * refractive_index[:, 1]\n            )\n    else:\n        self.refractive_index = refractive_index.astype(int)\n\n    self.number = r.shape[0]\n    self.__setup_impl()\n</code></pre>"},{"location":"reference/particles/#particles.Particles.position","title":"<code>position = position</code>  <code>instance-attribute</code>","text":""},{"location":"reference/particles/#particles.Particles.r","title":"<code>r = r</code>  <code>instance-attribute</code>","text":""},{"location":"reference/particles/#particles.Particles.refractive_index","title":"<code>refractive_index = refractive_index</code>  <code>instance-attribute</code>","text":""},{"location":"reference/particles/#particles.Particles.type","title":"<code>type = shape_type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/particles/#particles.Particles.log","title":"<code>log = logging.getLogger(self.__class__.__module__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/particles/#particles.Particles.refractive_index_table","title":"<code>refractive_index_table = refractive_index_table</code>  <code>instance-attribute</code>","text":""},{"location":"reference/particles/#particles.Particles.number","title":"<code>number = r.shape[0]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/particles/#particles.Particles.compute_unique_refractive_indices","title":"<code>compute_unique_refractive_indices</code>","text":"<p>Computes the unique refractive indices and their indices.</p> Source code in <code>yasfpy/particles.py</code> <pre><code>def compute_unique_refractive_indices(self):\n    \"\"\"Computes the unique refractive indices and their indices.\"\"\"\n    self.unique_refractive_indices, self.refractive_index_array_idx = np.unique(\n        self.refractive_index, return_inverse=True, axis=0\n    )\n    self.num_unique_refractive_indices = self.unique_refractive_indices.shape[0]\n</code></pre>"},{"location":"reference/particles/#particles.Particles.compute_unique_radii","title":"<code>compute_unique_radii</code>","text":"<p>The function computes the unique radii from an array and stores them in a variable.</p> Source code in <code>yasfpy/particles.py</code> <pre><code>def compute_unique_radii(self):\n    \"\"\"The function computes the unique radii from an array and stores them in a variable.\"\"\"\n    self.unqiue_radii, self.radius_array_idx = np.unique(\n        self.r, return_inverse=True, axis=0\n    )\n    self.num_unique_radii = self.unqiue_radii.shape[0]\n</code></pre>"},{"location":"reference/particles/#particles.Particles.compute_unique_radii_index_pairs","title":"<code>compute_unique_radii_index_pairs</code>","text":"<p>The function computes unique pairs of radii and refractive indices and stores them in different arrays.</p> Source code in <code>yasfpy/particles.py</code> <pre><code>def compute_unique_radii_index_pairs(self):\n    \"\"\"The function computes unique pairs of radii and refractive indices and stores them in different\n    arrays.\n\n    \"\"\"\n    self.unique_radius_index_pairs, self.single_unique_array_idx = np.unique(\n        np.column_stack((self.r, self.refractive_index)),\n        return_inverse=True,\n        axis=0,\n    )\n    self.unique_single_radius_index_pairs = np.unique(\n        np.column_stack((self.radius_array_idx, self.refractive_index_array_idx)),\n        axis=0,\n    )\n</code></pre>"},{"location":"reference/particles/#particles.Particles.compute_single_unique_idx","title":"<code>compute_single_unique_idx</code>","text":"<p>The function computes a single unique index based on the sum of pairs of values and their corresponding indices.</p> Source code in <code>yasfpy/particles.py</code> <pre><code>def compute_single_unique_idx(self):\n    \"\"\"The function computes a single unique index based on the sum of pairs of values and their\n    corresponding indices.\n\n    \"\"\"\n    self.single_unique_idx = (\n        np.sum(self.unique_single_radius_index_pairs, axis=1)\n        * (np.sum(self.unique_single_radius_index_pairs, axis=1) + 1)\n    ) // 2 + self.unique_single_radius_index_pairs[:, 1]\n\n    # pairedArray = (\n    #   self.radius_array_idx + self.refractive_index_array_idx *\n    #   (self.radius_array_idx + self.refractive_index_array_idx + 1)\n    # ) // 2 + self.refractive_index_array_idx\n\n    # self.single_unique_idx, self.single_unique_array_idx = np.unique(\n    #   pairedArray,\n    #   return_inverse=True,\n    #   axis=0)\n\n    self.num_unique_pairs = self.unique_radius_index_pairs.shape[0]\n</code></pre>"},{"location":"reference/particles/#particles.Particles.compute_maximal_particle_distance","title":"<code>compute_maximal_particle_distance</code>","text":"<p>The function computes the maximum distance between particles using the ConvexHull algorithm.</p> Source code in <code>yasfpy/particles.py</code> <pre><code>def compute_maximal_particle_distance(self):\n    \"\"\"The function computes the maximum distance between particles using the ConvexHull algorithm.\"\"\"\n    if len(self.position) &lt; 4:\n        if len(self.position) == 1:\n            self.max_particle_distance = 0\n        else:\n            self.max_particle_distance = max(pdist(self.position))\n\n    else:\n        hull = ConvexHull(self.position)\n        vert = self.position[hull.vertices, :]\n        self.max_particle_distance = max(pdist(vert))\n</code></pre>"},{"location":"reference/particles/#particles.Particles.compute_volume_equivalent_area","title":"<code>compute_volume_equivalent_area</code>","text":"<p>The function computes the volume equivalent area by calculating the geometric projection.</p> Source code in <code>yasfpy/particles.py</code> <pre><code>def compute_volume_equivalent_area(self):\n    \"\"\"The function computes the volume equivalent area by calculating the geometric projection.\"\"\"\n    r3 = np.power(self.r, 3)\n    self.geometric_projection = np.pi * np.power(np.sum(r3), 2 / 3)\n</code></pre>"},{"location":"reference/particles/#particles.Particles.__setup_impl","title":"<code>__setup_impl</code>","text":"<p>The function sets up various computations related to refractive indices, radii, and particle distances.</p> Source code in <code>yasfpy/particles.py</code> <pre><code>def __setup_impl(self):\n    \"\"\"The function sets up various computations related to refractive indices, radii, and particle\n    distances.\n\n    \"\"\"\n    self.compute_unique_refractive_indices()\n    self.compute_unique_radii()\n    self.compute_unique_radii_index_pairs()\n    self.compute_single_unique_idx()\n    self.compute_maximal_particle_distance()\n    self.compute_volume_equivalent_area()\n</code></pre>"},{"location":"reference/simulation/","title":"Simulation","text":""},{"location":"reference/simulation/#simulation.Simulation","title":"<code>Simulation</code>","text":"<p>This class represents the simulation of YASF (Yet Another Scattering Framework). It contains methods for initializing the simulation, computing lookup tables, and calculating mie coefficients.</p> <p>Initialize the Simulation object.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Parameters</code> <p>The parameters for the simulation.</p> required <code>numerics</code> <code>Numerics</code> <p>The numerics for the simulation.</p> required Source code in <code>yasfpy/simulation.py</code> <pre><code>def __init__(self, parameters: Parameters, numerics: Numerics):\n    \"\"\"\n    Initialize the Simulation object.\n\n    Args:\n        parameters (Parameters): The parameters for the simulation.\n        numerics (Numerics): The numerics for the simulation.\n    \"\"\"\n    self.parameters = parameters\n    self.numerics = numerics\n\n    # self.log = log.infoing_logger(__name__)\n    self.log = logging.getLogger(self.__class__.__module__)\n    self.__setup()\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.parameters","title":"<code>parameters = parameters</code>  <code>instance-attribute</code>","text":""},{"location":"reference/simulation/#simulation.Simulation.numerics","title":"<code>numerics = numerics</code>  <code>instance-attribute</code>","text":""},{"location":"reference/simulation/#simulation.Simulation.log","title":"<code>log = logging.getLogger(self.__class__.__module__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/simulation/#simulation.Simulation.legacy_compute_lookup_particle_distances","title":"<code>legacy_compute_lookup_particle_distances</code>","text":"<p>The largest distance between two particles is divided into segments provided by <code>Numerics.particle_distance_resolution</code>. This array is then used as a lookup for the calculation of the spherical Hankel function.</p>"},{"location":"reference/simulation/#simulation.Simulation.legacy_compute_lookup_particle_distances--notes","title":"Notes","text":"<p>This function has been ported from the Matlab Celes framework but is not used by YASF!</p> Source code in <code>yasfpy/simulation.py</code> <pre><code>def legacy_compute_lookup_particle_distances(self):\n    \"\"\"\n    The largest distance between two particles is divided into segments provided by `Numerics.particle_distance_resolution`.\n    This array is then used as a lookup for the calculation of the spherical Hankel function.\n\n    Notes\n    -----\n    This function has been ported from the Matlab Celes framework but is not used by YASF!\n    \"\"\"\n    # add two zeros at the beginning to allow interpolation\n    # also in the first segment\n    step = self.numerics.particle_distance_resolution\n    maxdist = (\n        self.parameters.particles.max_particle_distance\n        + 3 * self.numerics.particle_distance_resolution\n    )\n    self.lookup_particle_distances = np.concatenate(\n        (np.array([0]), np.arange(0, maxdist + np.finfo(float).eps, step))\n    )\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.legacy_compute_h3_table","title":"<code>legacy_compute_h3_table</code>","text":"<p>Computes the spherical hankel function at the points calculated in <code>Simulation.legacy_compute_lookup_particle_distances()</code>.</p> <p>Attributes:</p> Name Type Description <code>h3_table</code> <code>ndarray</code> <p>Lookup table of the spherical hankel function values at <code>self.lookup_particle_distances</code></p> Notes <p>This function has been ported from the Matlab Celes framework but is not used by YASF!</p> Source code in <code>yasfpy/simulation.py</code> <pre><code>def legacy_compute_h3_table(self):\n    \"\"\"\n    Computes the spherical hankel function\n    at the points calculated in `Simulation.legacy_compute_lookup_particle_distances()`.\n\n    Attributes:\n        h3_table (np.ndarray): Lookup table of the spherical hankel function values at `self.lookup_particle_distances`\n\n    Notes:\n        This function has been ported from the Matlab Celes framework but is not used by YASF!\n    \"\"\"\n    self.h3_table = np.zeros(\n        (\n            2 * self.numerics.lmax + 1,\n            self.lookup_particle_distances.shape[0],\n            self.parameters.medium_refractive_index.shape[0],\n        ),\n        dtype=complex,\n    )\n    size_param = np.outer(self.lookup_particle_distances, self.parameters.k_medium)\n\n    for p in range(2 * self.numerics.lmax + 1):\n        self.h3_table[p, :, :] = spherical_jn(p, size_param) + 1j * spherical_yn(\n            p, size_param\n        )\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.__compute_idx_lookup","title":"<code>__compute_idx_lookup</code>","text":"<p>Creates a lookup table with the indices used in further calculations. The lookup table is created using <code>compute_idx_lookups</code> function from <code>yasfpy.functions.cpu_numba</code>.</p> <p>Attributes:</p> Name Type Description <code>idx_lookup</code> <code>ndarray</code> <p>Lookup table of the indices to iterate over large arrays.</p> Notes <p>This function utilizes Numba to optimize the computations.</p> Source code in <code>yasfpy/simulation.py</code> <pre><code>def __compute_idx_lookup(self):\n    \"\"\"\n    Creates a lookup table with the indices used in further calculations.\n    The lookup table is created using `compute_idx_lookups` function from `yasfpy.functions.cpu_numba`.\n\n    Attributes:\n        idx_lookup (np.ndarray): Lookup table of the indices to iterate over large arrays.\n\n    Notes:\n        This function utilizes Numba to optimize the computations.\n    \"\"\"\n    self.idx_lookup = compute_idx_lookups(\n        self.numerics.lmax, self.parameters.particles.number\n    )\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.__compute_lookups","title":"<code>__compute_lookups</code>","text":"<p>Computes various lookup tables for each particle.</p> <p>Attributes:</p> Name Type Description <code>sph_j</code> <code>ndarray</code> <p>Spherical Bessel function lookup table calculated for pair-wise particle distances.</p> <code>sph_h</code> <code>ndarray</code> <p>Spherical Hankel function lookup table calculated for pair-wise particle distances.</p> <code>plm</code> <code>ndarray</code> <p>Associated Legendre polynomial lookup table calculated for the cosine value of the pairwise particle inclination angles.</p> <code>e_j_dm_phi</code> <code>ndarray</code> <p>Exponential function lookup table calculated for the pairwise particle azimuthal angles.</p> Notes <p>This function uses numba (https://numba.pydata.org/) under the hood to speed up the computations.</p> Source code in <code>yasfpy/simulation.py</code> <pre><code>def __compute_lookups(self):\n    \"\"\"\n    Computes various lookup tables for each particle.\n\n    Attributes:\n        sph_j (np.ndarray): Spherical Bessel function lookup table calculated for pair-wise particle distances.\n        sph_h (np.ndarray): Spherical Hankel function lookup table calculated for pair-wise particle distances.\n        plm (np.ndarray): Associated Legendre polynomial lookup table calculated for the cosine value of the pairwise particle inclination angles.\n        e_j_dm_phi (np.ndarray): Exponential function lookup table calculated for the pairwise particle azimuthal angles.\n\n    Notes:\n        This function uses numba (https://numba.pydata.org/) under the hood to speed up the computations.\n    \"\"\"\n    lookup_computation_time_start = time()\n    # TODO: new, could be error prone and is not tested yet!\n    self.sph_j, self.sph_h, self.e_j_dm_phi, self.plm = mutual_lookup(\n        self.numerics.lmax,\n        self.parameters.particles.position,\n        self.parameters.particles.position,\n        self.parameters.k_medium,\n    )[:4]\n\n    # lmax = self.numerics.lmax\n    # particle_number = self.parameters.particles.number\n\n    # dists = squareform(pdist(self.parameters.particles.position))\n    # ct = np.divide(\n    #   np.subtract.outer(\n    #     self.parameters.particles.position[:, 2], self.parameters.particles.position[:, 2]),\n    #   dists,\n    #   out = np.zeros((particle_number, particle_number)),\n    #   where = dists != 0)\n    # phi = np.arctan2(\n    #   np.subtract.outer(\n    #     self.parameters.particles.position[:, 1], self.parameters.particles.position[:, 1]),\n    #   np.subtract.outer(self.parameters.particles.position[:, 0], self.parameters.particles.position[:, 0]))\n\n    # size_param = np.outer(dists.ravel(), self.parameters.k_medium).reshape(\n    #   [particle_number, particle_number, self.parameters.k_medium.shape[0]])\n\n    # self.sph_h = np.zeros((2 * lmax + 1, particle_number, particle_number, self.parameters.k_medium.shape[0]), dtype=complex)\n    # self.sph_j = np.zeros_like(self.sph_h)\n    # self.e_j_dm_phi = np.zeros((4 * lmax + 1, particle_number, particle_number), dtype=complex)\n    # self.plm = np.zeros(((lmax + 1) * (2 * lmax + 1),\n    #           particle_number, particle_number))\n\n    # for p in range(2 * lmax + 1):\n    #   self.sph_h[p, :, :, :] = np.sqrt(\n    #     np.divide(\n    #       np.pi / 2,\n    #       size_param,\n    #       out=np.zeros_like(size_param),\n    #       where=size_param != 0)\n    #   ) * hankel1(p + 1/2, size_param)\n    #   self.sph_j[p, :, :, :] = spherical_jn(p, size_param)\n    #   self.e_j_dm_phi[p, :, :] = np.exp(1j * (p - 2 * lmax) * phi)\n    #   self.e_j_dm_phi[p + 2 * lmax, :, :] = np.exp(1j * p * phi)\n    #   for absdm in range(p + 1):\n    #     cml = np.sqrt((2 * p + 1) / 2 /\n    #             np.prod(np.arange(p - absdm + 1, p + absdm + 1)))\n    #     self.plm[p * (p + 1) // 2 + absdm, :, :] = cml * \\\n    #       np.power(-1.0, absdm) * lpmv(absdm, p, ct)\n\n    # self.sph_h = np.nan_to_num(\n    #   self.sph_h, nan=0) + np.isnan(self.sph_h) * 1\n\n    lookup_computation_time_stop = time()\n    self.log.info(\n        \"Computing lookup tables took %f s\"\n        % (lookup_computation_time_stop - lookup_computation_time_start)\n    )\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.__setup","title":"<code>__setup</code>","text":"<p>An internal setup function called upon object creation. The following functions are called:</p> <ul> <li>__compute_idx_lookups</li> <li>__compute_lookups</li> </ul> Source code in <code>yasfpy/simulation.py</code> <pre><code>def __setup(self):\n    \"\"\"\n    An internal setup function called upon object creation.\n    The following functions are called:\n\n    - [__compute_idx_lookups][simulation.Simulation.__compute_idx_lookup]\n    - [__compute_lookups][simulation.Simulation.__compute_lookups]\n    \"\"\"\n    self.__compute_idx_lookup()\n    self.__compute_lookups()\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.compute_mie_coefficients","title":"<code>compute_mie_coefficients</code>","text":"<p>Computes the mie coefficients for the unique pair of particle radius and the refractive index of the particle.</p> <p>Attributes:</p> Name Type Description <code>mie_coefficients</code> <code>ndarray</code> <p>Mie coefficients table</p> See Also <p>t_entry : T-Matrix entry function</p> Notes <p>Due to the four nested loops (particles, tau, l, and m), it could be rewritten using <code>numba</code> to speed the process up.</p> Source code in <code>yasfpy/simulation.py</code> <pre><code>def compute_mie_coefficients(self):\n    \"\"\"\n    Computes the mie coefficients for the unique pair\n    of particle radius and the refractive index of the particle.\n\n    Attributes:\n        mie_coefficients (np.ndarray): Mie coefficients table\n\n    See Also:\n        [t_entry][functions.t_entry.t_entry] : T-Matrix entry function\n\n    Notes:\n        Due to the four nested loops (particles, tau, l, and m),\n        it could be rewritten using `numba` to speed the process up.\n    \"\"\"\n    self.mie_coefficients = np.zeros(\n        (\n            self.parameters.particles.num_unique_pairs,\n            self.numerics.nmax,\n            self.parameters.wavelength.shape[0],\n        ),\n        dtype=complex,\n    )\n\n    self.scatter_to_internal = np.zeros_like(self.mie_coefficients)\n\n    for u_i in range(self.parameters.particles.num_unique_pairs):\n        for tau in range(1, 3):\n            for l in range(1, self.numerics.lmax + 1):\n                for m in range(-l, l + 1):\n                    jmult = multi2single_index(0, tau, l, m, self.numerics.lmax)\n                    self.mie_coefficients[u_i, jmult, :] = t_entry(\n                        tau=tau,\n                        l=l,\n                        k_medium=self.parameters.k_medium,\n                        k_sphere=self.parameters.omega\n                        * self.parameters.particles.unique_radius_index_pairs[\n                            u_i, 1:\n                        ],\n                        radius=np.real(\n                            self.parameters.particles.unique_radius_index_pairs[\n                                u_i, 0\n                            ]\n                        ),\n                    )\n\n                    self.scatter_to_internal[u_i, jmult, :] = t_entry(\n                        tau=tau,\n                        l=l,\n                        k_medium=self.parameters.k_medium,\n                        k_sphere=self.parameters.omega\n                        * self.parameters.particles.unique_radius_index_pairs[\n                            u_i, 1:\n                        ],\n                        radius=np.real(\n                            self.parameters.particles.unique_radius_index_pairs[\n                                u_i, 0\n                            ]\n                        ),\n                        field_type=\"ratio\",\n                    )\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.compute_initial_field_coefficients","title":"<code>compute_initial_field_coefficients</code>","text":"<p>Computes initial field coefficients \\(a_{\\\\tau ,l,m}\\) and \\(b_{\\\\tau ,l,m}\\). Depending on the <code>beam_width</code>, one of two functions is called:</p> <ul> <li>__compute_initial_field_coefficients_wavebundle_normal_incidence, \\(\\\\text{beam width} \\\\in (0, \\\\infty)\\)</li> <li>__compute_initial_field_coefficients_planewave, \\(\\\\text{beam width} = 0\\) or \\(\\\\text{beam width} = \\\\infty\\)</li> </ul> <p>Attributes:</p> Name Type Description <code>initial_field_coefficients</code> <code>ndarray</code> <p>Initial field coefficients</p> Source code in <code>yasfpy/simulation.py</code> <pre><code>def compute_initial_field_coefficients(self):\n    r\"\"\"\n    Computes initial field coefficients $a_{\\\\tau ,l,m}$ and $b_{\\\\tau ,l,m}$.\n    Depending on the `beam_width`, one of two functions is called:\n\n    - [__compute_initial_field_coefficients_wavebundle_normal_incidence][simulation.Simulation.__compute_initial_field_coefficients_wavebundle_normal_incidence], $\\\\text{beam width} \\\\in (0, \\\\infty)$\n    - [__compute_initial_field_coefficients_planewave][simulation.Simulation.__compute_initial_field_coefficients_planewave], $\\\\text{beam width} = 0$ or $\\\\text{beam width} = \\\\infty$\n\n    Attributes:\n        initial_field_coefficients (np.ndarray): Initial field coefficients\n    \"\"\"\n    self.log.info(\"compute initial field coefficients ...\")\n\n    if np.isfinite(self.parameters.initial_field.beam_width) and (\n        self.parameters.initial_field.beam_width &gt; 0\n    ):\n        self.log.info(\"\\t Gaussian beam ...\")\n        if self.parameters.initial_field.normal_incidence:\n            self.__compute_initial_field_coefficients_wavebundle_normal_incidence()\n        else:\n            self.log.error(\"\\t this case is not implemented\")\n    else:\n        self.log.info(\"\\t plane wave ...\")\n        self.__compute_initial_field_coefficients_planewave()\n\n    self.log.info(\"done\")\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.compute_right_hand_side","title":"<code>compute_right_hand_side</code>","text":"<p>Computes the right hand side \\(T \\\\cdot a_I\\) of the equation \\(M \\\\cdot b = T \\\\cdot a_I\\).</p>"},{"location":"reference/simulation/#simulation.Simulation.compute_right_hand_side--attributes","title":"Attributes","text":"<p>right_hand_side : np.ndarray     Right hand side of the equation \\(M \\\\cdot b = T \\\\cdot a_I\\)</p>"},{"location":"reference/simulation/#simulation.Simulation.compute_right_hand_side--notes","title":"Notes","text":"<p>For more information regarding the equation, please refer to the paper by Celes (https://arxiv.org/abs/1706.02145).</p> Source code in <code>yasfpy/simulation.py</code> <pre><code>def compute_right_hand_side(self):\n    r\"\"\"\n    Computes the right hand side $T \\\\cdot a_I$ of the equation $M \\\\cdot b = T \\\\cdot a_I$.\n\n    Attributes\n    ----------\n    right_hand_side : np.ndarray\n        Right hand side of the equation $M \\\\cdot b = T \\\\cdot a_I$\n\n    Notes\n    -----\n    For more information regarding the equation, please refer to the paper by Celes (https://arxiv.org/abs/1706.02145).\n    \"\"\"\n    self.right_hand_side = (\n        self.mie_coefficients[self.parameters.particles.single_unique_array_idx, :]\n        * self.initial_field_coefficients\n    )\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.__compute_initial_field_coefficients_planewave","title":"<code>__compute_initial_field_coefficients_planewave</code>","text":"<p>The function computes the initial field coefficients for a plane wave based on given parameters and spherical coordinates.</p> Source code in <code>yasfpy/simulation.py</code> <pre><code>def __compute_initial_field_coefficients_planewave(self):\n    \"\"\"The function computes the initial field coefficients for a plane wave based on given parameters\n    and spherical coordinates.\n\n    \"\"\"\n    lmax = self.numerics.lmax\n    E0 = self.parameters.initial_field.amplitude\n    k = self.parameters.k_medium\n\n    beta = self.parameters.initial_field.polar_angle\n    cb = np.cos(beta)\n    sb = np.sin(beta)\n    alpha = self.parameters.initial_field.azimuthal_angle\n\n    # pi and tau symbols for transformation matrix B_dagger\n    pilm, taulm = spherical_functions_trigon(lmax, beta)\n\n    # cylindrical coordinates for relative particle positions\n    relative_particle_positions = (\n        self.parameters.particles.position\n        - self.parameters.initial_field.focal_point\n    )\n    kvec = np.outer(np.array((sb * np.cos(alpha), sb * np.sin(alpha), cb)), k)\n    eikr = np.exp(1j * np.matmul(relative_particle_positions, kvec))\n\n    # clean up some memory?\n    del (k, beta, cb, sb, kvec, relative_particle_positions)\n\n    self.initial_field_coefficients = np.zeros(\n        (\n            self.parameters.particles.number,\n            self.numerics.nmax,\n            self.parameters.k_medium.size,\n        ),\n        dtype=complex,\n    )\n    for m in range(-lmax, lmax + 1):\n        for tau in range(1, 3):\n            for l in range(np.max([1, np.abs(m)]), lmax + 1):\n                n = multi2single_index(0, tau, l, m, lmax)\n                self.initial_field_coefficients[:, n, :] = (\n                    4\n                    * E0\n                    * np.exp(-1j * m * alpha)\n                    * eikr\n                    * transformation_coefficients(\n                        pilm,\n                        taulm,\n                        tau,\n                        l,\n                        m,\n                        self.parameters.initial_field.pol,\n                        dagger=True,\n                    )\n                )\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.__compute_initial_field_coefficients_wavebundle_normal_incidence","title":"<code>__compute_initial_field_coefficients_wavebundle_normal_incidence</code>","text":"<p>The function initializes the field coefficients for a wave bundle incident at normal incidence.</p> TODO <p>Implement this function using the celes function initial_field_coefficients_wavebundle_normal_incidence.m</p> Source code in <code>yasfpy/simulation.py</code> <pre><code>def __compute_initial_field_coefficients_wavebundle_normal_incidence(self):\n    \"\"\"The function initializes the field coefficients for a wave bundle incident at normal incidence.\n\n    TODO:\n        Implement this function using the celes function [initial_field_coefficients_wavebundle_normal_incidence.m](https://github.com/disordered-photonics/celes/blob/master/src/initial/initial_field_coefficients_wavebundle_normal_incidence.m)\n    \"\"\"\n    self.initial_field_coefficients = (\n        np.zeros(\n            (\n                self.parameters.particles.number,\n                self.numerics.nmax,\n                self.parameters.k_medium.size,\n            ),\n            dtype=complex,\n        )\n        * np.nan\n    )\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.coupling_matrix_multiply","title":"<code>coupling_matrix_multiply</code>","text":"<p>Computes the coupling matrix <code>wx</code> based on the input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>An input array of shape (n,) or (n, m), where n is the number of particles and m is the number of features for each particle. This array represents the input data for which the coupling matrix needs to be computed.</p> required <code>idx</code> <code>int</code> <p>An optional integer that specifies the index of a specific spherical harmonic mode. If <code>idx</code> is provided, the computation will only be performed for that specific mode. If <code>idx</code> is not provided or set to <code>None</code>, the computation will be performed for all spherical harmonic modes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>wx</code> <code>ndarray</code> <p>An array of shape (n, m, p), where n is the number of particles, m is the number of features for each particle, and p is the number of wavelengths. It represents the coupling matrix <code>wx</code>.</p> Source code in <code>yasfpy/simulation.py</code> <pre><code>def coupling_matrix_multiply(self, x: np.ndarray, idx: int = None):\n    \"\"\"Computes the coupling matrix `wx` based on the input parameters.\n\n    Args:\n        x (np.ndarray): An input array of shape (n,) or (n, m), where n is the number of particles and m is the number\n            of features for each particle. This array represents the input data for which the coupling\n            matrix needs to be computed.\n        idx (int): An optional integer that specifies the index of a specific spherical harmonic mode. If `idx` is provided,\n            the computation will only be performed for that specific mode. If `idx` is not provided or set to `None`,\n            the computation will be performed for all spherical harmonic modes.\n\n    Returns:\n        wx (np.ndarray): An array of shape (n, m, p), where n is the number of particles, m is the number of features for each\n            particle, and p is the number of wavelengths. It represents the coupling matrix `wx`.\n    \"\"\"\n    self.log.debug(\"prepare particle coupling ... \")\n    preparation_time = time()\n\n    lmax = self.numerics.lmax\n    particle_number = self.parameters.particles.number\n    jmax = particle_number * 2 * lmax * (lmax + 2)\n    wavelengths_size = self.parameters.k_medium.shape[0]\n    translation_table = self.numerics.translation_ab5\n    associated_legendre_lookup = self.plm\n    spherical_hankel_lookup = self.sph_h\n    e_j_dm_phi_loopup = self.e_j_dm_phi\n\n    idx_lookup = self.idx_lookup\n\n    if idx is not None:\n        spherical_hankel_lookup = spherical_hankel_lookup[:, :, :, idx]\n        spherical_hankel_lookup = np.copy(\n            spherical_hankel_lookup[:, :, :, np.newaxis]\n        )\n        wavelengths_size = 1\n\n    self.log.debug(\"\\t Starting Wx computation\")\n    if self.numerics.gpu:\n        wx_real = np.zeros(x.shape + (wavelengths_size,), dtype=float)\n        wx_imag = np.zeros_like(wx_real)\n\n        idx_device = cuda.to_device(idx_lookup)\n        x_device = cuda.to_device(x)\n        wx_real_device = cuda.to_device(wx_real)\n        wx_imag_device = cuda.to_device(wx_imag)\n        translation_device = cuda.to_device(translation_table)\n        associated_legendre_device = cuda.to_device(associated_legendre_lookup)\n        spherical_hankel_device = cuda.to_device(spherical_hankel_lookup)\n        e_j_dm_phi_device = cuda.to_device(e_j_dm_phi_loopup)\n\n        threads_per_block = (16, 16, 2)\n        blocks_per_grid_x = ceil(jmax / threads_per_block[0])\n        blocks_per_grid_y = ceil(jmax / threads_per_block[1])\n        blocks_per_grid_z = ceil(wavelengths_size / threads_per_block[2])\n        blocks_per_grid = (blocks_per_grid_x, blocks_per_grid_y, blocks_per_grid_z)\n\n        coupling_matrix_time = time()\n        particle_interaction_gpu[blocks_per_grid, threads_per_block](\n            lmax,\n            particle_number,\n            idx_device,\n            x_device,\n            wx_real_device,\n            wx_imag_device,\n            translation_device,\n            associated_legendre_device,\n            spherical_hankel_device,\n            e_j_dm_phi_device,\n        )\n        wx_real = wx_real_device.copy_to_host()\n        wx_imag = wx_imag_device.copy_to_host()\n        wx = wx_real + 1j * wx_imag\n        # particle_interaction.parallel_diagnostics(level=4)\n        time_end = time()\n        self.log.debug(\n            \"\\t Time taken for preparation: %f\"\n            % (coupling_matrix_time - preparation_time)\n        )\n        self.log.debug(\n            \"\\t Time taken for coupling matrix: %f\"\n            % (time_end - coupling_matrix_time)\n        )\n    else:\n        # from numba_progress import ProgressBar\n        # num_iterations = jmax * jmax * wavelengths\n        # progress = ProgressBar(total=num_iterations)\n        # progress = None\n        wx = particle_interaction(\n            lmax,\n            particle_number,\n            idx_lookup,\n            x,\n            translation_table,\n            associated_legendre_lookup,\n            spherical_hankel_lookup,\n            e_j_dm_phi_loopup,\n        )\n        time_end = time()\n        self.log.debug(\n            \"\\t Time taken for coupling matrix: %f\" % (time_end - preparation_time)\n        )\n\n    if idx is not None:\n        wx = np.squeeze(wx)\n\n    return wx\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.master_matrix_multiply","title":"<code>master_matrix_multiply</code>","text":"<p>Applies a T-matrix to a given value and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ndarray</code> <p>The input value for the matrix multiplication operation.</p> required <code>idx</code> <code>int</code> <p>The index of the matrix to be multiplied.</p> required <p>Returns:</p> Name Type Description <code>mx</code> <code>ndarray</code> <p>The result of the matrix multiplication operation.</p> Source code in <code>yasfpy/simulation.py</code> <pre><code>def master_matrix_multiply(self, value: np.ndarray, idx: int):\n    \"\"\"Applies a T-matrix to a given value and returns the result.\n\n    Args:\n        value (np.ndarray): The input value for the matrix multiplication operation.\n        idx (int): The index of the matrix to be multiplied.\n\n    Returns:\n        mx (np.ndarray): The result of the matrix multiplication operation.\n\n    \"\"\"\n    wx = self.coupling_matrix_multiply(value, idx)\n\n    self.log.debug(\"apply T-matrix ...\")\n    t_matrix_start = time()\n\n    twx = (\n        self.mie_coefficients[\n            self.parameters.particles.single_unique_array_idx, :, idx\n        ].ravel(order=\"C\")\n        * wx\n    )\n    mx = value - twx\n\n    t_matrix_stop = time()\n    self.log.debug(f\"\\t done in {t_matrix_stop - t_matrix_start} seconds.\")\n\n    return mx\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.compute_scattered_field_coefficients","title":"<code>compute_scattered_field_coefficients</code>","text":"<p>The function computes the scattered field coefficients using a linear operator and a solver.</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <code>ndarray</code> <p>Optional. The initial guess for the solution of the linear system. If no guess is provided, the <code>right_hand_side</code> variable is used as the initial guess.</p> <code>None</code> Source code in <code>yasfpy/simulation.py</code> <pre><code>def compute_scattered_field_coefficients(self, guess: np.ndarray = None):\n    \"\"\"The function computes the scattered field coefficients using a linear operator and a solver.\n\n    Args:\n        guess (np.ndarray): Optional. The initial guess for the solution of the linear system. If no guess is provided,\n            the `right_hand_side` variable is used as the initial guess.\n\n    \"\"\"\n    self.log.info(\"compute scattered field coefficients ...\")\n    jmax = self.parameters.particles.number * self.numerics.nmax\n    self.scattered_field_coefficients = np.zeros_like(\n        self.initial_field_coefficients\n    )\n    self.scattered_field_err_codes = np.zeros(self.parameters.wavelengths_number)\n    if guess is None:\n        guess = self.right_hand_side\n    # TODO: Look into performing this loop in parallel\n    for w in range(self.parameters.wavelengths_number):\n        A = LinearOperator(\n            shape=(jmax, jmax), matvec=lambda x: self.master_matrix_multiply(x, w)\n        )\n        b = self.right_hand_side[:, :, w].ravel()\n        x0 = guess[:, :, w].ravel()\n        self.log.info(\n            \"Solver run %d/%d\" % (w + 1, self.parameters.wavelengths_number)\n        )\n        x, err_code = self.numerics.solver.run(A, b, x0)\n        self.scattered_field_coefficients[:, :, w] = x.reshape(\n            self.right_hand_side.shape[:2]\n        )\n        self.scattered_field_err_codes[w] = err_code\n</code></pre>"},{"location":"reference/simulation/#simulation.Simulation.compute_fields","title":"<code>compute_fields</code>","text":"<p>The function <code>compute_fields</code> calculates the field at given sampling points using either CPU or GPU computation.</p> <p>Parameters:</p> Name Type Description Default <code>sampling_points</code> <code>ndarray</code> <p>The numpy array that represents the coordinates of the sampling points. It should have a shape of <code>(n, 3)</code>, where <code>n</code> is the number of sampling points and each row represents the <code>(x, y, z)</code> coordinates of a point.</p> required Source code in <code>yasfpy/simulation.py</code> <pre><code>def compute_fields(self, sampling_points: np.ndarray):\n    \"\"\"The function `compute_fields` calculates the field at given sampling points using either CPU or\n    GPU computation.\n\n    Args:\n        sampling_points (np.ndarray): The numpy array that represents the coordinates of the sampling points.\n            It should have a shape of `(n, 3)`, where `n` is the number of sampling points and each row\n            represents the `(x, y, z)` coordinates of a point.\n    \"\"\"\n    if sampling_points.shape[0] &lt; 1:\n        self.log.error(\"Number of sampling points must be bigger than zero!\")\n        return\n    if sampling_points.shape[1] != 3:\n        self.log.error(\"The points have to have three coordinates (x,y,z)!\")\n        return\n\n    # scatter_to_internal_table = np.sum((self.parameters.particles.position[:, np.newaxis, :] - sampling_points[np.newaxis, :, :])**2, axis = 2)\n    # scatter_to_internal_table = scatter_to_internal_table &lt; self.parameters.particles.r[:, np.newaxis]**2\n\n    self.log.info(\"Computing mutual lookup\")\n    lookup_computation_time_start = time()\n    (\n        _,\n        sph_h,\n        e_j_dm_phi,\n        p_lm,\n        e_r,\n        e_theta,\n        e_phi,\n        cosine_theta,\n        sine_theta,\n        size_parameter,\n        sph_h_derivative,\n    ) = mutual_lookup(\n        self.numerics.lmax,\n        self.parameters.particles.position,\n        sampling_points,\n        self.parameters.k_medium,\n        derivatives=True,\n        parallel=False,\n    )\n    lookup_computation_time_stop = time()\n    self.log.info(\n        \"Computing lookup tables took %f s\",\n        lookup_computation_time_stop - lookup_computation_time_start,\n    )\n    pi_lm, tau_lm = spherical_functions_trigon(\n        self.numerics.lmax, cosine_theta, sine_theta\n    )\n\n    self.log.info(\"Computing field...\")\n    field_time_start = time()\n    self.sampling_points = sampling_points\n    if not self.numerics.gpu:\n        self.log.info(\"\\t...using GPU\")\n        field_real = np.zeros(\n            (self.parameters.k_medium.size, sampling_points.shape[0], 3),\n            dtype=float,\n        )\n        field_imag = np.zeros_like(field_real)\n\n        idx_device = cuda.to_device(self.idx_lookup)\n        size_parameter_device = cuda.to_device(np.ascontiguousarray(size_parameter))\n        sph_h_device = cuda.to_device(np.ascontiguousarray(sph_h))\n        sph_h_derivative_device = cuda.to_device(\n            np.ascontiguousarray(sph_h_derivative)\n        )\n        e_j_dm_phi_device = cuda.to_device(np.ascontiguousarray(e_j_dm_phi))\n        p_lm_device = cuda.to_device(np.ascontiguousarray(p_lm))\n        pi_lm_device = cuda.to_device(np.ascontiguousarray(pi_lm))\n        tau_lm_device = cuda.to_device(np.ascontiguousarray(tau_lm))\n        e_r_device = cuda.to_device(np.ascontiguousarray(e_r))\n        e_theta_device = cuda.to_device(np.ascontiguousarray(e_theta))\n        e_phi_device = cuda.to_device(np.ascontiguousarray(e_phi))\n        sfc_device = cuda.to_device(\n            np.ascontiguousarray(self.scattered_field_coefficients)\n        )\n\n        field_real_device = cuda.to_device(field_real)\n        field_imag_device = cuda.to_device(field_imag)\n\n        threads_per_block = (16, 16, 2)\n        blocks_per_grid = (\n            sampling_points.shape[0],\n            sph_h.shape[1] * 2 * self.numerics.lmax * (self.numerics.lmax + 2),\n            self.parameters.k_medium.size,\n        )\n        # blocks_per_grid = tuple(\n        #     [\n        #         ceil(blocks_per_grid[i] / threads_per_block[i])\n        #         for i in range(len(threads_per_block))\n        #     ]\n        # )\n        blocks_per_grid = tuple(\n            ceil(blocks_per_grid[i] / threads_per_block[i])\n            for i in range(len(threads_per_block))\n        )\n\n        compute_field_gpu[blocks_per_grid, threads_per_block](\n            self.numerics.lmax,\n            idx_device,\n            size_parameter_device,\n            sph_h_device,\n            sph_h_derivative_device,\n            e_j_dm_phi_device,\n            p_lm_device,\n            pi_lm_device,\n            tau_lm_device,\n            e_r_device,\n            e_theta_device,\n            e_phi_device,\n            sfc_device,\n            field_real_device,\n            field_imag_device,\n        )\n\n        field_real = field_real_device.copy_to_host()\n        field_imag = field_imag_device.copy_to_host()\n        self.scattered_field = field_real + 1j * field_imag\n\n    else:\n        self.log.info(\"\\t...using CPU\")\n        self.scattered_field = compute_field(\n            self.numerics.lmax,\n            self.idx_lookup,\n            size_parameter,\n            sph_h,\n            sph_h_derivative,\n            e_j_dm_phi,\n            p_lm,\n            pi_lm,\n            tau_lm,\n            e_r,\n            e_theta,\n            e_phi,\n            scattered_field_coefficients=self.scattered_field_coefficients,\n        )\n\n    field_time_stop = time()\n    self.log.info(\n        f\"\\t Time taken for field calculation: {field_time_stop - field_time_start}\"\n    )\n</code></pre>"},{"location":"reference/solver/","title":"Solver","text":""},{"location":"reference/solver/#solver.Solver","title":"<code>Solver</code>","text":"<p>The Solver class provides a generic interface for solving linear systems of equations using different iterative solvers such as GMRES, BiCGSTAB, and LGMRES, and the GMResCounter class is used to count the number of iterations and display the residual or current iterate during the GMRES solver.</p> <p>Initializes a solver object with specified parameters and creates a logger object.</p> <p>Parameters:</p> Name Type Description Default <code>solver_type</code> <code>str</code> <p>The type of solver to be used. Defaults to \"gmres\".</p> <code>'gmres'</code> <code>tolerance</code> <code>float</code> <p>The desired accuracy of the solver.</p> <code>0.0001</code> <code>max_iter</code> <code>int</code> <p>The maximum number of iterations that the solver will perform.</p> <code>10000.0</code> <code>restart</code> <code>int</code> <p>The number of iterations after which the solver will restart.</p> <code>100.0</code> Source code in <code>yasfpy/solver.py</code> <pre><code>def __init__(\n    self,\n    solver_type: str = \"gmres\",\n    tolerance: float = 1e-4,\n    max_iter: float = 1e4,\n    restart: float = 1e2,\n):\n    \"\"\"Initializes a solver object with specified parameters and creates a logger object.\n\n    Args:\n        solver_type (str, optional): The type of solver to be used. Defaults to \"gmres\".\n        tolerance (float): The desired accuracy of the solver.\n        max_iter (int): The maximum number of iterations that the solver will perform.\n        restart (int): The number of iterations after which the solver will restart.\n    \"\"\"\n    self.type = solver_type.lower()\n    self.tolerance = tolerance\n    self.max_iter = int(max_iter)\n    self.restart = int(restart)\n\n    # self.log = log.scattering_logger(__name__)\n    self.log = logging.getLogger(self.__class__.__module__)\n</code></pre>"},{"location":"reference/solver/#solver.Solver.type","title":"<code>type = solver_type.lower()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/solver/#solver.Solver.tolerance","title":"<code>tolerance = tolerance</code>  <code>instance-attribute</code>","text":""},{"location":"reference/solver/#solver.Solver.max_iter","title":"<code>max_iter = int(max_iter)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/solver/#solver.Solver.restart","title":"<code>restart = int(restart)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/solver/#solver.Solver.log","title":"<code>log = logging.getLogger(self.__class__.__module__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/solver/#solver.Solver.run","title":"<code>run</code>","text":"<p>Runs the solver on the given linear system of equations.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>LinearOperator</code> <p>The linear operator representing the system matrix.</p> required <code>b</code> <code>ndarray</code> <p>The right-hand side vector.</p> required <code>x0</code> <code>ndarray</code> <p>The initial guess for the solution. If not provided, a copy of b will be used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>value</code> <code>ndarray</code> <p>The solution to the linear system of equations.</p> <code>err_code</code> <code>int</code> <p>The error code indicating the convergence status of the solver.</p> Source code in <code>yasfpy/solver.py</code> <pre><code>def run(self, a: LinearOperator, b: np.ndarray, x0: np.ndarray = None):\n    \"\"\"\n    Runs the solver on the given linear system of equations.\n\n    Args:\n        a (LinearOperator): The linear operator representing the system matrix.\n        b (np.ndarray): The right-hand side vector.\n        x0 (np.ndarray, optional): The initial guess for the solution. If not provided, a copy of b will be used.\n\n    Returns:\n        value (np.ndarray): The solution to the linear system of equations.\n        err_code (int): The error code indicating the convergence status of the solver.\n\n    \"\"\"\n    if x0 is None:\n        x0 = np.copy(b)\n\n    x0 = np.zeros_like(b)\n\n    if np.any(np.isnan(b)):\n        print(b)\n\n    if self.type == \"bicgstab\":\n        # Add your code here for the bicgstab solver\n        pass\n        counter = GMResCounter(callback_type=\"x\")\n        value, err_code = bicgstab(\n            a,\n            b,\n            x0,\n            tol=self.tolerance,\n            atol=0,\n            maxiter=self.max_iter,\n            callback=counter,\n        )\n    elif self.type == \"gmres\":\n        counter = GMResCounter(callback_type=\"pr_norm\")\n        value, err_code = gmres(\n            a,\n            b,\n            x0,\n            restart=self.rerestartstart,\n            tol=self.tolerance,\n            atol=0,\n            maxiter=self.max_iter,\n            callback=counter,\n            callback_type=\"pr_norm\",\n        )\n    elif self.type == \"lgmres\":\n        counter = GMResCounter(callback_type=\"x\")\n        value, err_code = lgmres(\n            a,\n            b,\n            x0,\n            rtol=self.tolerance,\n            atol=0,\n            maxiter=self.max_iter,\n            callback=counter,\n        )\n    elif self.type == \"cgs\":\n        # counter = GMResCounter(callback_type=\"x\")\n        value, err_code = cgs(\n            a,\n            b,\n            x0,\n            rtol=self.tolerance,\n            atol=0,\n            maxiter=self.max_iter,\n            # callback=co\n        )\n    elif self.type == \"qmr\":\n        value, err_code = qmr(\n            a,\n            b,\n            x0=x0,\n            rtol=self.tolerance,\n            atol=0,\n            maxiter=self.max_iter,\n            # callback=co\n        )\n    elif self.type == \"gcrotmk\":\n        # counter = GMResCounter(callback_type=\"x\")\n        value, err_code = gcrotmk(\n            a,\n            b,\n            x0,\n            rtol=self.tolerance,\n            atol=0,\n            maxiter=self.max_iter,\n            # callback=co\n        )\n    elif self.type == \"tfqmr\":\n        # counter = GMResCounter(callback_type=\"x\")\n        value, err_code = tfqmr(\n            a,\n            b,\n            x0,\n            rtol=self.tolerance,\n            atol=0,\n            maxiter=self.max_iter,\n            # callback=co\n        )\n    else:\n        self.log.error(\"Please specify a valid solver type\")\n        exit(1)\n\n    return value, err_code\n</code></pre>"},{"location":"reference/solver/#solver.GMResCounter","title":"<code>GMResCounter</code>","text":"<p>               Bases: <code>object</code></p> <p>The GMResCounter class is a helper class that counts the number of iterations and displays the residual or current iterate during the GMRES solver.</p> <p>Initializes an object with optional display and callback type parameters.</p> <p>Parameters:</p> Name Type Description Default <code>disp</code> <code>bool</code> <p>A boolean flag that determines whether or not to display the progress of the algorithm. If <code>disp</code> is set to <code>True</code>, the algorithm will display the progress. If <code>disp</code> is set to <code>False</code>, the algorithm will not display the progress.</p> <code>False</code> <code>callback_type</code> <code>str</code> <p>The type of callback to be used. It can have two possible values.</p> <code>'pr_norm'</code> Source code in <code>yasfpy/solver.py</code> <pre><code>def __init__(self, disp: bool = False, callback_type: str = \"pr_norm\"):\n    \"\"\"Initializes an object with optional display and callback type parameters.\n\n    Args:\n        disp (bool, optional): A boolean flag that determines whether or not to display the progress\n            of the algorithm. If `disp` is set to `True`, the algorithm will display the progress.\n            If `disp` is set to `False`, the algorithm will not display the progress.\n        callback_type (str, optional): The type of callback to be used. It can have two possible values.\n\n    \"\"\"\n    # self.log = log.scattering_logger(__name__)\n    self.log = logging.getLogger(self.__class__.__module__)\n    self._disp = disp\n    self.niter = 0\n    if callback_type == \"pr_norm\":\n        # self.header = \"% 10s \\t % 15s\" % (\"Iteration\", \"Residual\")\n        self.header = \" Iteration \\t        Residual\"\n    elif callback_type == \"x\":\n        # self.header = \"% 10s \\t %s\" % (\"Iteration\", \"Current Iterate\")\n        self.header = \" Iteration \\t Current Iterate\"\n</code></pre>"},{"location":"reference/solver/#solver.GMResCounter.log","title":"<code>log = logging.getLogger(self.__class__.__module__)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/solver/#solver.GMResCounter.niter","title":"<code>niter = 0</code>  <code>instance-attribute</code>","text":""},{"location":"reference/solver/#solver.GMResCounter.header","title":"<code>header = ' Iteration \\t        Residual'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/solver/#solver.GMResCounter.__call__","title":"<code>__call__</code>","text":"<p>The function increments a counter, formats a message based on the input, logs the header and message, and prints the header and message if the <code>_disp</code> flag is True.</p> <p>Parameters:</p> Name Type Description Default <code>rk</code> <code>Union[ndarray, float]</code> <p>The parameter <code>rk</code> can be either a float or a numpy array.</p> <code>None</code> Source code in <code>yasfpy/solver.py</code> <pre><code>def __call__(self, rk=None):\n    \"\"\"The function increments a counter, formats a message based on the input, logs the header and\n    message, and prints the header and message if the `_disp` flag is True.\n\n    Args:\n        rk (Union[np.ndarray, float]): The parameter `rk` can be either a float or a numpy array.\n\n    \"\"\"\n    self.niter += 1\n    if isinstance(rk, float):\n        # msg = \"% 10i \\t % 15.5f\" % (self.niter, rk)\n        msg = f\"{self.niter:10} \\t {rk:15.5f}\"\n    elif isinstance(rk, np.ndarray):\n        # msg = \"% 10i \\t \" % self.niter + np.array2string(rk)\n        msg = f\"{self.niter:10} \\t {np.array2string(rk)}\"\n\n    self.log.debug(self.header)\n    self.log.debug(msg)\n    if self._disp:\n        print(self.header)\n        print(msg)\n</code></pre>"},{"location":"reference/summary/","title":"Yasfpy","text":"<ul> <li>Yasfpy</li> <li>Benchmark<ul> <li>Adda</li> <li>Mstm3</li> <li>Mstm4</li> </ul> </li> <li>Cli</li> <li>Computers<ul> <li>Computer</li> <li>Computer Cpu</li> <li>Computer Cuda</li> </ul> </li> <li>Config</li> <li>Functions<ul> <li>Cpu Numba</li> <li>Cuda Numba</li> <li>Legendre Normalized Trigon</li> <li>Material Handler</li> <li>Misc</li> <li>Spherical Functions Trigon</li> <li>T Entry</li> </ul> </li> <li>Initial Field</li> <li>Log</li> <li>Numerics</li> <li>Optics</li> <li>Parameters</li> <li>Particles</li> <li>Simulation</li> <li>Solver</li> <li>Yasf</li> </ul>"},{"location":"reference/yasf/","title":"Yasf","text":""},{"location":"reference/yasf/#yasf.YASF","title":"<code>YASF</code>","text":"Source code in <code>yasfpy/yasf.py</code> <pre><code>def __init__(\n    self,\n    path_config: str,\n    preprocess: bool = True,\n    path_cluster: str = \"\",\n):\n    # super().__init__(\n    #     path_config=path_config,\n    #     preprocess=preprocess,\n    #     path_cluster=path_cluster,\n    # )\n    self.path_config = path_config\n    self.config = Config(path_config, preprocess, path_cluster)\n\n    self.particles = Particles(\n        self.config.spheres[:, 0:3],\n        self.config.spheres[:, 3],\n        self.config.spheres[:, 4],\n        refractive_index_table=self.config.refractive_index_interpolated,\n        # refractive_index_table=self.config.material,\n    )\n    self.initial_field = InitialField(\n        beam_width=self.config.config[\"initial_field\"][\"beam_width\"],\n        focal_point=np.array(self.config.config[\"initial_field\"][\"focal_point\"]),\n        polar_angle=self.config.config[\"initial_field\"][\"polar_angle\"],\n        azimuthal_angle=self.config.config[\"initial_field\"][\"azimuthal_angle\"],\n        polarization=self.config.config[\"initial_field\"][\"polarization\"],\n    )\n    self.parameters = Parameters(\n        wavelength=self.config.wavelength,\n        medium_refractive_index=self.config.medium_refractive_index,\n        particles=self.particles,\n        initial_field=self.initial_field,\n    )\n    self.solver = Solver(\n        solver_type=self.config.config[\"solver\"][\"type\"],\n        tolerance=self.config.config[\"solver\"][\"tolerance\"],\n        max_iter=self.config.config[\"solver\"][\"max_iter\"],\n        restart=self.config.config[\"solver\"][\"restart\"],\n    )\n    self.numerics = Numerics(\n        lmax=self.config.config[\"numerics\"][\"lmax\"],\n        sampling_points_number=self.config.config[\"numerics\"][\"sampling_points\"],\n        particle_distance_resolution=self.config.config[\"numerics\"][\n            \"particle_distance_resolution\"\n        ],\n        gpu=self.config.config[\"numerics\"][\"gpu\"],\n        solver=self.solver,\n    )\n    self.simulation = Simulation(self.parameters, self.numerics)\n    self.optics = Optics(self.simulation)\n</code></pre>"},{"location":"reference/yasf/#yasf.YASF.path_cluster","title":"<code>path_cluster: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/yasf/#yasf.YASF.path_config","title":"<code>path_config: str = path_config</code>  <code>instance-attribute</code>","text":""},{"location":"reference/yasf/#yasf.YASF.config","title":"<code>config: dict = Config(path_config, preprocess, path_cluster)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/yasf/#yasf.YASF.particles","title":"<code>particles = Particles(self.config.spheres[:, 0:3], self.config.spheres[:, 3], self.config.spheres[:, 4], refractive_index_table=self.config.refractive_index_interpolated)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/yasf/#yasf.YASF.initial_field","title":"<code>initial_field = InitialField(beam_width=self.config.config['initial_field']['beam_width'], focal_point=np.array(self.config.config['initial_field']['focal_point']), polar_angle=self.config.config['initial_field']['polar_angle'], azimuthal_angle=self.config.config['initial_field']['azimuthal_angle'], polarization=self.config.config['initial_field']['polarization'])</code>  <code>instance-attribute</code>","text":""},{"location":"reference/yasf/#yasf.YASF.parameters","title":"<code>parameters = Parameters(wavelength=self.config.wavelength, medium_refractive_index=self.config.medium_refractive_index, particles=self.particles, initial_field=self.initial_field)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/yasf/#yasf.YASF.solver","title":"<code>solver = Solver(solver_type=self.config.config['solver']['type'], tolerance=self.config.config['solver']['tolerance'], max_iter=self.config.config['solver']['max_iter'], restart=self.config.config['solver']['restart'])</code>  <code>instance-attribute</code>","text":""},{"location":"reference/yasf/#yasf.YASF.numerics","title":"<code>numerics = Numerics(lmax=self.config.config['numerics']['lmax'], sampling_points_number=self.config.config['numerics']['sampling_points'], particle_distance_resolution=self.config.config['numerics']['particle_distance_resolution'], gpu=self.config.config['numerics']['gpu'], solver=self.solver)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/yasf/#yasf.YASF.simulation","title":"<code>simulation = Simulation(self.parameters, self.numerics)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/yasf/#yasf.YASF.optics","title":"<code>optics = Optics(self.simulation)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/yasf/#yasf.YASF.run","title":"<code>run</code>","text":"Source code in <code>yasfpy/yasf.py</code> <pre><code>def run(self, points: np.ndarray = None):\n    self.particles.compute_volume_equivalent_area()\n    self.numerics.compute_spherical_unity_vectors()\n    self.numerics.compute_translation_table()\n    self.simulation.compute_mie_coefficients()\n    self.simulation.compute_initial_field_coefficients()\n    self.simulation.compute_right_hand_side()\n    self.simulation.compute_scattered_field_coefficients()\n    if self.config.config[\"optics\"]:\n        self.optics.compute_cross_sections()\n        self.optics.compute_efficiencies()\n        self.optics.compute_phase_funcition()\n\n    # NOTE: Legacy, needs to be removed\n    if points is not None:\n        self.optics.simulation.compute_fields(points)\n\n    if \"points\" in self.config.config:\n        points = np.stack(\n            (\n                self.config.config[\"points\"][\"x\"],\n                self.config.config[\"points\"][\"y\"],\n                self.config.config[\"points\"][\"z\"],\n            ),\n            axis=1,\n        )\n        self.optics.simulation.compute_fields(points)\n</code></pre>"},{"location":"reference/yasf/#yasf.YASF.benchmark","title":"<code>benchmark</code>  <code>staticmethod</code>","text":"Source code in <code>yasfpy/yasf.py</code> <pre><code>@staticmethod\ndef benchmark(config_path: str = None, runner: pyperf.Runner = None):\n    if config_path is None:\n        raise Exception(\"Plase provide a config file!\")\n    if runner is None:\n        raise Exception(\"Plase provide a runner for benchmarking!\")\n    runner.bench_func(\"yasf_init\", lambda: YASF(config_path))\n    yasf_instance = YASF(config_path)\n    runner.bench_func(\"yasf_run\", lambda: yasf_instance.run())\n</code></pre>"},{"location":"reference/yasf/#yasf.YASF.profiler","title":"<code>profiler</code>  <code>staticmethod</code>","text":"Source code in <code>yasfpy/yasf.py</code> <pre><code>@staticmethod\ndef profiler(config_path: str = None, output: str = None):\n    if config_path is None:\n        raise Exception(\"Plase provide a config file!\")\n    with cProfile.Profile() as pr:\n        yasf_instance = YASF(config_path)\n        yasf_instance.run()\n        stats = pstats.Stats(pr).sort_stats(pstats.SortKey.TIME)\n        stats.print_stats() if output is None else stats.dump_stats(output)\n        return yasf_instance\n</code></pre>"},{"location":"reference/benchmark/adda/","title":"Adda","text":""},{"location":"reference/benchmark/adda/#benchmark.adda.DEFAULT_BIN_PATH","title":"<code>DEFAULT_BIN_PATH = ''</code>  <code>module-attribute</code>","text":""},{"location":"reference/benchmark/adda/#benchmark.adda.DEFAULT_CONF_PATH","title":"<code>DEFAULT_CONF_PATH = ''</code>  <code>module-attribute</code>","text":""},{"location":"reference/benchmark/adda/#benchmark.adda.adda","title":"<code>adda = ADDAManager('./config.json', './MSTM3/src/mstm')</code>  <code>module-attribute</code>","text":""},{"location":"reference/benchmark/adda/#benchmark.adda.runner","title":"<code>runner = pyperf.Runner(values=1, processes=5, warmups=1)</code>  <code>module-attribute</code>","text":""},{"location":"reference/benchmark/adda/#benchmark.adda.ADDAManager","title":"<code>ADDAManager</code>","text":"Source code in <code>yasfpy/benchmark/adda.py</code> <pre><code>def __init__(\n    self,\n    config_path: str = DEFAULT_CONF_PATH,\n    binary: str = DEFAULT_BIN_PATH,\n    output_file: str = \"wow\",\n):\n    self.config = Config(config_path)\n    self.binary = binary\n    self.output_file = output_file\n</code></pre>"},{"location":"reference/benchmark/adda/#benchmark.adda.ADDAManager.config","title":"<code>config = Config(config_path)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/adda/#benchmark.adda.ADDAManager.binary","title":"<code>binary = binary</code>  <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/adda/#benchmark.adda.ADDAManager.output_file","title":"<code>output_file = output_file</code>  <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/adda/#benchmark.adda.ADDAManager.__exec","title":"<code>__exec</code>","text":"Source code in <code>yasfpy/benchmark/adda.py</code> <pre><code>def __exec(self, runner: pyperf.Runner = None):\n    # command = [self.binary, self.input_args]\n    if self.config.spheres.shape[0] &gt; 1:\n        print(\n            \"WARNING! MORE THAN 1 SPHERE DETECTED IN CONFIG! USING ONLY THE FIRST SPHERE!\"\n        )\n\n    diameter = (\n        self.config.spheres[0, 3] * 2\n    )  # TODO: THIS ALWAYS NEEDS TO BE IN NANOMETERS\n    for wi, wavelength in enumerate(self.config.wavelength):\n        command = [\n            self.binary,\n            f\"-size\",\n            f\"{diameter}\",\n            f\"-lambda\",\n            f\"{wavelength}\",\n            f\"-m\",\n            f\"{self.config.medium_refractive_index[wi].real}\",\n            f\"{self.config.medium_refractive_index[wi].imag}\",\n            \"-asym\",\n            f\"-dir\",\n            f\"run_sphere_r{diameter}_l{wavelength}\",\n        ]\n    if runner is None:\n        os.system(\" \".join(command))\n    else:\n        # TODO: this needs to take into account all wavelengths\n        runner.bench_command(\"mstm3_exec\", command)\n</code></pre>"},{"location":"reference/benchmark/adda/#benchmark.adda.ADDAManager.__read","title":"<code>__read</code>","text":"Source code in <code>yasfpy/benchmark/adda.py</code> <pre><code>def __read(self):\n    q_exts: list[float] = []\n    q_scats: list[float] = []\n    gs: list[float] = []\n    c_exts: list[float] = []\n    c_scats: list[float] = []\n    diameter = self.config.spheres[0, 3] * 2\n    for wavelength in self.config.wavelength:\n        with open(f\"run_sphere_r{diameter}_l{wavelength}/CrossSec-Y\", \"r\") as f:\n            data = f.readlines()\n        for line in data:\n            if len(re.findall(\"^g\\t=\", line)) &gt; 0:\n                g = float(line.split(\"=\")[-1].strip().split(\",\")[-1].strip(\")\"))\n                gs.append(g)\n            if len(re.findall(\"Qsca\\t\", line)) &gt; 0:\n                q_sca = float(line.split(\"=\")[-1].strip())\n                q_scats.append(q_sca)\n            if len(re.findall(\"Qext\\t\", line)) &gt; 0:\n                q_ext = float(line.split(\"=\")[-1].strip())\n                q_exts.append(q_ext)\n            if len(re.findall(\"Csca\\t\", line)) &gt; 0:\n                c_sca = float(line.split(\"=\")[-1].strip())\n                c_scats.append(c_sca)\n            if len(re.findall(\"Cext\\t\", line)) &gt; 0:\n                c_ext = float(line.split(\"=\")[-1].strip())\n                c_exts.append(c_ext)\n    adda = {\n        \"cross_sections\": {\"C_scat\": c_scats, \"C_ext\": c_ext},\n        \"efficiencies\": {\n            \"Q_scat\": q_scats,\n            \"Q_ext\": q_exts,\n        },\n        \"asymmetry\": {\"g\": gs},\n    }\n    self.output = adda\n</code></pre>"},{"location":"reference/benchmark/adda/#benchmark.adda.ADDAManager.clean","title":"<code>clean</code>","text":"Source code in <code>yasfpy/benchmark/adda.py</code> <pre><code>def clean(self):\n    # TODO: clean folders\n    res_dirs = [i for i in os.listdir() if len(re.findall(\"run_sphere\", i)) &gt; 0]\n    for dir in res_dirs:\n        shutil.rmtree(dir)\n    pass\n</code></pre>"},{"location":"reference/benchmark/adda/#benchmark.adda.ADDAManager.run","title":"<code>run</code>","text":"Source code in <code>yasfpy/benchmark/adda.py</code> <pre><code>def run(self, runner: pyperf.Runner = None, cleanup: bool = True):\n    self.__exec(runner)\n    if runner is None:\n        self.__read()\n\n    if cleanup:\n        self.clean()\n</code></pre>"},{"location":"reference/benchmark/adda/#benchmark.adda.ADDAManager.export","title":"<code>export</code>","text":"Source code in <code>yasfpy/benchmark/adda.py</code> <pre><code>def export(self, file: str = None, cleanup: bool = False):\n    if file is None:\n        raise Exception(\"Please provide a filename\")\n    self.run(cleanup=False)\n    adda = copy.deepcopy(self.output)\n\n    match file.split(\".\")[-1]:\n        case \"json\":\n            with open(file, \"w\") as outfile:\n                json.dump(self.output, outfile)\n        case \"yaml\" | \"yml\":\n            with open(file, \"w\") as outfile:\n                yaml.dump(self.output, outfile, default_flow_style=False)\n        case \"bz2\":\n            with bz2.BZ2File(file, \"w\") as outfile:\n                _pickle.dump(self.output, outfile)\n        case _:\n            raise Exception(\n                \"The provided config file needs to be a json or yaml file!\"\n            )\n\n    if cleanup:\n        self.clean()\n</code></pre>"},{"location":"reference/benchmark/mstm3/","title":"Mstm3","text":""},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.mstm","title":"<code>mstm = MSTM3Manager('./config.json', './MSTM3/src/mstm')</code>  <code>module-attribute</code>","text":""},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.runner","title":"<code>runner = pyperf.Runner(values=1, processes=5, warmups=1)</code>  <code>module-attribute</code>","text":""},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager","title":"<code>MSTM3Manager</code>","text":"Source code in <code>yasfpy/benchmark/mstm3.py</code> <pre><code>def __init__(\n    self,\n    config_path: str = None,\n    binary: str = None,\n    input_file: str = \"mstm3.inp\",\n    output_file: str = \"mstm3.dat\",\n):\n    self.config = Config(config_path)\n    self.binary = binary\n\n    self.input_file = input_file\n    self.output_file = output_file\n</code></pre>"},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager.config","title":"<code>config = Config(config_path)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager.binary","title":"<code>binary: str = binary</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager.input_file","title":"<code>input_file: str = input_file</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager.output_file","title":"<code>output_file: str = output_file</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager.__write","title":"<code>__write</code>","text":"Source code in <code>yasfpy/benchmark/mstm3.py</code> <pre><code>def __write(\n    self,\n    fixed_lmax: bool = True,\n    save: bool = True,\n) -&gt; None:\n    mstm_config = \"output_file\\n\"\n    mstm_config += f\"{self.output_file}\\n\"\n    mstm_config += \"write_sphere_data\\n\"\n    mstm_config += \"1\\n\"\n    mstm_config += \"calculate_scattering_coefficients\\n\"\n    mstm_config += \"1\\n\"\n    # mstm_config += \"scattering_coefficient_file\\n\"\n    # mstm_config += \"mstm3.coef\\n\"\n    mstm_config += \"incident_or_target_frame\\n\"\n    mstm_config += \"0\\n\"\n    mstm_config += \"min_scattering_angle_deg\\n\"\n    mstm_config += \"0.0d0\\n\"\n    mstm_config += \"max_scattering_angle_deg\\n\"\n    mstm_config += \"180.d0\\n\"\n    mstm_config += \"min_scattering_plane_angle_deg\\n\"\n    mstm_config += \"0.0d0\\n\"\n    mstm_config += \"max_scattering_plane_angle_deg\\n\"\n    mstm_config += \"360.0d0\\n\"\n    mstm_config += \"delta_scattering_angle_deg\\n\"\n    mstm_config += \"30\\n\"\n    mstm_config += \"normalize_scattering_matrix\\n\"\n    mstm_config += \"0\\n\"\n    mstm_config += \"incident_polar_angle_deg\\n\"\n    mstm_config += f\"{self.config.config['initial_field']['polar_angle']:e}\\n\"\n    mstm_config += \"incident_azimuth_angle_deg\\n\"\n    mstm_config += f\"{self.config.config['initial_field']['azimuthal_angle']:e}\\n\"\n    mstm_config += \"real_ref_index_scale_factor\\n\"\n    mstm_config += \"1.0d0\\n\"\n    mstm_config += \"imag_ref_index_scale_factor\\n\"\n    mstm_config += \"1.0d0\\n\"\n    mstm_config += \"real_chiral_factor\\n\"\n    mstm_config += \"0.0d0\\n\"\n    mstm_config += \"imag_chiral_factor\\n\"\n    mstm_config += \"0.0d0\\n\"\n    mstm_config += \"medium_real_chiral_factor\\n\"\n    mstm_config += \"0.d0\\n\"\n    mstm_config += \"medium_imag_chiral_factor\\n\"\n    mstm_config += \"0.d0\\n\"\n\n    if fixed_lmax:\n        mstm_config += \"mie_epsilon\\n\"\n        mstm_config += f\"-{int(self.config.config['numerics']['lmax'])}\\n\"\n\n    ref_idx = np.take(\n        self.config.refractive_index_interpolated,\n        self.config.spheres[:, 4].astype(int),\n        axis=0,\n    )\n    for wl_idx, wl in enumerate(self.config.wavelength):\n        mstm_config += \"length_scale_factor\\n\"\n        mstm_config += f\"{2 * np.pi / (wl * self.config.wavelength_scale / self.config.particles_scale):e}\\n\"\n        mstm_config += \"medium_real_ref_index\\n\"\n        mstm_config += f\"{self.config.medium_refractive_index[wl_idx].real}\\n\"\n        mstm_config += \"medium_imag_ref_index\\n\"\n        mstm_config += f\"{self.config.medium_refractive_index[wl_idx].imag}\\n\"\n        mstm_config += \"number_spheres\\n\"\n        mstm_config += f\"{self.config.spheres.shape[0]}\\n\"\n\n        mstm_config += \"sphere_sizes_and_positions\\n\"\n        for particle_idx in range(self.config.spheres.shape[0]):\n            position_str = \",\".join(\n                [str(i) for i in self.config.spheres[particle_idx, [3, 0, 1, 2]]]\n            )\n            ref_idx_str = f\"{ref_idx[particle_idx, wl_idx].real}, {ref_idx[particle_idx, wl_idx].imag}\"\n            mstm_config += f\"{position_str},{ref_idx_str}\\n\"\n\n        if wl_idx + 1 == self.config.wavelength.size:\n            mstm_config += \"end_of_options\"\n        else:\n            mstm_config += \"new_run\\n\"\n\n    if save:\n        with open(self.input_file, \"w\") as fh:\n            fh.write(mstm_config)\n\n    return mstm_config\n</code></pre>"},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager.__exec","title":"<code>__exec</code>","text":"Source code in <code>yasfpy/benchmark/mstm3.py</code> <pre><code>def __exec(self, runner: pyperf.Runner = None):\n    command = [self.binary, self.input_file]\n    if runner is None:\n        os.system(\" \".join(command))\n    else:\n        runner.bench_command(\"mstm3_exec\", command)\n</code></pre>"},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager.__parse_output","title":"<code>__parse_output</code>  <code>staticmethod</code>","text":"Source code in <code>yasfpy/benchmark/mstm3.py</code> <pre><code>@staticmethod\ndef __parse_output(results):\n    p = re.compile(r\"input parameters for run number\\s+(\\d+)\")\n    r = p.search(results)\n    id = r.group(1)\n    id = int(id)\n\n    p = re.compile(r\"length, ref. indx. scale factors:\\s+(.+?)\\s+(.+?)\\s+(.+?)\")\n    r = p.search(results)\n    length_scale_factor = r.group(1)\n    length_scale_factor = float(length_scale_factor)\n\n    p = re.compile(\n        r\"sphere host\\s+ka\\s+x-x\\(host\\)\\s+y-y\\(host\\)\\s+z-z\\(host\\)\\s+Re\\(m\\)\\s+Im\\(m\\)\\s+ Qext\\s+Qsca\\s+Qabs\\s+Qabs\\(V\\)(.+)unpolarized\",\n        re.S,\n    )\n    r = p.search(results)\n    sphere_data = r.group(1)\n    sphere_data = pd.read_csv(\n        StringIO(sphere_data),\n        names=[\n            \"sphere host\",\n            \"ka\",\n            \"x-x(host)\",\n            \"y-y(host)\",\n            \"z-z(host)\",\n            \"Re(m)\",\n            \"Im(m)\",\n            \"Qext\",\n            \"Qsca\",\n            \"Qabs\",\n            \"Qabs(V)\",\n        ],\n        header=None,\n        sep=\"\\s+\",\n    )\n\n    efficiencies = {}\n\n    p = re.compile(\n        r\"unpolarized total ext, abs, scat efficiencies, w.r.t. xv, and asym. parm\\s+(.+)\"\n    )\n    r = p.search(results)\n    efficiencies_unp = r.group(1)\n    efficiencies_unp = [float(e) for e in efficiencies_unp.split()]\n    efficiencies[\"q_ext_unp\"] = efficiencies_unp[0]\n    efficiencies[\"q_abs_unp\"] = efficiencies_unp[1]\n    efficiencies[\"q_sca_unp\"] = efficiencies_unp[2]\n\n    p = re.compile(r\"parallel total ext, abs, scat efficiencies\\s+(.+)\")\n    r = p.search(results)\n    efficiencies_par = r.group(1)\n    efficiencies_par = [float(e) for e in efficiencies_par.split()]\n    efficiencies[\"q_ext_par\"] = efficiencies_par[0]\n    efficiencies[\"q_abs_par\"] = efficiencies_par[1]\n    efficiencies[\"q_sca_par\"] = efficiencies_par[2]\n\n    p = re.compile(r\"perpendicular total ext, abs, scat efficiencies\\s+(.+)\")\n    r = p.search(results)\n    efficiencies_per = r.group(1)\n    efficiencies_per = [float(e) for e in efficiencies_per.split()]\n    efficiencies[\"q_ext_per\"] = efficiencies_per[0]\n    efficiencies[\"q_abs_per\"] = efficiencies_per[1]\n    efficiencies[\"q_sca_per\"] = efficiencies_per[2]\n\n    p = re.compile(\n        r\"theta\\s+phi\\s+11\\s+12\\s+13\\s+14\\s+21\\s+22\\s+23\\s+24\\s+31\\s+32\\s+33\\s+34\\s+41\\s+42\\s+43\\s+44\\s+(.+)\",\n        re.S,\n    )\n    r = p.search(results)\n    scattering_matrix = r.group(1)\n    scattering_matrix = pd.read_csv(\n        StringIO(scattering_matrix),\n        names=[\n            \"theta\",\n            \"phi\",\n            \"11\",\n            \"12\",\n            \"13\",\n            \"14\",\n            \"21\",\n            \"22\",\n            \"23\",\n            \"24\",\n            \"31\",\n            \"32\",\n            \"33\",\n            \"34\",\n            \"41\",\n            \"42\",\n            \"43\",\n            \"44\",\n        ],\n        header=None,\n        sep=\"\\s+\",\n    )\n\n    return dict(\n        id=id,\n        length_scale_factor=length_scale_factor,\n        sphere_data=sphere_data,\n        efficiencies=efficiencies,\n        scattering_matrix=scattering_matrix,\n    )\n</code></pre>"},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager.__read","title":"<code>__read</code>","text":"Source code in <code>yasfpy/benchmark/mstm3.py</code> <pre><code>def __read(self):\n    output = None\n    with open(self.output_file, \"r\") as fh:\n        output = fh.read()\n\n    if output is None:\n        raise Exception(\"Could not read file\")\n\n    section_divider = \"*****************************************************\\n\"\n    sections = output.split(section_divider)\n\n    results = []\n    for s in sections:\n        results.append(MSTM3Manager.__parse_output(s))\n    if not results:\n        raise Exception(\"No results found in the file!\")\n    number_of_particles = results[0][\"sphere_data\"].shape[0]\n    number_of_angles = results[0][\"scattering_matrix\"].shape[0]\n    number_of_runs = len(results)\n    sphere_data_header = list(results[0][\"sphere_data\"])\n    scattering_matrix_header = list(results[0][\"scattering_matrix\"])\n\n    mstm = dict(\n        length_scale_factor=np.zeros(number_of_runs),\n        # sphere_data=[None] * number_of_runs,\n        sphere_data={\n            key: np.zeros((number_of_particles, number_of_runs))\n            for key in sphere_data_header\n        },\n        efficiencies=dict(\n            q_ext_unp=np.zeros(number_of_runs),\n            q_abs_unp=np.zeros(number_of_runs),\n            q_sca_unp=np.zeros(number_of_runs),\n            q_ext_par=np.zeros(number_of_runs),\n            q_abs_par=np.zeros(number_of_runs),\n            q_sca_par=np.zeros(number_of_runs),\n            q_ext_per=np.zeros(number_of_runs),\n            q_abs_per=np.zeros(number_of_runs),\n            q_sca_per=np.zeros(number_of_runs),\n        ),\n        # scattering_matrix=[None] * number_of_runs,\n        scattering_matrix={\n            key: np.zeros((number_of_angles, number_of_runs))\n            for key in scattering_matrix_header\n        },\n    )\n    for r in results:\n        idx = r[\"id\"] - 1\n        mstm[\"length_scale_factor\"][idx] = r[\"length_scale_factor\"]\n        for key in sphere_data_header:\n            mstm[\"sphere_data\"][key][:, idx] = r[\"sphere_data\"][key].to_numpy()\n        for efficiency_type, value in r[\"efficiencies\"].items():\n            mstm[\"efficiencies\"][efficiency_type][idx] = value\n        for key in scattering_matrix_header:\n            mstm[\"scattering_matrix\"][key][:, idx] = r[\"scattering_matrix\"][\n                key\n            ].to_numpy()\n\n    self.output = mstm\n</code></pre>"},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager.clean","title":"<code>clean</code>","text":"Source code in <code>yasfpy/benchmark/mstm3.py</code> <pre><code>def clean(self):\n    os.system(f\"rm -f {self.input_file} {self.output_file} mstm3.coef\")\n</code></pre>"},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager.run","title":"<code>run</code>","text":"Source code in <code>yasfpy/benchmark/mstm3.py</code> <pre><code>def run(self, runner: pyperf.Runner = None, cleanup: bool = True):\n    self.__write()\n    self.__exec(runner)\n    if runner is None:\n        self.__read()\n\n    if cleanup:\n        self.clean()\n</code></pre>"},{"location":"reference/benchmark/mstm3/#benchmark.mstm3.MSTM3Manager.export","title":"<code>export</code>","text":"Source code in <code>yasfpy/benchmark/mstm3.py</code> <pre><code>def export(self, file: str = None, cleanup: bool = False):\n    if file is None:\n        raise Exception(\"Please provide a filename\")\n    self.run(cleanup=False)\n    mstm = copy.deepcopy(self.output)\n\n    mstm[\"length_scale_factor\"] = mstm[\"length_scale_factor\"].tolist()\n    for tag in [\"sphere_data\", \"efficiencies\", \"scattering_matrix\"]:\n        for key, value in mstm[tag].items():\n            mstm[tag][key] = value.tolist()\n\n    match file.split(\".\")[-1]:\n        case \"json\":\n            with open(file, \"w\") as outfile:\n                json.dump(self.output, outfile)\n        case \"yaml\" | \"yml\":\n            with open(file, \"w\") as outfile:\n                yaml.dump(self.output, outfile, default_flow_style=False)\n        case \"bz2\":\n            with bz2.BZ2File(file, \"w\") as outfile:\n                _pickle.dump(self.output, outfile)\n        case _:\n            raise Exception(\n                \"The provided config file needs to be a json or yaml file!\"\n            )\n\n    if cleanup:\n        self.clean()\n</code></pre>"},{"location":"reference/benchmark/mstm4/","title":"Mstm4","text":""},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.mstm","title":"<code>mstm = MSTM4Manager('./config.json', './MSTM/code/mstm', parallel=4)</code>  <code>module-attribute</code>","text":""},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.runner","title":"<code>runner = pyperf.Runner(values=1, processes=5, warmups=1)</code>  <code>module-attribute</code>","text":""},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager","title":"<code>MSTM4Manager</code>","text":"Source code in <code>yasfpy/benchmark/mstm4.py</code> <pre><code>def __init__(\n    self,\n    config_path: str = None,\n    binary: str = None,\n    input_file: str = \"mstm4.inp\",\n    output_file: str = \"mstm4.dat\",\n    parallel: int = 1,\n):\n    self.config = Config(config_path)\n    self.binary = binary\n\n    self.input_file = input_file\n    self.output_file = output_file\n\n    self.parallel = parallel\n</code></pre>"},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.config","title":"<code>config = Config(config_path)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.binary","title":"<code>binary: str = binary</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.input_file","title":"<code>input_file: str = input_file</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.output_file","title":"<code>output_file: str = output_file</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.parallel","title":"<code>parallel: int = parallel</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.__write","title":"<code>__write</code>","text":"Source code in <code>yasfpy/benchmark/mstm4.py</code> <pre><code>def __write(\n    self,\n    fixed_lmax: bool = True,\n    save: bool = True,\n) -&gt; None:\n    mstm_config = \"output_file\\n\"\n    mstm_config += f\"{self.output_file}\\n\"\n    mstm_config += \"print_sphere_data\\n\"\n    mstm_config += \"t\\n\"\n    mstm_config += \"calculate_scattering_matrix\\n\"\n    mstm_config += \"t\\n\"\n    mstm_config += \"incident_frame\\n\"\n    mstm_config += \"f\\n\"\n    mstm_config += \"scattering_map_model\\n\"\n    mstm_config += \"0\\n\"\n    mstm_config += \"scattering_map_increment\\n\"\n    mstm_config += \"30.d0\\n\"\n    mstm_config += \"incident_beta_deg\\n\"\n    mstm_config += f\"{self.config.config['initial_field']['polar_angle']:e}\\n\"\n    mstm_config += \"incident_alpha_deg\\n\"\n    mstm_config += f\"{self.config.config['initial_field']['azimuthal_angle']:e}\\n\"\n\n    if fixed_lmax:\n        mstm_config += \"mie_epsilon\\n\"\n        mstm_config += f\"-{int(self.config.config['numerics']['lmax'])}\\n\"\n\n    ref_idx = np.take(\n        self.config.refractive_index_interpolated,\n        self.config.spheres[:, 4].astype(int),\n        axis=0,\n    )\n    for wl_idx, wl in enumerate(self.config.wavelength):\n        mstm_config += \"length_scale_factor\\n\"\n        mstm_config += f\"{2 * np.pi / (wl * self.config.wavelength_scale / self.config.particles_scale)}\\n\"\n        mstm_config += \"layer_ref_index\\n\"\n        mstm_config += f\"({self.config.medium_refractive_index[wl_idx].real}, {self.config.medium_refractive_index[wl_idx].imag})\\n\"\n        mstm_config += \"number_spheres\\n\"\n        mstm_config += f\"{self.config.spheres.shape[0]}\\n\"\n\n        mstm_config += \"sphere_data\\n\"\n        for particle_idx in range(self.config.spheres.shape[0]):\n            position_str = \",\".join(\n                [str(i) for i in self.config.spheres[particle_idx, :-1]]\n            )\n            ref_idx_str = f\"({ref_idx[particle_idx, wl_idx].real}, {ref_idx[particle_idx, wl_idx].imag})\"\n            mstm_config += f\"{position_str},{ref_idx_str}\\n\"\n\n        mstm_config += \"end_of_sphere_data\\n\"\n\n        if wl_idx + 1 == self.config.wavelength.size:\n            mstm_config += \"end_of_options\"\n        else:\n            mstm_config += \"new_run\\n\"\n\n    if save:\n        with open(self.input_file, \"w\") as fh:\n            fh.write(mstm_config)\n\n    return mstm_config\n</code></pre>"},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.__exec","title":"<code>__exec</code>","text":"Source code in <code>yasfpy/benchmark/mstm4.py</code> <pre><code>def __exec(self, runner: pyperf.Runner = None):\n    if self.parallel == 1:\n        command = [self.binary, self.input_file]\n    elif self.parallel % 4 == 0:\n        command = [\n            \"mpiexec\",\n            \"-n\",\n            str(self.parallel),\n            self.binary,\n            self.input_file,\n        ]\n    else:\n        raise Exception(\"parallel parameter needs to be divisble by 4!\")\n\n    if runner is None:\n        os.system(\" \".join(command))\n    else:\n        runner.bench_command(f\"mstm4_exec_{self.parallel}\", command)\n</code></pre>"},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.__parse_input","title":"<code>__parse_input</code>  <code>staticmethod</code>","text":"Source code in <code>yasfpy/benchmark/mstm4.py</code> <pre><code>@staticmethod\ndef __parse_input(input):\n    # Get id of run\n    p = re.compile(\"\\s+input variables for run\\s+(\\d+)\")\n    r = p.search(input)\n    id = r.group(1)\n    id = int(id)\n\n    # lengths scale factor\n    p = re.compile(\"\\s+length, ref index scale factors\\s+(.+?)\\s+(.+?)\\s+(.+?)\")\n    r = p.search(input)\n    length_scale_factor = r.group(1)\n    length_scale_factor = float(length_scale_factor)\n\n    return dict(\n        id=id,\n        length_scale_factor=length_scale_factor,\n    )\n</code></pre>"},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.__parse_output","title":"<code>__parse_output</code>  <code>staticmethod</code>","text":"Source code in <code>yasfpy/benchmark/mstm4.py</code> <pre><code>@staticmethod\ndef __parse_output(results):\n    # Get id of run\n    p = re.compile(r\"\\s+calculation results for run\\s+(\\d+)\")\n    r = p.search(results)\n    id = r.group(1)\n    id = int(id)\n\n    p = re.compile(r\"sphere\\s+Qext\\s+Qabs\\s+Qvabs\\s+(.+)total\", re.S)\n    r = p.search(results)\n    sphere_data = r.group(1)\n    sphere_data = pd.read_csv(\n        StringIO(sphere_data),\n        names=[\"sphere\", \"Qext\", \"Qabs\", \"Qvabs\"],\n        header=None,\n        sep=\"\\s+\",\n    )\n\n    p = re.compile(\n        r\"total extinction, absorption, scattering efficiencies \\(unpol, par, perp incidence\\)\\s+(.+)\"\n    )\n    r = p.search(results)\n    efficiencies = r.group(1)\n    efficiencies = [float(e) for e in efficiencies.split()]\n    efficiencies = dict(\n        q_ext_unp=efficiencies[0],\n        q_abs_unp=efficiencies[1],\n        q_sca_unp=efficiencies[2],\n        q_ext_par=efficiencies[3],\n        q_abs_par=efficiencies[4],\n        q_sca_par=efficiencies[5],\n        q_ext_per=efficiencies[6],\n        q_abs_per=efficiencies[7],\n        q_sca_per=efficiencies[8],\n    )\n\n    p = re.compile(\n        r\"down and up hemispherical scattering efficiencies \\(unpol, par, perp\\)\\s+(.+)\"\n    )\n    r = p.search(results)\n    efficiencies_hem = r.group(1)\n    efficiencies_hem = [float(e) for e in efficiencies_hem.split()]\n    efficiencies_hem = dict(\n        q_hem_u_unp=efficiencies_hem[0],\n        q_hem_d_unp=efficiencies_hem[1],\n        q_hem_u_par=efficiencies_hem[2],\n        q_hem_d_par=efficiencies_hem[3],\n        q_hem_u_per=efficiencies_hem[4],\n        q_hem_d_per=efficiencies_hem[5],\n    )\n\n    p = re.compile(\n        r\"theta\\s+11\\s+12\\s+13\\s+14\\s+21\\s+22\\s+23\\s+24\\s+31\\s+32\\s+33\\s+34\\s+41\\s+42\\s+43\\s+44\\s+(.+)\",\n        re.S,\n    )\n    r = p.search(results)\n    scattering_matrix = r.group(1)\n    scattering_matrix = pd.read_csv(\n        StringIO(scattering_matrix),\n        names=[\n            \"theta\",\n            \"11\",\n            \"12\",\n            \"13\",\n            \"14\",\n            \"21\",\n            \"22\",\n            \"23\",\n            \"24\",\n            \"31\",\n            \"32\",\n            \"33\",\n            \"34\",\n            \"41\",\n            \"42\",\n            \"43\",\n            \"44\",\n        ],\n        header=None,\n        sep=\"\\s+\",\n    )\n\n    return dict(\n        id=id,\n        sphere_data=sphere_data,\n        efficiencies=efficiencies,\n        efficiencies_hem=efficiencies_hem,\n        scattering_matrix=scattering_matrix,\n    )\n</code></pre>"},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.__read","title":"<code>__read</code>","text":"Source code in <code>yasfpy/benchmark/mstm4.py</code> <pre><code>def __read(self):\n    output = None\n    with open(self.output_file, \"r\") as fh:\n        output = fh.read()\n\n    if output is None:\n        raise Exception(\"Could not read file\")\n\n    section_divider = \"****************************************************\\n\"\n    sections = output.split(section_divider)\n    sections = [\n        s\n        for s in sections\n        if (\"calculation results for run\" in s) or (\"input variables for run \" in s)\n    ]\n\n    inputs = []\n    results = []\n    for s in sections:\n        if \"input variables for run \" in s:\n            inputs.append(MSTM4Manager.__parse_input(s))\n        elif \"calculation results for run\" in s:\n            results.append(MSTM4Manager.__parse_output(s))\n    if (not results) or (not inputs):\n        raise Exception(\"No results found in the file!\")\n    number_of_particles = results[0][\"sphere_data\"].shape[0]\n    number_of_angles = results[0][\"scattering_matrix\"].shape[0]\n    number_of_runs = len(inputs)\n    sphere_data_header = list(results[0][\"sphere_data\"])\n    scattering_matrix_header = list(results[0][\"scattering_matrix\"])\n\n    mstm = dict(\n        length_scale_factor=np.zeros(number_of_runs),\n        sphere_data={\n            key: np.zeros((number_of_particles, number_of_runs))\n            for key in sphere_data_header\n        },\n        efficiencies=dict(\n            q_ext_unp=np.zeros(number_of_runs),\n            q_abs_unp=np.zeros(number_of_runs),\n            q_sca_unp=np.zeros(number_of_runs),\n            q_ext_par=np.zeros(number_of_runs),\n            q_abs_par=np.zeros(number_of_runs),\n            q_sca_par=np.zeros(number_of_runs),\n            q_ext_per=np.zeros(number_of_runs),\n            q_abs_per=np.zeros(number_of_runs),\n            q_sca_per=np.zeros(number_of_runs),\n        ),\n        efficiencies_hem=dict(\n            q_hem_u_unp=np.zeros(number_of_runs),\n            q_hem_d_unp=np.zeros(number_of_runs),\n            q_hem_u_par=np.zeros(number_of_runs),\n            q_hem_d_par=np.zeros(number_of_runs),\n            q_hem_u_per=np.zeros(number_of_runs),\n            q_hem_d_per=np.zeros(number_of_runs),\n        ),\n        scattering_matrix={\n            key: np.zeros((number_of_angles, number_of_runs))\n            for key in scattering_matrix_header\n        },\n    )\n\n    for i, r in zip(inputs, results):\n        # inputs\n        idx = i[\"id\"] - 1\n        mstm[\"length_scale_factor\"][idx] = i[\"length_scale_factor\"]\n\n        # results\n        idx = r[\"id\"] - 1\n        for key in sphere_data_header:\n            mstm[\"sphere_data\"][key][:, idx] = r[\"sphere_data\"][key].to_numpy()\n        for efficiency_type, value in r[\"efficiencies\"].items():\n            mstm[\"efficiencies\"][efficiency_type][idx] = value\n        for efficiency_type, value in r[\"efficiencies_hem\"].items():\n            mstm[\"efficiencies_hem\"][efficiency_type][idx] = value\n        for key in scattering_matrix_header:\n            mstm[\"scattering_matrix\"][key][:, idx] = r[\"scattering_matrix\"][\n                key\n            ].to_numpy()\n\n    self.output = mstm\n</code></pre>"},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.clean","title":"<code>clean</code>","text":"Source code in <code>yasfpy/benchmark/mstm4.py</code> <pre><code>def clean(self):\n    os.system(f\"rm -f {self.input_file} {self.output_file} temp_pos.dat\")\n</code></pre>"},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.run","title":"<code>run</code>","text":"Source code in <code>yasfpy/benchmark/mstm4.py</code> <pre><code>def run(self, runner: pyperf.Runner = None, cleanup: bool = True):\n    self.__write()\n    self.__exec(runner)\n    if runner is None:\n        self.__read()\n\n    if cleanup:\n        self.clean()\n</code></pre>"},{"location":"reference/benchmark/mstm4/#benchmark.mstm4.MSTM4Manager.export","title":"<code>export</code>","text":"Source code in <code>yasfpy/benchmark/mstm4.py</code> <pre><code>def export(self, file: str = None, cleanup: bool = False):\n    if file is None:\n        raise Exception(\"Please provide a filename\")\n    self.run(cleanup=False)\n    mstm = copy.deepcopy(self.output)\n\n    mstm[\"length_scale_factor\"] = mstm[\"length_scale_factor\"].tolist()\n    for tag in [\n        \"sphere_data\",\n        \"efficiencies\",\n        \"efficiencies_hem\",\n        \"scattering_matrix\",\n    ]:\n        for key, value in mstm[tag].items():\n            mstm[tag][key] = value.tolist()\n\n    match file.split(\".\")[-1]:\n        case \"json\":\n            with open(file, \"w\") as outfile:\n                json.dump(self.output, outfile)\n        case \"yaml\" | \"yml\":\n            with open(file, \"w\") as outfile:\n                yaml.dump(self.output, outfile, default_flow_style=False)\n        case \"bz2\":\n            with bz2.BZ2File(file, \"w\") as outfile:\n                _pickle.dump(self.output, outfile)\n        case _:\n            raise Exception(\n                \"The provided config file needs to be a json or yaml file!\"\n            )\n\n    if cleanup:\n        self.clean()\n</code></pre>"},{"location":"reference/computers/computer/","title":"Computer","text":""},{"location":"reference/computers/computer/#computers.computer.Computer","title":"<code>Computer</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/computers/computer/#computers.computer.Computer.particle_interaction","title":"<code>particle_interaction</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Perform particle interaction calculations on the GPU.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>Maximum angular momentum quantum number.</p> required <code>particle_number</code> <code>int</code> <p>Number of particles.</p> required <code>idx</code> <code>ndarray</code> <p>Array containing particle indices.</p> required <code>x</code> <code>ndarray</code> <p>Array of particle positions.</p> required <code>wx_real</code> <code>ndarray</code> <p>Array to store the real part of the result.</p> required <code>wx_imag</code> <code>ndarray</code> <p>Array to store the imaginary part of the result.</p> required <code>translation_table</code> <code>ndarray</code> <p>Array containing translation table.</p> required <code>plm</code> <code>ndarray</code> <p>Array containing associated Legendre polynomials.</p> required <code>sph_h</code> <code>ndarray</code> <p>Array containing spherical harmonics.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>Additional parameter for the calculation.</p> required Todo <p>Implement data batching for GPUs with smaller memory</p> Source code in <code>yasfpy/computers/computer.py</code> <pre><code>@abstractmethod\n@staticmethod\ndef particle_interaction(\n    lmax: int,\n    particle_number: int,\n    idx: np.ndarray,\n    x: np.ndarray,\n    wx_real: np.ndarray,\n    wx_imag: np.ndarray,\n    translation_table: np.ndarray,\n    plm: np.ndarray,\n    sph_h: np.ndarray,\n    e_j_dm_phi,\n):\n    \"\"\"\n    Perform particle interaction calculations on the GPU.\n\n    Args:\n        lmax (int): Maximum angular momentum quantum number.\n        particle_number (int): Number of particles.\n        idx (np.ndarray): Array containing particle indices.\n        x (np.ndarray): Array of particle positions.\n        wx_real (np.ndarray): Array to store the real part of the result.\n        wx_imag (np.ndarray): Array to store the imaginary part of the result.\n        translation_table (np.ndarray): Array containing translation table.\n        plm (np.ndarray): Array containing associated Legendre polynomials.\n        sph_h (np.ndarray): Array containing spherical harmonics.\n        e_j_dm_phi (np.ndarray): Additional parameter for the calculation.\n\n    Todo:\n        Implement data batching for GPUs with smaller memory\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/computers/computer/#computers.computer.Computer.compute_scattering_cross_section","title":"<code>compute_scattering_cross_section</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Compute the scattering cross section on the GPU using CUDA.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics expansion.</p> required <code>particle_number</code> <code>int</code> <p>The number of particles.</p> required <code>idx</code> <code>ndarray</code> <p>The index array.</p> required <code>sfc</code> <code>ndarray</code> <p>The scattering form factor array.</p> required <code>translation_table</code> <code>ndarray</code> <p>The translation table array.</p> required <code>plm</code> <code>ndarray</code> <p>The associated Legendre polynomials array.</p> required <code>sph_h</code> <code>ndarray</code> <p>The spherical harmonics array.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>The phase factor array.</p> required <code>c_sca_real</code> <code>ndarray</code> <p>The real part of the scattering cross section array.</p> required <code>c_sca_imag</code> <code>ndarray</code> <p>The imaginary part of the scattering cross section array.</p> required Source code in <code>yasfpy/computers/computer.py</code> <pre><code>@abstractmethod\n@staticmethod\ndef compute_scattering_cross_section(\n    lmax: int,\n    particle_number: int,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    translation_table: np.ndarray,\n    plm: np.ndarray,\n    sph_h: np.ndarray,\n    e_j_dm_phi: np.ndarray,\n    c_sca_real: np.ndarray,\n    c_sca_imag: np.ndarray,\n):\n    \"\"\"\n    Compute the scattering cross section on the GPU using CUDA.\n\n    Args:\n        lmax (int): The maximum degree of the spherical harmonics expansion.\n        particle_number (int): The number of particles.\n        idx (np.ndarray): The index array.\n        sfc (np.ndarray): The scattering form factor array.\n        translation_table (np.ndarray): The translation table array.\n        plm (np.ndarray): The associated Legendre polynomials array.\n        sph_h (np.ndarray): The spherical harmonics array.\n        e_j_dm_phi (np.ndarray): The phase factor array.\n        c_sca_real (np.ndarray): The real part of the scattering cross section array.\n        c_sca_imag (np.ndarray): The imaginary part of the scattering cross section array.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/computers/computer/#computers.computer.Computer.compute_radial_independent_scattered_field","title":"<code>compute_radial_independent_scattered_field</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Compute the radial independent scattered field using GPU acceleration.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics expansion.</p> required <code>particles_position</code> <code>ndarray</code> <p>Array of particle positions.</p> required <code>idx</code> <code>ndarray</code> <p>Array of indices for particle properties.</p> required <code>sfc</code> <code>ndarray</code> <p>Array of scattering form factors.</p> required <code>k_medium</code> <code>ndarray</code> <p>Array of wave numbers in the medium.</p> required <code>azimuthal_angles</code> <code>ndarray</code> <p>Array of azimuthal angles.</p> required <code>e_r</code> <code>ndarray</code> <p>Array of radial electric field components.</p> required <code>e_phi</code> <code>ndarray</code> <p>Array of azimuthal electric field components.</p> required <code>e_theta</code> <code>ndarray</code> <p>Array of polar electric field components.</p> required <code>pilm</code> <code>ndarray</code> <p>Array of associated Legendre polynomials.</p> required <code>taulm</code> <code>ndarray</code> <p>Array of tau coefficients.</p> required <code>e_1_sca_real</code> <code>ndarray</code> <p>Array of real parts of the scattered electric field.</p> required <code>e_1_sca_imag</code> <code>ndarray</code> <p>Array of imaginary parts of the scattered electric field.</p> required Source code in <code>yasfpy/computers/computer.py</code> <pre><code>@abstractmethod\n@staticmethod\ndef compute_radial_independent_scattered_field(\n    lmax: int,\n    particles_position: np.ndarray,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    k_medium: np.ndarray,\n    azimuthal_angles: np.ndarray,\n    e_r: np.ndarray,\n    e_phi: np.ndarray,\n    e_theta: np.ndarray,\n    pilm: np.ndarray,\n    taulm: np.ndarray,\n    e_1_sca_real: np.ndarray,\n    e_1_sca_imag: np.ndarray,\n):\n    \"\"\"\n    Compute the radial independent scattered field using GPU acceleration.\n\n    Args:\n        lmax (int): The maximum degree of the spherical harmonics expansion.\n        particles_position (np.ndarray): Array of particle positions.\n        idx (np.ndarray): Array of indices for particle properties.\n        sfc (np.ndarray): Array of scattering form factors.\n        k_medium (np.ndarray): Array of wave numbers in the medium.\n        azimuthal_angles (np.ndarray): Array of azimuthal angles.\n        e_r (np.ndarray): Array of radial electric field components.\n        e_phi (np.ndarray): Array of azimuthal electric field components.\n        e_theta (np.ndarray): Array of polar electric field components.\n        pilm (np.ndarray): Array of associated Legendre polynomials.\n        taulm (np.ndarray): Array of tau coefficients.\n        e_1_sca_real (np.ndarray): Array of real parts of the scattered electric field.\n        e_1_sca_imag (np.ndarray): Array of imaginary parts of the scattered electric field.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/computers/computer/#computers.computer.Computer.compute_electric_field_angle_components","title":"<code>compute_electric_field_angle_components</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Compute the electric field angle components on the GPU.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum angular momentum quantum number.</p> required <code>particles_position</code> <code>ndarray</code> <p>Array of particle positions.</p> required <code>idx</code> <code>ndarray</code> <p>Array of indices.</p> required <code>sfc</code> <code>ndarray</code> <p>Array of scattering form factors.</p> required <code>k_medium</code> <code>ndarray</code> <p>Array of medium wavevectors.</p> required <code>azimuthal_angles</code> <code>ndarray</code> <p>Array of azimuthal angles.</p> required <code>e_r</code> <code>ndarray</code> <p>Array of radial unit vectors.</p> required <code>pilm</code> <code>ndarray</code> <p>Array of associated Legendre polynomials.</p> required <code>taulm</code> <code>ndarray</code> <p>Array of tau coefficients.</p> required <code>e_field_theta_real</code> <code>ndarray</code> <p>Array of real parts of electric field theta component.</p> required <code>e_field_theta_imag</code> <code>ndarray</code> <p>Array of imaginary parts of electric field theta component.</p> required <code>e_field_phi_real</code> <code>ndarray</code> <p>Array of real parts of electric field phi component.</p> required <code>e_field_phi_imag</code> <code>ndarray</code> <p>Array of imaginary parts of electric field phi component.</p> required Source code in <code>yasfpy/computers/computer.py</code> <pre><code>@abstractmethod\n@staticmethod\ndef compute_electric_field_angle_components(\n    lmax: int,\n    particles_position: np.ndarray,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    k_medium: np.ndarray,\n    azimuthal_angles: np.ndarray,\n    e_r: np.ndarray,\n    pilm: np.ndarray,\n    taulm: np.ndarray,\n    e_field_theta_real: np.ndarray,\n    e_field_theta_imag: np.ndarray,\n    e_field_phi_real: np.ndarray,\n    e_field_phi_imag: np.ndarray,\n):\n    \"\"\"\n    Compute the electric field angle components on the GPU.\n\n    Args:\n        lmax (int): The maximum angular momentum quantum number.\n        particles_position (np.ndarray): Array of particle positions.\n        idx (np.ndarray): Array of indices.\n        sfc (np.ndarray): Array of scattering form factors.\n        k_medium (np.ndarray): Array of medium wavevectors.\n        azimuthal_angles (np.ndarray): Array of azimuthal angles.\n        e_r (np.ndarray): Array of radial unit vectors.\n        pilm (np.ndarray): Array of associated Legendre polynomials.\n        taulm (np.ndarray): Array of tau coefficients.\n        e_field_theta_real (np.ndarray): Array of real parts of electric field theta component.\n        e_field_theta_imag (np.ndarray): Array of imaginary parts of electric field theta component.\n        e_field_phi_real (np.ndarray): Array of real parts of electric field phi component.\n        e_field_phi_imag (np.ndarray): Array of imaginary parts of electric field phi component.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/computers/computer/#computers.computer.Computer.compute_polarization_components","title":"<code>compute_polarization_components</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Compute the polarization components using GPU acceleration.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_wavelengths</code> <code>int</code> <p>Number of wavelengths.</p> required <code>number_of_angles</code> <code>int</code> <p>Number of angles.</p> required <code>e_field_theta_real</code> <code>ndarray</code> <p>Real part of the electric field in the theta direction.</p> required <code>e_field_theta_imag</code> <code>ndarray</code> <p>Imaginary part of the electric field in the theta direction.</p> required <code>e_field_phi_real</code> <code>ndarray</code> <p>Real part of the electric field in the phi direction.</p> required <code>e_field_phi_imag</code> <code>ndarray</code> <p>Imaginary part of the electric field in the phi direction.</p> required <code>intensity</code> <code>ndarray</code> <p>Array to store the intensity component.</p> required <code>degree_of_polarization</code> <code>ndarray</code> <p>Array to store the degree of polarization component.</p> required <code>degree_of_linear_polarization</code> <code>ndarray</code> <p>Array to store the degree of linear polarization component.</p> required <code>degree_of_linear_polarization_q</code> <code>ndarray</code> <p>Array to store the degree of linear polarization (Q) component.</p> required <code>degree_of_linear_polarization_u</code> <code>ndarray</code> <p>Array to store the degree of linear polarization (U) component.</p> required <code>degree_of_circular_polarization</code> <code>ndarray</code> <p>Array to store the degree of circular polarization component.</p> required Source code in <code>yasfpy/computers/computer.py</code> <pre><code>@abstractmethod\n@staticmethod\ndef compute_polarization_components(\n    number_of_wavelengths: int,\n    number_of_angles: int,\n    e_field_theta_real: np.ndarray,\n    e_field_theta_imag: np.ndarray,\n    e_field_phi_real: np.ndarray,\n    e_field_phi_imag: np.ndarray,\n    intensity: np.ndarray,\n    degree_of_polarization: np.ndarray,\n    degree_of_linear_polarization: np.ndarray,\n    degree_of_linear_polarization_q: np.ndarray,\n    degree_of_linear_polarization_u: np.ndarray,\n    degree_of_circular_polarization: np.ndarray,\n):\n    \"\"\"\n    Compute the polarization components using GPU acceleration.\n\n    Args:\n        number_of_wavelengths (int): Number of wavelengths.\n        number_of_angles (int): Number of angles.\n        e_field_theta_real (np.ndarray): Real part of the electric field in the theta direction.\n        e_field_theta_imag (np.ndarray): Imaginary part of the electric field in the theta direction.\n        e_field_phi_real (np.ndarray): Real part of the electric field in the phi direction.\n        e_field_phi_imag (np.ndarray): Imaginary part of the electric field in the phi direction.\n        intensity (np.ndarray): Array to store the intensity component.\n        degree_of_polarization (np.ndarray): Array to store the degree of polarization component.\n        degree_of_linear_polarization (np.ndarray): Array to store the degree of linear polarization component.\n        degree_of_linear_polarization_q (np.ndarray): Array to store the degree of linear polarization (Q) component.\n        degree_of_linear_polarization_u (np.ndarray): Array to store the degree of linear polarization (U) component.\n        degree_of_circular_polarization (np.ndarray): Array to store the degree of circular polarization component.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/computers/computer/#computers.computer.Computer.compute_field","title":"<code>compute_field</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Compute the field on the GPU using CUDA.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>Maximum degree of the spherical harmonics.</p> required <code>idx</code> <code>ndarray</code> <p>Array of indices.</p> required <code>size_parameter</code> <code>ndarray</code> <p>Array of size parameters.</p> required <code>sph_h</code> <code>ndarray</code> <p>Array of spherical harmonics.</p> required <code>derivative</code> <code>ndarray</code> <p>Array of derivatives.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>Array of phi-dependent terms.</p> required <code>p_lm</code> <code>ndarray</code> <p>Array of Legendre polynomials.</p> required <code>pi_lm</code> <code>ndarray</code> <p>Array of pi-dependent terms.</p> required <code>tau_lm</code> <code>ndarray</code> <p>Array of tau-dependent terms.</p> required <code>e_r</code> <code>ndarray</code> <p>Array of r-dependent terms.</p> required <code>e_theta</code> <code>ndarray</code> <p>Array of theta-dependent terms.</p> required <code>e_phi</code> <code>ndarray</code> <p>Array of phi-dependent terms.</p> required <code>scattered_field_coefficients</code> <code>ndarray</code> <p>Array of scattered field coefficients.</p> required <code>field_real</code> <code>ndarray</code> <p>Array to store the real part of the field.</p> required <code>field_imag</code> <code>ndarray</code> <p>Array to store the imaginary part of the field.</p> required Source code in <code>yasfpy/computers/computer.py</code> <pre><code>@abstractmethod\n@staticmethod\ndef compute_field(\n    lmax: int,\n    idx: np.ndarray,\n    size_parameter: np.ndarray,\n    sph_h: np.ndarray,\n    derivative: np.ndarray,\n    e_j_dm_phi: np.ndarray,\n    p_lm: np.ndarray,\n    pi_lm: np.ndarray,\n    tau_lm: np.ndarray,\n    e_r: np.ndarray,\n    e_theta: np.ndarray,\n    e_phi: np.ndarray,\n    scattered_field_coefficients: np.ndarray,\n    field_real: np.ndarray,\n    field_imag: np.ndarray,\n):  # , initial_field_coefficients: np.ndarray, scatter_to_internal: np.ndarray):\n    \"\"\"\n    Compute the field on the GPU using CUDA.\n\n    Args:\n        lmax (int): Maximum degree of the spherical harmonics.\n        idx (np.ndarray): Array of indices.\n        size_parameter (np.ndarray): Array of size parameters.\n        sph_h (np.ndarray): Array of spherical harmonics.\n        derivative (np.ndarray): Array of derivatives.\n        e_j_dm_phi (np.ndarray): Array of phi-dependent terms.\n        p_lm (np.ndarray): Array of Legendre polynomials.\n        pi_lm (np.ndarray): Array of pi-dependent terms.\n        tau_lm (np.ndarray): Array of tau-dependent terms.\n        e_r (np.ndarray): Array of r-dependent terms.\n        e_theta (np.ndarray): Array of theta-dependent terms.\n        e_phi (np.ndarray): Array of phi-dependent terms.\n        scattered_field_coefficients (np.ndarray): Array of scattered field coefficients.\n        field_real (np.ndarray): Array to store the real part of the field.\n        field_imag (np.ndarray): Array to store the imaginary part of the field.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/computers/computer_cpu/","title":"Computer Cpu","text":""},{"location":"reference/computers/computer_cpu/#computers.computer_cpu.ComputerCPU","title":"<code>ComputerCPU</code>","text":"<p>               Bases: <code>Computer</code></p>"},{"location":"reference/computers/computer_cpu/#computers.computer_cpu.ComputerCPU.particle_interaction","title":"<code>particle_interaction</code>","text":"<p>Calculates the interaction between particles based on their properties and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum value of the angular momentum quantum number <code>l</code>. It determines the size of the arrays <code>plm</code> and <code>sph_h</code>.</p> required <code>particle_number</code> <code>int</code> <p>The number of particles in the system.</p> required <code>idx</code> <code>ndarray</code> <p>A numpy array of shape <code>(jmax, 5)</code>, where <code>jmax</code> is the total number of interactions between particles. Each row of <code>idx</code> represents an interaction and contains the following information: - s1 (int): The index of the first particle. - n1 (int): The index of the first particle's property. - tau1 (int): The tau value of the first particle. - l1 (int): The l value of the first particle. - m1 (int): The m value of the first particle.</p> required <code>x</code> <code>ndarray</code> <p>A numpy array representing the positions of the particles. It has shape <code>(particle_number,)</code> and contains the x-coordinates of the particles.</p> required <code>translation_table</code> <code>ndarray</code> <p>A 3-dimensional numpy array that stores the translation coefficients used in the calculation. It has shape <code>(n2, n1, p)</code> where <code>n2</code> and <code>n1</code> are the indices of the translation coefficients, and <code>p</code> is the maximum.</p> required <code>plm</code> <code>ndarray</code> <p>A numpy array representing the associated Legendre polynomials. It has shape <code>(pmax * (pmax + 1) // 2, s1max, s2max)</code>, where <code>pmax</code> is the maximum degree of the Legendre polynomials.</p> required <code>sph_h</code> <code>ndarray</code> <p>A numpy array representing the spherical harmonics. It has shape <code>(jmax, jmax, channels)</code>, where <code>jmax</code> is the maximum number of particles, <code>channels</code> is the number of channels.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>The parameter <code>e_j_dm_phi</code> is not defined in the code snippet you provided. Could you please provide the definition or explanation of what <code>e_j_dm_phi</code> represents?</p> required <p>Returns:</p> Name Type Description <code>wx</code> <code>ndarray</code> <p>The array <code>wx</code>, which represents the result of the particle interaction calculations.</p> Source code in <code>yasfpy/computers/computer_cpu.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True, cache=True)\ndef particle_interaction(\n    lmax: int,\n    particle_number: int,\n    idx: np.ndarray,\n    x: np.ndarray,\n    translation_table: np.ndarray,\n    plm: np.ndarray,\n    sph_h: np.ndarray,\n    e_j_dm_phi,\n):\n    \"\"\"Calculates the interaction between particles based on their properties and returns the result.\n\n    Args:\n        lmax (int): The maximum value of the angular momentum quantum number `l`. It determines the size of the arrays `plm` and `sph_h`.\n        particle_number (int): The number of particles in the system.\n        idx (np.ndarray): A numpy array of shape `(jmax, 5)`, where `jmax` is the total number of interactions between particles. Each row of `idx` represents an interaction and contains the following information:\n            - s1 (int): The index of the first particle.\n            - n1 (int): The index of the first particle's property.\n            - tau1 (int): The tau value of the first particle.\n            - l1 (int): The l value of the first particle.\n            - m1 (int): The m value of the first particle.\n        x (np.ndarray): A numpy array representing the positions of the particles. It has shape `(particle_number,)` and contains the x-coordinates of the particles.\n        translation_table (np.ndarray): A 3-dimensional numpy array that stores the translation coefficients used in the calculation. It has shape `(n2, n1, p)` where `n2` and `n1` are the indices of the translation coefficients, and `p` is the maximum.\n        plm (np.ndarray): A numpy array representing the associated Legendre polynomials. It has shape `(pmax * (pmax + 1) // 2, s1max, s2max)`, where `pmax` is the maximum degree of the Legendre polynomials.\n        sph_h (np.ndarray): A numpy array representing the spherical harmonics. It has shape `(jmax, jmax, channels)`, where `jmax` is the maximum number of particles, `channels` is the number of channels.\n        e_j_dm_phi (np.ndarray): The parameter `e_j_dm_phi` is not defined in the code snippet you provided. Could you please provide the definition or explanation of what `e_j_dm_phi` represents?\n\n    Returns:\n        wx (np.ndarray): The array `wx`, which represents the result of the particle interaction calculations.\n    \"\"\"\n    jmax = particle_number * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    wx = np.zeros(x.size * channels, dtype=complex128).reshape(\n        x.shape + (channels,)\n    )\n\n    for w_idx in prange(jmax * jmax * channels):\n        w = w_idx % channels\n        j_idx = w_idx // channels\n        j1 = j_idx // jmax\n        j2 = j_idx % jmax\n        s1, n1, tau1, l1, m1 = idx[j1, :]\n        s2, n2, tau2, l2, m2 = idx[j2, :]\n\n        if s1 == s2:\n            continue\n\n        delta_tau = np.absolute(tau1 - tau2)\n        delta_l = np.absolute(l1 - l2)\n        delta_m = np.absolute(m1 - m2)\n\n        val = 0j\n        for p in range(np.maximum(delta_m, delta_l + delta_tau), l1 + l2 + 1):\n            val += (\n                translation_table[n2, n1, p]\n                * plm[p * (p + 1) // 2 + delta_m, s1, s2]\n                * sph_h[p, s1, s2, w]\n            )\n        val *= e_j_dm_phi[m2 - m1 + 2 * lmax, s1, s2] * x[j2]\n\n        wx[j1, w] += val\n\n    return wx\n</code></pre>"},{"location":"reference/computers/computer_cpu/#computers.computer_cpu.ComputerCPU.compute_idx_lookups","title":"<code>compute_idx_lookups</code>","text":"<p>The function <code>compute_idx_lookups</code> generates an index lookup table for a given <code>lmax</code> and <code>particle_number</code> using parallel processing.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum value of the angular momentum quantum number <code>l</code>. It determines the range of values for <code>l</code> in the nested loop.</p> required <code>particle_number</code> <code>int</code> <p>The number of particles in the system.</p> required <p>Returns:</p> Name Type Description <code>idx</code> <code>ndarray</code> <p>A NumPy array <code>idx</code> which contains the computed index lookups.</p> Source code in <code>yasfpy/computers/computer_cpu.py</code> <pre><code>@jit(nopython=True, parallel=True, fastmath=True)\ndef compute_idx_lookups(lmax: int, particle_number: int):\n    \"\"\"\n    The function `compute_idx_lookups` generates an index lookup table for a given `lmax` and\n    `particle_number` using parallel processing.\n\n    Args:\n        lmax (int): The maximum value of the angular momentum quantum number `l`. It determines the range of values for `l` in the nested loop.\n        particle_number (int): The number of particles in the system.\n\n    Returns:\n        idx (np.ndarray): A NumPy array `idx` which contains the computed index lookups.\n    \"\"\"\n    nmax = 2 * lmax * (lmax + 2)\n    idx = np.zeros(nmax * particle_number * 5, dtype=int64).reshape(\n        (nmax * particle_number, 5)\n    )\n\n    for s in prange(particle_number):\n        for tau in range(1, 3):\n            for l in range(1, lmax + 1):\n                for m in range(-l, l + 1):\n                    n = (tau - 1) * lmax * (lmax + 2) + (l - 1) * (l + 1) + l + m\n                    i = n + s * nmax\n                    idx[i, 0] = s\n                    idx[i, 1] = n\n                    idx[i, 2] = tau\n                    idx[i, 3] = l\n                    idx[i, 4] = m\n\n    return idx\n</code></pre>"},{"location":"reference/computers/computer_cpu/#computers.computer_cpu.ComputerCPU.compute_scattering_cross_section","title":"<code>compute_scattering_cross_section</code>","text":"<p>Calculates the scattering cross section for a given set of input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum angular momentum quantum number. It determines the maximum value of <code>l</code> in the calculations.</p> required <code>particle_number</code> <code>int</code> <p>The number of particles in the system.</p> required <code>idx</code> <code>ndarray</code> <p>A numpy array of shape <code>(jmax, 5)</code>, where <code>jmax</code> is the total number of particle pairs. Each row of <code>idx</code> represents a particle pair and contains the following information: - s (int): The index of the first particle. - n (int): The index of the second particle. - tau (int): The tau value. - l (int): The l value. - m (int): The m value.</p> required <code>sfc</code> <code>ndarray</code> <p>A numpy array of shape <code>(s, n, channels)</code>, where:</p> required <code>translation_table</code> <code>ndarray</code> <p>A 3-dimensional numpy array that stores the translation coefficients used in the computation of the scattering cross section. It has shape <code>(n2, n1, p)</code> where <code>n2</code> and <code>n1</code> are the number of radial functions for the second and first particles, respectively, and <code>p</code> is the order of the Legendre polynomial.</p> required <code>plm</code> <code>ndarray</code> <p>A numpy array representing the associated Legendre polynomials. It has shape <code>(pmax * (pmax + 1) // 2, 2, 2)</code>, where <code>pmax</code> is the maximum value of <code>p</code> in the loop.</p> required <code>sph_h</code> <code>ndarray</code> <p>A numpy array of shape <code>(pmax, s1max, s2max, channels)</code>. It represents the scattering matrix elements for each combination of <code>s1</code>, <code>s2</code>, and <code>p</code>, where <code>p</code> is the order of the Legendre polynomial.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>A numpy array representing the scattering phase function. It has shape <code>(2*lmax+1, channels, channels)</code> and contains complex values. The indices <code>(j, s1, s2)</code> represent the angular momentum index <code>j</code>, and the spin indices <code>s1</code> and <code>s2</code>.</p> required <p>Returns:</p> Name Type Description <code>c_sca_complex</code> <code>ndarray</code> <p>The complex scattering cross section <code>c_sca_complex</code>.</p> Source code in <code>yasfpy/computers/computer_cpu.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True)\ndef compute_scattering_cross_section(\n    lmax: int,\n    particle_number: int,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    translation_table: np.ndarray,\n    plm: np.ndarray,\n    sph_h: np.ndarray,\n    e_j_dm_phi: np.ndarray,\n):\n    \"\"\"Calculates the scattering cross section for a given set of input parameters.\n\n    Args:\n        lmax (int): The maximum angular momentum quantum number. It determines the maximum value of `l` in the calculations.\n        particle_number (int): The number of particles in the system.\n        idx (np.ndarray): A numpy array of shape `(jmax, 5)`, where `jmax` is the total number of particle pairs. Each row of `idx` represents a particle pair and contains the following information:\n            - s (int): The index of the first particle.\n            - n (int): The index of the second particle.\n            - tau (int): The tau value.\n            - l (int): The l value.\n            - m (int): The m value.\n        sfc (np.ndarray): A numpy array of shape `(s, n, channels)`, where:\n        translation_table (np.ndarray): A 3-dimensional numpy array that stores the translation coefficients used in the computation of the scattering cross section. It has shape `(n2, n1, p)` where `n2` and `n1` are the number of radial functions for the second and first particles, respectively, and `p` is the order of the Legendre polynomial.\n        plm (np.ndarray): A numpy array representing the associated Legendre polynomials. It has shape `(pmax * (pmax + 1) // 2, 2, 2)`, where `pmax` is the maximum value of `p` in the loop.\n        sph_h (np.ndarray): A numpy array of shape `(pmax, s1max, s2max, channels)`. It represents the scattering matrix elements for each combination of `s1`, `s2`, and `p`, where `p` is the order of the Legendre polynomial.\n        e_j_dm_phi (np.ndarray): A numpy array representing the scattering phase function. It has shape `(2*lmax+1, channels, channels)` and contains complex values. The indices `(j, s1, s2)` represent the angular momentum index `j`, and the spin indices `s1` and `s2`.\n\n    Returns:\n        c_sca_complex (np.ndarray): The complex scattering cross section `c_sca_complex`.\n    \"\"\"\n    jmax = particle_number * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    c_sca_complex = np.zeros(channels, dtype=complex128)\n\n    for j_idx in prange(jmax * jmax):\n        j1 = j_idx // jmax\n        j2 = j_idx % jmax\n        s1, n1, _, _, m1 = idx[j1, :]\n        s2, n2, _, _, m2 = idx[j2, :]\n\n        delta_m = np.absolute(m1 - m2)\n\n        p_dependent = np.zeros(channels, dtype=complex128)\n        for p in range(delta_m, 2 * lmax + 1):\n            p_dependent += (\n                translation_table[n2, n1, p]\n                * plm[p * (p + 1) // 2 + delta_m, s1, s2]\n                * sph_h[p, s1, s2, :]\n            )\n        p_dependent *= (\n            np.conj(sfc[s1, n1, :])\n            * e_j_dm_phi[m2 - m1 + 2 * lmax, s1, s2]\n            * sfc[s2, n2, :]\n        )\n\n        c_sca_complex += p_dependent\n\n    return c_sca_complex\n</code></pre>"},{"location":"reference/computers/computer_cpu/#computers.computer_cpu.ComputerCPU.compute_radial_independent_scattered_field_legacy","title":"<code>compute_radial_independent_scattered_field_legacy</code>","text":"<p>Calculates the scattered field for a given set of parameters and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum value of the angular momentum quantum number <code>l</code>. It determines the maximum order of the spherical harmonics used in the computation.</p> required <code>particles_position</code> <code>ndarray</code> <p>An array representing the positions of particles. It has shape <code>(num_particles, 3)</code>, where <code>num_particles</code> is the number of particles and each row represents the x, y, and z coordinates of a particle.</p> required <code>idx</code> <code>ndarray</code> <p>An array containing the indices of the particles. It has shape <code>(jmax, 5)</code> where <code>jmax</code> is the total number of particles. Each row of <code>idx</code> represents a particle and contains the following information:</p> required <code>sfc</code> <code>ndarray</code> <p>A 3-dimensional array representing the scattering form factors. It has dimensions <code>(s, n, w)</code>, where:</p> required <code>k_medium</code> <code>ndarray</code> <p>An array representing the wave number in the medium. It is used in the calculation of the scattered field.</p> required <code>azimuthal_angles</code> <code>ndarray</code> <p>An array of azimuthal angles, representing the angles at which the scattered field is computed.</p> required <code>e_r</code> <code>ndarray</code> <p>An array representing the radial component of the electric field. It has shape <code>(azimuthal_angles.size, 3)</code>, where <code>azimuthal_angles.size</code> is the number of azimuthal angles and 3 represents the three Cartesian components of the electric field.</p> required <code>e_phi</code> <code>ndarray</code> <p>An array representing the electric field component in the azimuthal direction. It has a shape of <code>(azimuthal_angles.size, 3)</code>, where <code>azimuthal_angles.size</code> is the number of azimuthal angles and <code>3</code> represents the three components of the electric field.</p> required <code>e_theta</code> <code>ndarray</code> <p>An array representing the electric field component in the theta direction. It has a shape of <code>(azimuthal_angles.size, 3)</code>, where <code>azimuthal_angles.size</code> is the number of azimuthal angles and <code>3</code> represents the three components of the electric field.</p> required <code>pilm</code> <code>ndarray</code> <p>An array representing the matrix of spherical harmonics coefficients. It has a shape of <code>(lmax+1, lmax+1, azimuthal_angles.size)</code>. Each element <code>pilm[l, m, a]</code> represents the coefficient of the spherical harmonics for a given <code>l</code>, <code>m</code>, and azimuthal angle <code>a</code>.</p> required <code>taulm</code> <code>ndarray</code> <p>An array representing the scattering coefficients for each combination of <code>l</code>, <code>m</code>, and azimuthal angle <code>a</code>. It has a shape of <code>(lmax+1, lmax+1, azimuthal_angles.size)</code>. The values in <code>taulm</code> represent the scattering coefficients.</p> required <p>Returns:</p> Name Type Description <code>e_1_sca</code> <code>ndarray</code> <p>An array of complex numbers representing the scattered field.</p> Source code in <code>yasfpy/computers/computer_cpu.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True)\ndef compute_radial_independent_scattered_field_legacy(\n    lmax: int,\n    particles_position: np.ndarray,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    k_medium: np.ndarray,\n    azimuthal_angles: np.ndarray,\n    e_r: np.ndarray,\n    e_phi: np.ndarray,\n    e_theta: np.ndarray,\n    pilm: np.ndarray,\n    taulm: np.ndarray,\n):\n    \"\"\"Calculates the scattered field for a given set of parameters and returns the result.\n\n    Args:\n        lmax (int): The maximum value of the angular momentum quantum number `l`. It determines the maximum order of the spherical harmonics used in the computation.\n        particles_position (np.ndarray): An array representing the positions of particles. It has shape `(num_particles, 3)`, where `num_particles` is the number of particles and each row represents the x, y, and z coordinates of a particle.\n        idx (np.ndarray): An array containing the indices of the particles. It has shape `(jmax, 5)` where `jmax` is the total number of particles. Each row of `idx` represents a particle and contains the following information:\n        sfc (np.ndarray): A 3-dimensional array representing the scattering form factors. It has dimensions `(s, n, w)`, where:\n        k_medium (np.ndarray): An array representing the wave number in the medium. It is used in the calculation of the scattered field.\n        azimuthal_angles (np.ndarray): An array of azimuthal angles, representing the angles at which the scattered field is computed.\n        e_r (np.ndarray): An array representing the radial component of the electric field. It has shape `(azimuthal_angles.size, 3)`, where `azimuthal_angles.size` is the number of azimuthal angles and 3 represents the three Cartesian components of the electric field.\n        e_phi (np.ndarray): An array representing the electric field component in the azimuthal direction. It has a shape of `(azimuthal_angles.size, 3)`, where `azimuthal_angles.size` is the number of azimuthal angles and `3` represents the three components of the electric field.\n        e_theta (np.ndarray): An array representing the electric field component in the theta direction. It has a shape of `(azimuthal_angles.size, 3)`, where `azimuthal_angles.size` is the number of azimuthal angles and `3` represents the three components of the electric field.\n        pilm (np.ndarray): An array representing the matrix of spherical harmonics coefficients. It has a shape of `(lmax+1, lmax+1, azimuthal_angles.size)`. Each element `pilm[l, m, a]` represents the coefficient of the spherical harmonics for a given `l`, `m`, and azimuthal angle `a`.\n        taulm (np.ndarray): An array representing the scattering coefficients for each combination of `l`, `m`, and azimuthal angle `a`. It has a shape of `(lmax+1, lmax+1, azimuthal_angles.size)`. The values in `taulm` represent the scattering coefficients.\n\n    Returns:\n        e_1_sca (np.ndarray): An array of complex numbers representing the scattered field.\n\n    \"\"\"\n    e_1_sca = np.zeros(\n        azimuthal_angles.size * 3 * k_medium.size, dtype=complex128\n    ).reshape((azimuthal_angles.size, 3, k_medium.size))\n    jmax = particles_position.shape[0] * 2 * lmax * (lmax + 2)\n\n    for global_idx in prange(jmax * azimuthal_angles.size * k_medium.size):\n        w_idx = global_idx % (jmax * k_medium.size)\n        g_idx = global_idx // (jmax * k_medium.size)\n\n        a = g_idx\n\n        w = w_idx % k_medium.size\n        j_idx = w_idx // k_medium.size\n        s, n, tau, l, m = idx[j_idx, :]\n\n        t = (\n            np.power(1j, tau - l - 2)\n            * sfc[s, n, w]\n            / np.sqrt(2 * l * (l + 1))\n            * np.exp(\n                1j\n                * (\n                    m * azimuthal_angles[a]\n                    - k_medium[w] * np.sum(particles_position[s, :] * e_r[a, :])\n                )\n            )\n        )\n\n        if tau == 1:\n            e_1_sca[a, :, w] += t * (\n                e_theta[a, :] * pilm[l, np.abs(m), a] * 1j * m\n                - e_phi[a, :] * taulm[l, np.abs(m), a]\n            )\n        else:\n            e_1_sca[a, :, w] += t * (\n                e_phi[a, :] * pilm[l, np.abs(m), a] * 1j * m\n                + e_theta[a, :] * taulm[l, np.abs(m), a]\n            )\n\n    return e_1_sca\n</code></pre>"},{"location":"reference/computers/computer_cpu/#computers.computer_cpu.ComputerCPU.compute_electric_field_angle_components","title":"<code>compute_electric_field_angle_components</code>","text":"<p>Calculates the electric field components in the theta and phi directions for given input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum value of the angular momentum quantum number <code>l</code>. It determines the maximum value of <code>l</code> for which the calculations will be performed.</p> required <code>particles_position</code> <code>ndarray</code> <p>The positions of particles. It has shape <code>(num_particles, 3)</code>, where <code>num_particles</code> is the number of particles and each particle has 3 coordinates (x, y, z).</p> required <code>idx</code> <code>ndarray</code> <p>A numpy array of shape <code>(jmax, 5)</code>, where <code>jmax</code> is the total number of particles multiplied by <code>2 * lmax * (lmax + 2)</code>. Each row of <code>idx</code> represents the indices <code>(s, n, tau, l, m)</code>.</p> required <code>sfc</code> <code>ndarray</code> <p>A 3-dimensional numpy array representing the scattering form factors. It has dimensions <code>(s, n, w)</code>.</p> required <code>k_medium</code> <code>ndarray</code> <p>The wave vector in the medium. It is a numpy array that contains the wave vector values for different frequencies or wavelengths.</p> required <code>azimuthal_angles</code> <code>ndarray</code> <p>An array representing the azimuthal angles at which the electric field components are computed. It specifies the angles at which the electric field is measured in the azimuthal direction.</p> required <code>e_r</code> <code>ndarray</code> <p>The unit vector pointing in the direction of the electric field. It is a numpy array of shape <code>(azimuthal_angles.size, 3)</code>, where each row corresponds to a different azimuthal angle and the three columns represent the x, y, and z components.</p> required <code>pilm</code> <code>ndarray</code> <p>A 3-dimensional numpy array of shape <code>(lmax+1, lmax+1, azimuthal_angles.size)</code>. It represents the matrix elements of the electric field expansion coefficients for the theta component. The indices <code>(l, m, a)</code> correspond to the spherical harmonics.</p> required <code>taulm</code> <code>ndarray</code> <p>A numpy array that represents the angular momentum coupling coefficients. It has a shape of <code>(lmax+1, lmax+1, azimuthal_angles.size)</code>. The first dimension represents the value of <code>l</code>, the second dimension represents the value of <code>m</code>, and the third dimension represents the azimuthal angle.</p> required <p>Returns:</p> Name Type Description <code>e_field_theta</code> <code>ndarray</code> <p>The electric field component in the theta direction.</p> <code>e_field_phi</code> <code>ndarray</code> <p>The electric field component in the phi direction.</p> Source code in <code>yasfpy/computers/computer_cpu.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True)\ndef compute_electric_field_angle_components(\n    lmax: int,\n    particles_position: np.ndarray,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    k_medium: np.ndarray,\n    azimuthal_angles: np.ndarray,\n    e_r: np.ndarray,\n    pilm: np.ndarray,\n    taulm: np.ndarray,\n):\n    \"\"\"Calculates the electric field components in the theta and phi directions for given input parameters.\n\n    Args:\n        lmax (int): The maximum value of the angular momentum quantum number `l`. It determines the maximum value of `l` for which the calculations will be performed.\n        particles_position (np.ndarray): The positions of particles. It has shape `(num_particles, 3)`, where `num_particles` is the number of particles and each particle has 3 coordinates (x, y, z).\n        idx (np.ndarray): A numpy array of shape `(jmax, 5)`, where `jmax` is the total number of particles multiplied by `2 * lmax * (lmax + 2)`. Each row of `idx` represents the indices `(s, n, tau, l, m)`.\n        sfc (np.ndarray): A 3-dimensional numpy array representing the scattering form factors. It has dimensions `(s, n, w)`.\n        k_medium (np.ndarray): The wave vector in the medium. It is a numpy array that contains the wave vector values for different frequencies or wavelengths.\n        azimuthal_angles (np.ndarray): An array representing the azimuthal angles at which the electric field components are computed. It specifies the angles at which the electric field is measured in the azimuthal direction.\n        e_r (np.ndarray): The unit vector pointing in the direction of the electric field. It is a numpy array of shape `(azimuthal_angles.size, 3)`, where each row corresponds to a different azimuthal angle and the three columns represent the x, y, and z components.\n        pilm (np.ndarray): A 3-dimensional numpy array of shape `(lmax+1, lmax+1, azimuthal_angles.size)`. It represents the matrix elements of the electric field expansion coefficients for the theta component. The indices `(l, m, a)` correspond to the spherical harmonics.\n        taulm (np.ndarray): A numpy array that represents the angular momentum coupling coefficients. It has a shape of `(lmax+1, lmax+1, azimuthal_angles.size)`. The first dimension represents the value of `l`, the second dimension represents the value of `m`, and the third dimension represents the azimuthal angle.\n\n    Returns:\n        e_field_theta (np.ndarray): The electric field component in the theta direction.\n        e_field_phi (np.ndarray): The electric field component in the phi direction.\n    \"\"\"\n    e_field_theta = np.zeros(\n        azimuthal_angles.size * k_medium.size, dtype=complex128\n    ).reshape((azimuthal_angles.size, k_medium.size))\n    e_field_phi = np.zeros_like(e_field_theta)\n\n    jmax = particles_position.shape[0] * 2 * lmax * (lmax + 2)\n\n    for global_idx in prange(jmax * azimuthal_angles.size * k_medium.size):\n        w_idx = global_idx % (jmax * k_medium.size)\n        g_idx = global_idx // (jmax * k_medium.size)\n\n        a = g_idx\n\n        w = w_idx % k_medium.size\n        j_idx = w_idx // k_medium.size\n        s, n, tau, l, m = idx[j_idx, :]\n\n        t = (\n            np.power(1j, tau - l - 2)\n            * sfc[s, n, w]\n            / np.sqrt(2 * l * (l + 1))\n            * np.exp(\n                1j\n                * (\n                    m * azimuthal_angles[a]\n                    - k_medium[w] * np.sum(particles_position[s, :] * e_r[a, :])\n                )\n            )\n        )\n\n        if tau == 1:\n            e_field_theta[a, w] += t * pilm[l, np.abs(m), a] * 1j * m\n            e_field_phi[a, w] -= t * taulm[l, np.abs(m), a]\n        else:\n            e_field_theta[a, w] += t * taulm[l, np.abs(m), a]\n            e_field_phi[a, w] += t * pilm[l, np.abs(m), a] * 1j * m\n\n    return e_field_theta, e_field_phi\n</code></pre>"},{"location":"reference/computers/computer_cpu/#computers.computer_cpu.ComputerCPU.compute_polarization_components","title":"<code>compute_polarization_components</code>","text":"<p>Compute the polarization components of electromagnetic fields.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_wavelengths</code> <code>int</code> <p>The number of wavelengths.</p> required <code>number_of_angles</code> <code>int</code> <p>The number of angles.</p> required <code>e_field_theta</code> <code>ndarray</code> <p>The electric field component in the theta direction.</p> required <code>e_field_phi</code> <code>ndarray</code> <p>The electric field component in the phi direction.</p> required <p>Returns:</p> Name Type Description <code>degree_of_polarization_tuple</code> <code>tuple</code> <p>A tuple containing the following polarization components: - I (np.ndarray): The total intensity. - degree_of_polarization (np.ndarray): The degree of polarization. - degree_of_linear_polarization (np.ndarray): The degree of linear polarization. - degree_of_linear_polarization_q (np.ndarray): The degree of linear polarization in the Q direction. - degree_of_linear_polarization_u (np.ndarray): The degree of linear polarization in the U direction. - degree_of_circular_polarization (np.ndarray): The degree of circular polarization.</p> Source code in <code>yasfpy/computers/computer_cpu.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True)\ndef compute_polarization_components(\n    number_of_wavelengths: int,\n    number_of_angles: int,\n    e_field_theta: np.ndarray,\n    e_field_phi: np.ndarray,\n):\n    \"\"\"\n    Compute the polarization components of electromagnetic fields.\n\n    Args:\n        number_of_wavelengths (int): The number of wavelengths.\n        number_of_angles (int): The number of angles.\n        e_field_theta (np.ndarray): The electric field component in the theta direction.\n        e_field_phi (np.ndarray): The electric field component in the phi direction.\n\n    Returns:\n        degree_of_polarization_tuple (tuple): A tuple containing the following polarization components:\n            - I (np.ndarray): The total intensity.\n            - degree_of_polarization (np.ndarray): The degree of polarization.\n            - degree_of_linear_polarization (np.ndarray): The degree of linear polarization.\n            - degree_of_linear_polarization_q (np.ndarray): The degree of linear polarization in the Q direction.\n            - degree_of_linear_polarization_u (np.ndarray): The degree of linear polarization in the U direction.\n            - degree_of_circular_polarization (np.ndarray): The degree of circular polarization.\n    \"\"\"\n    # Stokes components\n    # S = np.zeros(4 * number_of_angles * number_of_wavelengths, dtype=complex128).reshape((4, number_of_angles, number_of_wavelengths))\n    I = np.zeros(number_of_angles * number_of_wavelengths, dtype=float64).reshape(\n        (number_of_angles, number_of_wavelengths)\n    )\n    Q = np.zeros_like(I)\n    U = np.zeros_like(I)\n    V = np.zeros_like(I)\n\n    for global_idx in prange(number_of_angles * number_of_wavelengths):\n        w_idx = global_idx % number_of_wavelengths\n        a_idx = global_idx // number_of_wavelengths\n\n        e_field_theta_abs = (\n            e_field_theta[a_idx, w_idx].real ** 2\n            + e_field_theta[a_idx, w_idx].imag ** 2\n        )\n        e_field_phi_abs = (\n            e_field_phi[a_idx, w_idx].real ** 2\n            + e_field_phi[a_idx, w_idx].imag ** 2\n        )\n        e_field_angle_interaction = (\n            e_field_theta[a_idx, w_idx] * e_field_phi[a_idx, w_idx].conjugate()\n        )\n\n        I[a_idx, w_idx] = e_field_theta_abs + e_field_phi_abs\n        Q[a_idx, w_idx] = e_field_theta_abs - e_field_phi_abs\n        U[a_idx, w_idx] = -2 * e_field_angle_interaction.real\n        V[a_idx, w_idx] = 2 * e_field_angle_interaction.imag\n\n    degree_of_polarization = np.sqrt(Q**2 + U**2 + V**2) / I\n    degree_of_linear_polarization = np.sqrt(Q**2 + U**2) / I\n    degree_of_linear_polarization_q = -Q / I\n    degree_of_linear_polarization_u = U / I\n    degree_of_circular_polarization = V / I\n\n    return (\n        I,\n        degree_of_polarization,\n        degree_of_linear_polarization,\n        degree_of_linear_polarization_q,\n        degree_of_linear_polarization_u,\n        degree_of_circular_polarization,\n    )\n</code></pre>"},{"location":"reference/computers/computer_cpu/#computers.computer_cpu.ComputerCPU.compute_radial_independent_scattered_field","title":"<code>compute_radial_independent_scattered_field</code>","text":"<p>Compute the radial independent scattered field.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_wavelengths</code> <code>int</code> <p>The number of wavelengths.</p> required <code>number_of_angles</code> <code>int</code> <p>The number of angles.</p> required <code>e_phi</code> <code>ndarray</code> <p>The electric field in the phi direction.</p> required <code>e_theta</code> <code>ndarray</code> <p>The electric field in the theta direction.</p> required <code>e_field_theta</code> <code>ndarray</code> <p>The electric field theta component.</p> required <code>e_field_phi</code> <code>ndarray</code> <p>The electric field phi component.</p> required <p>Returns:</p> Name Type Description <code>e_1_sca</code> <code>ndarray</code> <p>The computed radial independent scattered field.</p> Source code in <code>yasfpy/computers/computer_cpu.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True)\ndef compute_radial_independent_scattered_field(\n    number_of_wavelengths: int,\n    number_of_angles: int,\n    e_phi: np.ndarray,\n    e_theta: np.ndarray,\n    e_field_theta: np.ndarray,\n    e_field_phi: np.ndarray,\n):\n    \"\"\"\n    Compute the radial independent scattered field.\n\n    Args:\n        number_of_wavelengths (int): The number of wavelengths.\n        number_of_angles (int): The number of angles.\n        e_phi (np.ndarray): The electric field in the phi direction.\n        e_theta (np.ndarray): The electric field in the theta direction.\n        e_field_theta (np.ndarray): The electric field theta component.\n        e_field_phi (np.ndarray): The electric field phi component.\n\n    Returns:\n        e_1_sca (np.ndarray): The computed radial independent scattered field.\n    \"\"\"\n    e_1_sca = np.zeros(\n        number_of_angles * 3 * number_of_wavelengths, dtype=complex128\n    ).reshape((number_of_angles, 3, number_of_wavelengths))\n\n    for global_idx in prange(number_of_angles * number_of_wavelengths):\n        w = global_idx % number_of_wavelengths\n        a = global_idx // number_of_wavelengths\n\n        e_1_sca[a, :, w] = (\n            e_field_theta[a, w] * e_theta[a, :] + e_field_phi[a, w] * e_phi[a, :]\n        )\n\n    return e_1_sca\n</code></pre>"},{"location":"reference/computers/computer_cpu/#computers.computer_cpu.ComputerCPU.compute_lookup_tables","title":"<code>compute_lookup_tables</code>","text":"<p>Compute lookup tables for spherical computations.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics.</p> required <code>size_parameter</code> <code>ndarray</code> <p>Array of size parameters.</p> required <code>phi</code> <code>ndarray</code> <p>Array of azimuthal angles.</p> required <code>cosine_theta</code> <code>ndarray</code> <p>Array of cosine of polar angles.</p> required <p>Returns:</p> Name Type Description <code>spherical_bessel</code> <code>ndarray</code> <p>Array of spherical Bessel functions.</p> <code>spherical_hankel</code> <code>ndarray</code> <p>Array of spherical Hankel functions.</p> <code>e_j_dm_phi</code> <code>ndarray</code> <p>Array of exponential terms.</p> <code>p_lm</code> <code>ndarray</code> <p>Array of associated Legendre polynomials.</p> Source code in <code>yasfpy/computers/computer_cpu.py</code> <pre><code>@jit(parallel=True, forceobj=True)\ndef compute_lookup_tables(\n    lmax: int, size_parameter: np.ndarray, phi: np.ndarray, cosine_theta: np.ndarray\n):\n    \"\"\"\n    Compute lookup tables for spherical computations.\n\n    Args:\n        lmax (int): The maximum degree of the spherical harmonics.\n        size_parameter (np.ndarray): Array of size parameters.\n        phi (np.ndarray): Array of azimuthal angles.\n        cosine_theta (np.ndarray): Array of cosine of polar angles.\n\n    Returns:\n        spherical_bessel (np.ndarray): Array of spherical Bessel functions.\n        spherical_hankel (np.ndarray): Array of spherical Hankel functions.\n        e_j_dm_phi (np.ndarray): Array of exponential terms.\n        p_lm (np.ndarray): Array of associated Legendre polynomials.\n    \"\"\"\n    spherical_hankel = np.zeros(\n        (2 * lmax + 1) * np.prod(size_parameter.shape), dtype=complex\n    ).reshape((2 * lmax + 1,) + size_parameter.shape)\n    spherical_bessel = np.zeros_like(spherical_hankel)\n    e_j_dm_phi = np.zeros(\n        (4 * lmax + 1) * np.prod(size_parameter.shape[:2]), dtype=complex\n    ).reshape((4 * lmax + 1,) + size_parameter.shape[:2])\n    p_lm = np.zeros(\n        (lmax + 1) * (2 * lmax + 1) * np.prod(size_parameter.shape[:2])\n    ).reshape(((lmax + 1) * (2 * lmax + 1),) + size_parameter.shape[:2])\n\n    for p in prange(2 * lmax + 1):\n        spherical_hankel[p, :, :, :] = np.sqrt(\n            np.divide(\n                np.pi / 2,\n                size_parameter,\n                out=np.zeros_like(size_parameter),\n                where=size_parameter != 0,\n            )\n        ) * hankel1(p + 1 / 2, size_parameter)\n        spherical_bessel[p, :, :, :] = spherical_jn(p, size_parameter)\n        e_j_dm_phi[p, :, :] = np.exp(1j * (p - 2 * lmax) * phi)\n        e_j_dm_phi[p + 2 * lmax, :, :] = np.exp(1j * p * phi)\n        for absdm in range(p + 1):\n            cml = np.sqrt(\n                (2 * p + 1) / 2 / np.prod(np.arange(p - absdm + 1, p + absdm + 1))\n            )\n            p_lm[p * (p + 1) // 2 + absdm, :, :] = (\n                cml * np.power(-1.0, absdm) * lpmv(absdm, p, cosine_theta)\n            )\n\n    return spherical_bessel, spherical_hankel, e_j_dm_phi, p_lm\n</code></pre>"},{"location":"reference/computers/computer_cpu/#computers.computer_cpu.ComputerCPU.compute_field","title":"<code>compute_field</code>","text":"<p>Compute the field using the given parameters and coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics.</p> required <code>idx</code> <code>ndarray</code> <p>The index array containing the values of s, n, tau, l, and m.</p> required <code>size_parameter</code> <code>ndarray</code> <p>The size parameter array.</p> required <code>sph_h</code> <code>ndarray</code> <p>The spherical harmonics array.</p> required <code>derivative</code> <code>ndarray</code> <p>The derivative array.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>The e_j_dm_phi array.</p> required <code>p_lm</code> <code>ndarray</code> <p>The p_lm array.</p> required <code>pi_lm</code> <code>ndarray</code> <p>The pi_lm array.</p> required <code>tau_lm</code> <code>ndarray</code> <p>The tau_lm array.</p> required <code>e_r</code> <code>ndarray</code> <p>The e_r array.</p> required <code>e_theta</code> <code>ndarray</code> <p>The e_theta array.</p> required <code>e_phi</code> <code>ndarray</code> <p>The e_phi array.</p> required <code>scattered_field_coefficients</code> <code>ndarray</code> <p>The scattered field coefficients array. Defaults to None.</p> <code>None</code> <code>initial_field_coefficients</code> <code>ndarray</code> <p>The initial field coefficients array. Defaults to None.</p> <code>None</code> <code>scatter_to_internal</code> <code>ndarray</code> <p>The scatter to internal array. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>field</code> <code>ndarray</code> <p>The computed field array.</p> Source code in <code>yasfpy/computers/computer_cpu.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True, cache=True)\ndef compute_field(\n    lmax: int,\n    idx: np.ndarray,\n    size_parameter: np.ndarray,\n    sph_h: np.ndarray,\n    derivative: np.ndarray,\n    e_j_dm_phi: np.ndarray,\n    p_lm: np.ndarray,\n    pi_lm: np.ndarray,\n    tau_lm: np.ndarray,\n    e_r: np.ndarray,\n    e_theta: np.ndarray,\n    e_phi: np.ndarray,\n    scattered_field_coefficients: np.ndarray = None,\n    initial_field_coefficients: np.ndarray = None,\n    scatter_to_internal: np.ndarray = None,\n):\n    \"\"\"\n    Compute the field using the given parameters and coefficients.\n\n    Parameters:\n        lmax (int): The maximum degree of the spherical harmonics.\n        idx (np.ndarray): The index array containing the values of s, n, tau, l, and m.\n        size_parameter (np.ndarray): The size parameter array.\n        sph_h (np.ndarray): The spherical harmonics array.\n        derivative (np.ndarray): The derivative array.\n        e_j_dm_phi (np.ndarray): The e_j_dm_phi array.\n        p_lm (np.ndarray): The p_lm array.\n        pi_lm (np.ndarray): The pi_lm array.\n        tau_lm (np.ndarray): The tau_lm array.\n        e_r (np.ndarray): The e_r array.\n        e_theta (np.ndarray): The e_theta array.\n        e_phi (np.ndarray): The e_phi array.\n        scattered_field_coefficients (np.ndarray, optional): The scattered field coefficients array. Defaults to None.\n        initial_field_coefficients (np.ndarray, optional): The initial field coefficients array. Defaults to None.\n        scatter_to_internal (np.ndarray, optional): The scatter to internal array. Defaults to None.\n\n    Returns:\n        field (np.ndarray): The computed field array.\n    \"\"\"\n    jmax = sph_h.shape[1] * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    field = np.zeros(channels * sph_h.shape[2] * 3, dtype=complex128).reshape(\n        (channels, sph_h.shape[2], 3)\n    )\n\n    if (scattered_field_coefficients is None) and (\n        initial_field_coefficients is None\n    ):\n        print(\n            \"At least one, scattered field or initial field coefficients, need to be given.\"\n        )\n        print(\"Returning a zero array\")\n        return field\n\n    for w_idx in prange(2 * lmax * (lmax + 2) * np.prod(np.array(sph_h.shape[1:]))):\n        w = w_idx % channels\n        j_idx = w_idx // channels\n        sampling_idx = j_idx // jmax\n        j_idx = j_idx % jmax\n        s, n, tau, l, m = idx[j_idx, :]\n\n        invariant = (\n            1 / np.sqrt(2 * (l + 1) * l) * e_j_dm_phi[m + 2 * lmax, s, sampling_idx]\n        )\n        # Calculate M\n        if tau == 1:\n            c_term_1 = (\n                1j\n                * m\n                * pi_lm[l, np.abs(m), s, sampling_idx]\n                * e_theta[s, sampling_idx, :]\n            )\n            c_term_2 = (\n                tau_lm[l, np.abs(m), s, sampling_idx] * e_phi[s, sampling_idx, :]\n            )\n            c_term = sph_h[l, s, sampling_idx, w] * (c_term_1 - c_term_2)\n\n            field[w, sampling_idx, :] += (\n                scattered_field_coefficients[s, n, w] * invariant * c_term\n            )\n        # Calculate N\n        else:\n            p_term = (\n                l\n                * (l + 1)\n                / size_parameter[s, sampling_idx, w]\n                * sph_h[l, s, sampling_idx, w]\n                * p_lm[l, np.abs(m), s, sampling_idx]\n                * e_r[s, sampling_idx, :]\n            )\n            #   p_term = l * (l + 1) / size_parameter[s, sampling_idx, w]\n            #   p_term *= sph_h[l, s, sampling_idx, w]\n            #   p_term *= p_lm[l, np.abs(m), s, sampling_idx]\n            #   p_term *= e_r[s, sampling_idx, :]\n\n            b_term_1 = (\n                derivative[l, s, sampling_idx, w]\n                / size_parameter[s, sampling_idx, w]\n            )\n            b_term_2 = (\n                tau_lm[l, np.abs(m), s, sampling_idx] * e_theta[s, sampling_idx, :]\n            )\n            b_term_3 = (\n                1j\n                * m\n                * pi_lm[l, np.abs(m), s, sampling_idx]\n                * e_phi[s, sampling_idx, :]\n            )\n            b_term = b_term_1 * (b_term_2 + b_term_3)\n\n            field[w, sampling_idx, :] += (\n                scattered_field_coefficients[s, n, w]\n                * invariant\n                * (p_term + b_term)\n            )\n\n    return field\n</code></pre>"},{"location":"reference/computers/computer_cuda/","title":"Computer Cuda","text":""},{"location":"reference/computers/computer_cuda/#computers.computer_cuda.ComputerCUDA","title":"<code>ComputerCUDA</code>","text":"<p>               Bases: <code>Computer</code></p>"},{"location":"reference/computers/computer_cuda/#computers.computer_cuda.ComputerCUDA.particle_interaction","title":"<code>particle_interaction</code>","text":"<p>Perform particle interaction calculations on the GPU.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>Maximum angular momentum quantum number.</p> required <code>particle_number</code> <code>int</code> <p>Number of particles.</p> required <code>idx</code> <code>ndarray</code> <p>Array containing particle indices.</p> required <code>x</code> <code>ndarray</code> <p>Array of particle positions.</p> required <code>wx_real</code> <code>ndarray</code> <p>Array to store the real part of the result.</p> required <code>wx_imag</code> <code>ndarray</code> <p>Array to store the imaginary part of the result.</p> required <code>translation_table</code> <code>ndarray</code> <p>Array containing translation table.</p> required <code>plm</code> <code>ndarray</code> <p>Array containing associated Legendre polynomials.</p> required <code>sph_h</code> <code>ndarray</code> <p>Array containing spherical harmonics.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>Additional parameter for the calculation.</p> required Todo <p>Implement data batching for GPUs with smaller memory</p> Source code in <code>yasfpy/computers/computer_cuda.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef particle_interaction(\n    lmax: int,\n    particle_number: int,\n    idx: np.ndarray,\n    x: np.ndarray,\n    wx_real: np.ndarray,\n    wx_imag: np.ndarray,\n    translation_table: np.ndarray,\n    plm: np.ndarray,\n    sph_h: np.ndarray,\n    e_j_dm_phi,\n):\n    \"\"\"\n    Perform particle interaction calculations on the GPU.\n\n    Args:\n        lmax (int): Maximum angular momentum quantum number.\n        particle_number (int): Number of particles.\n        idx (np.ndarray): Array containing particle indices.\n        x (np.ndarray): Array of particle positions.\n        wx_real (np.ndarray): Array to store the real part of the result.\n        wx_imag (np.ndarray): Array to store the imaginary part of the result.\n        translation_table (np.ndarray): Array containing translation table.\n        plm (np.ndarray): Array containing associated Legendre polynomials.\n        sph_h (np.ndarray): Array containing spherical harmonics.\n        e_j_dm_phi (np.ndarray): Additional parameter for the calculation.\n\n    Todo:\n        Implement data batching for GPUs with smaller memory\n    \"\"\"\n    j1, j2, w = cuda.grid(3)\n\n    jmax = particle_number * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    if (j1 &gt;= jmax) or (j2 &gt;= jmax) or (w &gt;= channels):\n        return\n\n    s1, n1, tau1, l1, m1 = idx[j1, :]\n    s2, n2, tau2, l2, m2 = idx[j2, :]\n\n    if s1 == s2:\n        return\n\n    delta_tau = abs(tau1 - tau2)\n    delta_l = abs(l1 - l2)\n    delta_m = abs(m1 - m2)\n\n    p_dependent = complex(0)\n    for p in range(max(delta_m, delta_l + delta_tau), l1 + l2 + 1):\n        p_dependent += (\n            translation_table[n2, n1, p]\n            * plm[p * (p + 1) // 2 + delta_m, s1, s2]\n            * sph_h[p, s1, s2, w]\n        )\n    p_dependent *= e_j_dm_phi[m2 - m1 + 2 * lmax, s1, s2] * x[j2]\n\n    # atomic.add performs the += operation in sync\n    cuda.atomic.add(wx_real, (j1, w), p_dependent.real)\n    cuda.atomic.add(wx_imag, (j1, w), p_dependent.imag)\n</code></pre>"},{"location":"reference/computers/computer_cuda/#computers.computer_cuda.ComputerCUDA.compute_scattering_cross_section","title":"<code>compute_scattering_cross_section</code>","text":"<p>Compute the scattering cross section on the GPU using CUDA.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics expansion.</p> required <code>particle_number</code> <code>int</code> <p>The number of particles.</p> required <code>idx</code> <code>ndarray</code> <p>The index array.</p> required <code>sfc</code> <code>ndarray</code> <p>The scattering form factor array.</p> required <code>translation_table</code> <code>ndarray</code> <p>The translation table array.</p> required <code>plm</code> <code>ndarray</code> <p>The associated Legendre polynomials array.</p> required <code>sph_h</code> <code>ndarray</code> <p>The spherical harmonics array.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>The phase factor array.</p> required <code>c_sca_real</code> <code>ndarray</code> <p>The real part of the scattering cross section array.</p> required <code>c_sca_imag</code> <code>ndarray</code> <p>The imaginary part of the scattering cross section array.</p> required Source code in <code>yasfpy/computers/computer_cuda.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef compute_scattering_cross_section(\n    lmax: int,\n    particle_number: int,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    translation_table: np.ndarray,\n    plm: np.ndarray,\n    sph_h: np.ndarray,\n    e_j_dm_phi: np.ndarray,\n    c_sca_real: np.ndarray,\n    c_sca_imag: np.ndarray,\n):\n    \"\"\"\n    Compute the scattering cross section on the GPU using CUDA.\n\n    Args:\n        lmax (int): The maximum degree of the spherical harmonics expansion.\n        particle_number (int): The number of particles.\n        idx (np.ndarray): The index array.\n        sfc (np.ndarray): The scattering form factor array.\n        translation_table (np.ndarray): The translation table array.\n        plm (np.ndarray): The associated Legendre polynomials array.\n        sph_h (np.ndarray): The spherical harmonics array.\n        e_j_dm_phi (np.ndarray): The phase factor array.\n        c_sca_real (np.ndarray): The real part of the scattering cross section array.\n        c_sca_imag (np.ndarray): The imaginary part of the scattering cross section array.\n    \"\"\"\n    jmax = particle_number * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    j1, j2, w = cuda.grid(3)\n\n    if (j1 &gt;= jmax) or (j2 &gt;= jmax) or (w &gt;= channels):\n        return\n\n    s1, n1, _, _, m1 = idx[j1, :]\n    s2, n2, _, _, m2 = idx[j2, :]\n\n    delta_m = abs(m1 - m2)\n\n    p_dependent = complex(0)\n    for p in range(delta_m, 2 * lmax + 1):\n        p_dependent += (\n            translation_table[n2, n1, p]\n            * plm[p * (p + 1) // 2 + delta_m, s1, s2]\n            * sph_h[p, s1, s2, w]\n        )\n    p_dependent *= (\n        sfc[s1, n1, w].conjugate()\n        * e_j_dm_phi[m2 - m1 + 2 * lmax, s1, s2]\n        * sfc[s2, n2, w]\n    )\n\n    # atomic.add performs the += operation in sync\n    cuda.atomic.add(c_sca_real, w, p_dependent.real)\n    cuda.atomic.add(c_sca_imag, w, p_dependent.imag)\n</code></pre>"},{"location":"reference/computers/computer_cuda/#computers.computer_cuda.ComputerCUDA.compute_radial_independent_scattered_field","title":"<code>compute_radial_independent_scattered_field</code>","text":"<p>Compute the radial independent scattered field using GPU acceleration.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics expansion.</p> required <code>particles_position</code> <code>ndarray</code> <p>Array of particle positions.</p> required <code>idx</code> <code>ndarray</code> <p>Array of indices for particle properties.</p> required <code>sfc</code> <code>ndarray</code> <p>Array of scattering form factors.</p> required <code>k_medium</code> <code>ndarray</code> <p>Array of wave numbers in the medium.</p> required <code>azimuthal_angles</code> <code>ndarray</code> <p>Array of azimuthal angles.</p> required <code>e_r</code> <code>ndarray</code> <p>Array of radial electric field components.</p> required <code>e_phi</code> <code>ndarray</code> <p>Array of azimuthal electric field components.</p> required <code>e_theta</code> <code>ndarray</code> <p>Array of polar electric field components.</p> required <code>pilm</code> <code>ndarray</code> <p>Array of associated Legendre polynomials.</p> required <code>taulm</code> <code>ndarray</code> <p>Array of tau coefficients.</p> required <code>e_1_sca_real</code> <code>ndarray</code> <p>Array of real parts of the scattered electric field.</p> required <code>e_1_sca_imag</code> <code>ndarray</code> <p>Array of imaginary parts of the scattered electric field.</p> required Source code in <code>yasfpy/computers/computer_cuda.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef compute_radial_independent_scattered_field(\n    lmax: int,\n    particles_position: np.ndarray,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    k_medium: np.ndarray,\n    azimuthal_angles: np.ndarray,\n    e_r: np.ndarray,\n    e_phi: np.ndarray,\n    e_theta: np.ndarray,\n    pilm: np.ndarray,\n    taulm: np.ndarray,\n    e_1_sca_real: np.ndarray,\n    e_1_sca_imag: np.ndarray,\n):\n    \"\"\"\n    Compute the radial independent scattered field using GPU acceleration.\n\n    Args:\n        lmax (int): The maximum degree of the spherical harmonics expansion.\n        particles_position (np.ndarray): Array of particle positions.\n        idx (np.ndarray): Array of indices for particle properties.\n        sfc (np.ndarray): Array of scattering form factors.\n        k_medium (np.ndarray): Array of wave numbers in the medium.\n        azimuthal_angles (np.ndarray): Array of azimuthal angles.\n        e_r (np.ndarray): Array of radial electric field components.\n        e_phi (np.ndarray): Array of azimuthal electric field components.\n        e_theta (np.ndarray): Array of polar electric field components.\n        pilm (np.ndarray): Array of associated Legendre polynomials.\n        taulm (np.ndarray): Array of tau coefficients.\n        e_1_sca_real (np.ndarray): Array of real parts of the scattered electric field.\n        e_1_sca_imag (np.ndarray): Array of imaginary parts of the scattered electric field.\n    \"\"\"\n    j_idx, a_idx, w_idx = cuda.grid(3)\n\n    jmax = particles_position.shape[0] * 2 * lmax * (lmax + 2)\n\n    if (\n        (j_idx &gt;= jmax)\n        or (a_idx &gt;= azimuthal_angles.size)\n        or (w_idx &gt;= k_medium.size)\n    ):\n        return\n\n    s, n, tau, l, m = idx[j_idx, :]\n\n    # Temporary variable\n    # If tau = 1 -&gt; 1j**(tau-1) = 1, if tau = 2 -&gt; 1j**(tau-1) = 1j\n    # 1j**(-l-1) = (-1j)**(l+1) =&gt; both lead to the coefficient 1j**(tau-l-2)\n    # k * &lt;particle_position, e_r&gt; is the phase shift due to the distance and relative position\n    t = (\n        1j ** (tau - l - 2)\n        * sfc[s, n, w_idx]\n        / sqrt(2 * l * (l + 1))\n        * exp(\n            1j\n            * (\n                m * azimuthal_angles[a_idx]\n                - k_medium[w_idx]\n                * (\n                    particles_position[s, 0] * e_r[a_idx, 0]\n                    + particles_position[s, 1] * e_r[a_idx, 1]\n                    + particles_position[s, 2] * e_r[a_idx, 2]\n                )\n            )\n        )\n    )\n\n    for c in range(3):\n        if tau == 1:\n            e_1_sca = t * (\n                e_theta[a_idx, c] * pilm[l, abs(m), a_idx] * 1j * m\n                - e_phi[a_idx, c] * taulm[l, abs(m), a_idx]\n            )\n        else:\n            e_1_sca = t * (\n                e_phi[a_idx, c] * pilm[l, abs(m), a_idx] * 1j * m\n                + e_theta[a_idx, c] * taulm[l, abs(m), a_idx]\n            )\n\n        cuda.atomic.add(e_1_sca_real, (a_idx, c, w_idx), e_1_sca.real)\n        cuda.atomic.add(e_1_sca_imag, (a_idx, c, w_idx), e_1_sca.imag)\n</code></pre>"},{"location":"reference/computers/computer_cuda/#computers.computer_cuda.ComputerCUDA.compute_electric_field_angle_components","title":"<code>compute_electric_field_angle_components</code>","text":"<p>Compute the electric field angle components on the GPU.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum angular momentum quantum number.</p> required <code>particles_position</code> <code>ndarray</code> <p>Array of particle positions.</p> required <code>idx</code> <code>ndarray</code> <p>Array of indices.</p> required <code>sfc</code> <code>ndarray</code> <p>Array of scattering form factors.</p> required <code>k_medium</code> <code>ndarray</code> <p>Array of medium wavevectors.</p> required <code>azimuthal_angles</code> <code>ndarray</code> <p>Array of azimuthal angles.</p> required <code>e_r</code> <code>ndarray</code> <p>Array of radial unit vectors.</p> required <code>pilm</code> <code>ndarray</code> <p>Array of associated Legendre polynomials.</p> required <code>taulm</code> <code>ndarray</code> <p>Array of tau coefficients.</p> required <code>e_field_theta_real</code> <code>ndarray</code> <p>Array of real parts of electric field theta component.</p> required <code>e_field_theta_imag</code> <code>ndarray</code> <p>Array of imaginary parts of electric field theta component.</p> required <code>e_field_phi_real</code> <code>ndarray</code> <p>Array of real parts of electric field phi component.</p> required <code>e_field_phi_imag</code> <code>ndarray</code> <p>Array of imaginary parts of electric field phi component.</p> required Source code in <code>yasfpy/computers/computer_cuda.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef compute_electric_field_angle_components(\n    lmax: int,\n    particles_position: np.ndarray,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    k_medium: np.ndarray,\n    azimuthal_angles: np.ndarray,\n    e_r: np.ndarray,\n    pilm: np.ndarray,\n    taulm: np.ndarray,\n    e_field_theta_real: np.ndarray,\n    e_field_theta_imag: np.ndarray,\n    e_field_phi_real: np.ndarray,\n    e_field_phi_imag: np.ndarray,\n):\n    \"\"\"\n    Compute the electric field angle components on the GPU.\n\n    Args:\n        lmax (int): The maximum angular momentum quantum number.\n        particles_position (np.ndarray): Array of particle positions.\n        idx (np.ndarray): Array of indices.\n        sfc (np.ndarray): Array of scattering form factors.\n        k_medium (np.ndarray): Array of medium wavevectors.\n        azimuthal_angles (np.ndarray): Array of azimuthal angles.\n        e_r (np.ndarray): Array of radial unit vectors.\n        pilm (np.ndarray): Array of associated Legendre polynomials.\n        taulm (np.ndarray): Array of tau coefficients.\n        e_field_theta_real (np.ndarray): Array of real parts of electric field theta component.\n        e_field_theta_imag (np.ndarray): Array of imaginary parts of electric field theta component.\n        e_field_phi_real (np.ndarray): Array of real parts of electric field phi component.\n        e_field_phi_imag (np.ndarray): Array of imaginary parts of electric field phi component.\n    \"\"\"\n    j_idx, a_idx, w_idx = cuda.grid(3)\n    jmax = particles_position.shape[0] * 2 * lmax * (lmax + 2)\n    if (\n        (j_idx &gt;= jmax)\n        or (a_idx &gt;= azimuthal_angles.size)\n        or (w_idx &gt;= k_medium.size)\n    ):\n        return\n\n    s, n, tau, l, m = idx[j_idx, :]\n\n    t = (\n        1j ** (tau - l - 2)\n        * sfc[s, n, w_idx]\n        / sqrt(2 * l * (l + 1))\n        * exp(\n            1j\n            * (\n                m * azimuthal_angles[a_idx]\n                - k_medium[w_idx]\n                * (\n                    particles_position[s, 0] * e_r[a_idx, 0]\n                    + particles_position[s, 1] * e_r[a_idx, 1]\n                    + particles_position[s, 2] * e_r[a_idx, 2]\n                )\n            )\n        )\n    )\n\n    if tau == 1:\n        e_field_theta = t * pilm[l, abs(m), a_idx] * 1j * m\n        e_field_phi = -t * taulm[l, abs(m), a_idx]\n    else:\n        e_field_theta = t * taulm[l, abs(m), a_idx]\n        e_field_phi = t * pilm[l, abs(m), a_idx] * 1j * m\n\n    cuda.atomic.add(e_field_theta_real, (a_idx, w_idx), e_field_theta.real)\n    cuda.atomic.add(e_field_theta_imag, (a_idx, w_idx), e_field_theta.imag)\n    cuda.atomic.add(e_field_phi_real, (a_idx, w_idx), e_field_phi.real)\n    cuda.atomic.add(e_field_phi_imag, (a_idx, w_idx), e_field_phi.imag)\n</code></pre>"},{"location":"reference/computers/computer_cuda/#computers.computer_cuda.ComputerCUDA.compute_polarization_components","title":"<code>compute_polarization_components</code>","text":"<p>Compute the polarization components using GPU acceleration.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_wavelengths</code> <code>int</code> <p>Number of wavelengths.</p> required <code>number_of_angles</code> <code>int</code> <p>Number of angles.</p> required <code>e_field_theta_real</code> <code>ndarray</code> <p>Real part of the electric field in the theta direction.</p> required <code>e_field_theta_imag</code> <code>ndarray</code> <p>Imaginary part of the electric field in the theta direction.</p> required <code>e_field_phi_real</code> <code>ndarray</code> <p>Real part of the electric field in the phi direction.</p> required <code>e_field_phi_imag</code> <code>ndarray</code> <p>Imaginary part of the electric field in the phi direction.</p> required <code>intensity</code> <code>ndarray</code> <p>Array to store the intensity component.</p> required <code>degree_of_polarization</code> <code>ndarray</code> <p>Array to store the degree of polarization component.</p> required <code>degree_of_linear_polarization</code> <code>ndarray</code> <p>Array to store the degree of linear polarization component.</p> required <code>degree_of_linear_polarization_q</code> <code>ndarray</code> <p>Array to store the degree of linear polarization (Q) component.</p> required <code>degree_of_linear_polarization_u</code> <code>ndarray</code> <p>Array to store the degree of linear polarization (U) component.</p> required <code>degree_of_circular_polarization</code> <code>ndarray</code> <p>Array to store the degree of circular polarization component.</p> required Source code in <code>yasfpy/computers/computer_cuda.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef compute_polarization_components(\n    number_of_wavelengths: int,\n    number_of_angles: int,\n    e_field_theta_real: np.ndarray,\n    e_field_theta_imag: np.ndarray,\n    e_field_phi_real: np.ndarray,\n    e_field_phi_imag: np.ndarray,\n    intensity: np.ndarray,\n    degree_of_polarization: np.ndarray,\n    degree_of_linear_polarization: np.ndarray,\n    degree_of_linear_polarization_q: np.ndarray,\n    degree_of_linear_polarization_u: np.ndarray,\n    degree_of_circular_polarization: np.ndarray,\n):\n    \"\"\"\n    Compute the polarization components using GPU acceleration.\n\n    Args:\n        number_of_wavelengths (int): Number of wavelengths.\n        number_of_angles (int): Number of angles.\n        e_field_theta_real (np.ndarray): Real part of the electric field in the theta direction.\n        e_field_theta_imag (np.ndarray): Imaginary part of the electric field in the theta direction.\n        e_field_phi_real (np.ndarray): Real part of the electric field in the phi direction.\n        e_field_phi_imag (np.ndarray): Imaginary part of the electric field in the phi direction.\n        intensity (np.ndarray): Array to store the intensity component.\n        degree_of_polarization (np.ndarray): Array to store the degree of polarization component.\n        degree_of_linear_polarization (np.ndarray): Array to store the degree of linear polarization component.\n        degree_of_linear_polarization_q (np.ndarray): Array to store the degree of linear polarization (Q) component.\n        degree_of_linear_polarization_u (np.ndarray): Array to store the degree of linear polarization (U) component.\n        degree_of_circular_polarization (np.ndarray): Array to store the degree of circular polarization component.\n    \"\"\"\n    a_idx, w_idx = cuda.grid(2)\n    if (w_idx &gt;= number_of_wavelengths) or (a_idx &gt;= number_of_angles):\n        return\n\n    # Jones vector components (1,2,4)\n    e_field_theta_abs = (\n        e_field_theta_real[a_idx, w_idx] ** 2\n        + e_field_theta_imag[a_idx, w_idx] ** 2\n    )\n    e_field_phi_abs = (\n        e_field_phi_real[a_idx, w_idx] ** 2 + e_field_phi_imag[a_idx, w_idx] ** 2\n    )\n    e_field_angle_interaction_real = (\n        e_field_theta_real[a_idx, w_idx] * e_field_phi_real[a_idx, w_idx]\n        + e_field_theta_imag[a_idx, w_idx] * e_field_phi_imag[a_idx, w_idx]\n    )\n    e_field_angle_interaction_imag = (\n        e_field_theta_imag[a_idx, w_idx] * e_field_phi_real[a_idx, w_idx]\n        - e_field_theta_real[a_idx, w_idx] * e_field_phi_imag[a_idx, w_idx]\n    )\n\n    # Stokes components S = (I, Q, U, V)\n    I = e_field_theta_abs + e_field_phi_abs\n    Q = e_field_theta_abs - e_field_phi_abs\n    U = -2 * e_field_angle_interaction_real\n    V = 2 * e_field_angle_interaction_imag\n\n    intensity[a_idx, w_idx] = I\n    degree_of_polarization[a_idx, w_idx] = sqrt(Q**2 + U**2 + V**2).real / I\n    degree_of_linear_polarization[a_idx, w_idx] = sqrt(Q**2 + U**2).real / I\n    degree_of_linear_polarization_q[a_idx, w_idx] = -Q.real / I\n    degree_of_linear_polarization_u[a_idx, w_idx] = U.real / I\n    degree_of_circular_polarization[a_idx, w_idx] = V / I\n</code></pre>"},{"location":"reference/computers/computer_cuda/#computers.computer_cuda.ComputerCUDA.compute_field","title":"<code>compute_field</code>","text":"<p>Compute the field on the GPU using CUDA.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>Maximum degree of the spherical harmonics.</p> required <code>idx</code> <code>ndarray</code> <p>Array of indices.</p> required <code>size_parameter</code> <code>ndarray</code> <p>Array of size parameters.</p> required <code>sph_h</code> <code>ndarray</code> <p>Array of spherical harmonics.</p> required <code>derivative</code> <code>ndarray</code> <p>Array of derivatives.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>Array of phi-dependent terms.</p> required <code>p_lm</code> <code>ndarray</code> <p>Array of Legendre polynomials.</p> required <code>pi_lm</code> <code>ndarray</code> <p>Array of pi-dependent terms.</p> required <code>tau_lm</code> <code>ndarray</code> <p>Array of tau-dependent terms.</p> required <code>e_r</code> <code>ndarray</code> <p>Array of r-dependent terms.</p> required <code>e_theta</code> <code>ndarray</code> <p>Array of theta-dependent terms.</p> required <code>e_phi</code> <code>ndarray</code> <p>Array of phi-dependent terms.</p> required <code>scattered_field_coefficients</code> <code>ndarray</code> <p>Array of scattered field coefficients.</p> required <code>field_real</code> <code>ndarray</code> <p>Array to store the real part of the field.</p> required <code>field_imag</code> <code>ndarray</code> <p>Array to store the imaginary part of the field.</p> required Source code in <code>yasfpy/computers/computer_cuda.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef compute_field(\n    lmax: int,\n    idx: np.ndarray,\n    size_parameter: np.ndarray,\n    sph_h: np.ndarray,\n    derivative: np.ndarray,\n    e_j_dm_phi: np.ndarray,\n    p_lm: np.ndarray,\n    pi_lm: np.ndarray,\n    tau_lm: np.ndarray,\n    e_r: np.ndarray,\n    e_theta: np.ndarray,\n    e_phi: np.ndarray,\n    scattered_field_coefficients: np.ndarray,\n    field_real: np.ndarray,\n    field_imag: np.ndarray,\n):  # , initial_field_coefficients: np.ndarray, scatter_to_internal: np.ndarray):\n    \"\"\"\n    Compute the field on the GPU using CUDA.\n\n    Args:\n        lmax (int): Maximum degree of the spherical harmonics.\n        idx (np.ndarray): Array of indices.\n        size_parameter (np.ndarray): Array of size parameters.\n        sph_h (np.ndarray): Array of spherical harmonics.\n        derivative (np.ndarray): Array of derivatives.\n        e_j_dm_phi (np.ndarray): Array of phi-dependent terms.\n        p_lm (np.ndarray): Array of Legendre polynomials.\n        pi_lm (np.ndarray): Array of pi-dependent terms.\n        tau_lm (np.ndarray): Array of tau-dependent terms.\n        e_r (np.ndarray): Array of r-dependent terms.\n        e_theta (np.ndarray): Array of theta-dependent terms.\n        e_phi (np.ndarray): Array of phi-dependent terms.\n        scattered_field_coefficients (np.ndarray): Array of scattered field coefficients.\n        field_real (np.ndarray): Array to store the real part of the field.\n        field_imag (np.ndarray): Array to store the imaginary part of the field.\n    \"\"\"\n    jmax = sph_h.shape[1] * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    sampling_idx, j_idx, w = cuda.grid(3)\n\n    if (sampling_idx &gt;= sph_h.shape[2]) or (j_idx &gt;= jmax) or (w &gt;= channels):\n        return\n\n    particle_idx, n, tau, l, m = idx[j_idx, :]\n\n    invariant = (\n        1\n        / sqrt(2 * (l + 1) * l)\n        * e_j_dm_phi[m + 2 * lmax, particle_idx, sampling_idx]\n    )\n\n    for c in range(3):\n        term = scattered_field_coefficients[particle_idx, n, w] * invariant\n\n        # Calculate M\n        if tau == 1:\n            c_term_1 = (\n                pi_lm[l, abs(m), particle_idx, sampling_idx]\n                * e_theta[particle_idx, sampling_idx, c]\n                * 1j\n                * m\n            )\n            c_term_2 = (\n                tau_lm[l, abs(m), particle_idx, sampling_idx]\n                * e_phi[particle_idx, sampling_idx, c]\n            )\n            c_term = sph_h[l, particle_idx, sampling_idx, w] * (c_term_1 - c_term_2)\n\n            term *= c_term\n\n        # Calculate N\n        else:\n            p_term = (\n                l\n                * (l + 1)\n                / size_parameter[particle_idx, sampling_idx, w]\n                * sph_h[l, particle_idx, sampling_idx, w]\n            )\n            p_term *= (\n                p_lm[l, abs(m), particle_idx, sampling_idx]\n                * e_r[particle_idx, sampling_idx, c]\n            )\n\n            b_term_1 = (\n                derivative[l, particle_idx, sampling_idx, w]\n                / size_parameter[particle_idx, sampling_idx, w]\n            )\n            b_term_2 = (\n                tau_lm[l, abs(m), particle_idx, sampling_idx]\n                * e_theta[particle_idx, sampling_idx, c]\n            )\n            b_term_3 = (\n                pi_lm[l, abs(m), particle_idx, sampling_idx]\n                * e_phi[particle_idx, sampling_idx, c]\n                * 1j\n                * m\n            )\n            b_term = b_term_1 * (b_term_2 + b_term_3)\n\n            term *= p_term + b_term\n\n        cuda.atomic.add(field_real, (w, sampling_idx, c), term.real)\n        cuda.atomic.add(field_imag, (w, sampling_idx, c), term.imag)\n</code></pre>"},{"location":"reference/functions/cpu_numba/","title":"Cpu Numba","text":""},{"location":"reference/functions/cpu_numba/#functions.cpu_numba.particle_interaction","title":"<code>particle_interaction</code>","text":"<p>Calculates the interaction between particles based on their properties and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum value of the angular momentum quantum number <code>l</code>. It determines the size of the arrays <code>plm</code> and <code>sph_h</code>.</p> required <code>particle_number</code> <code>int</code> <p>The number of particles in the system.</p> required <code>idx</code> <code>ndarray</code> <p>A numpy array of shape <code>(jmax, 5)</code>, where <code>jmax</code> is the total number of interactions between particles. Each row of <code>idx</code> represents an interaction and contains the following information: - s1 (int): The index of the first particle. - n1 (int): The index of the first particle's property. - tau1 (int): The tau value of the first particle. - l1 (int): The l value of the first particle. - m1 (int): The m value of the first particle.</p> required <code>x</code> <code>ndarray</code> <p>A numpy array representing the positions of the particles. It has shape <code>(particle_number,)</code> and contains the x-coordinates of the particles.</p> required <code>translation_table</code> <code>ndarray</code> <p>A 3-dimensional numpy array that stores the translation coefficients used in the calculation. It has shape <code>(n2, n1, p)</code> where <code>n2</code> and <code>n1</code> are the indices of the translation coefficients, and <code>p</code> is the maximum.</p> required <code>plm</code> <code>ndarray</code> <p>A numpy array representing the associated Legendre polynomials. It has shape <code>(pmax * (pmax + 1) // 2, s1max, s2max)</code>, where <code>pmax</code> is the maximum degree of the Legendre polynomials.</p> required <code>sph_h</code> <code>ndarray</code> <p>A numpy array representing the spherical harmonics. It has shape <code>(jmax, jmax, channels)</code>, where <code>jmax</code> is the maximum number of particles, <code>channels</code> is the number of channels.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>The parameter <code>e_j_dm_phi</code> is not defined in the code snippet you provided. Could you please provide the definition or explanation of what <code>e_j_dm_phi</code> represents?</p> required <p>Returns:</p> Name Type Description <code>wx</code> <code>ndarray</code> <p>The array <code>wx</code>, which represents the result of the particle interaction calculations.</p> Source code in <code>yasfpy/functions/cpu_numba.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True, cache=True)\ndef particle_interaction(\n    lmax: int,\n    particle_number: int,\n    idx: np.ndarray,\n    x: np.ndarray,\n    translation_table: np.ndarray,\n    plm: np.ndarray,\n    sph_h: np.ndarray,\n    e_j_dm_phi,\n):\n    \"\"\"Calculates the interaction between particles based on their properties and returns the result.\n\n    Args:\n        lmax (int): The maximum value of the angular momentum quantum number `l`. It determines the size of the arrays `plm` and `sph_h`.\n        particle_number (int): The number of particles in the system.\n        idx (np.ndarray): A numpy array of shape `(jmax, 5)`, where `jmax` is the total number of interactions between particles. Each row of `idx` represents an interaction and contains the following information:\n            - s1 (int): The index of the first particle.\n            - n1 (int): The index of the first particle's property.\n            - tau1 (int): The tau value of the first particle.\n            - l1 (int): The l value of the first particle.\n            - m1 (int): The m value of the first particle.\n        x (np.ndarray): A numpy array representing the positions of the particles. It has shape `(particle_number,)` and contains the x-coordinates of the particles.\n        translation_table (np.ndarray): A 3-dimensional numpy array that stores the translation coefficients used in the calculation. It has shape `(n2, n1, p)` where `n2` and `n1` are the indices of the translation coefficients, and `p` is the maximum.\n        plm (np.ndarray): A numpy array representing the associated Legendre polynomials. It has shape `(pmax * (pmax + 1) // 2, s1max, s2max)`, where `pmax` is the maximum degree of the Legendre polynomials.\n        sph_h (np.ndarray): A numpy array representing the spherical harmonics. It has shape `(jmax, jmax, channels)`, where `jmax` is the maximum number of particles, `channels` is the number of channels.\n        e_j_dm_phi (np.ndarray): The parameter `e_j_dm_phi` is not defined in the code snippet you provided. Could you please provide the definition or explanation of what `e_j_dm_phi` represents?\n\n    Returns:\n        wx (np.ndarray): The array `wx`, which represents the result of the particle interaction calculations.\n    \"\"\"\n    jmax = particle_number * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    wx = np.zeros(x.size * channels, dtype=complex128).reshape(x.shape + (channels,))\n\n    for w_idx in prange(jmax * jmax * channels):\n        w = w_idx % channels\n        j_idx = w_idx // channels\n        j1 = j_idx // jmax\n        j2 = j_idx % jmax\n        s1, n1, tau1, l1, m1 = idx[j1, :]\n        s2, n2, tau2, l2, m2 = idx[j2, :]\n\n        if s1 == s2:\n            continue\n\n        delta_tau = np.absolute(tau1 - tau2)\n        delta_l = np.absolute(l1 - l2)\n        delta_m = np.absolute(m1 - m2)\n\n        val = 0j\n        for p in range(np.maximum(delta_m, delta_l + delta_tau), l1 + l2 + 1):\n            val += (\n                translation_table[n2, n1, p]\n                * plm[p * (p + 1) // 2 + delta_m, s1, s2]\n                * sph_h[p, s1, s2, w]\n            )\n        val *= e_j_dm_phi[m2 - m1 + 2 * lmax, s1, s2] * x[j2]\n\n        wx[j1, w] += val\n\n    return wx\n</code></pre>"},{"location":"reference/functions/cpu_numba/#functions.cpu_numba.compute_idx_lookups","title":"<code>compute_idx_lookups</code>","text":"<p>The function <code>compute_idx_lookups</code> generates an index lookup table for a given <code>lmax</code> and <code>particle_number</code> using parallel processing.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum value of the angular momentum quantum number <code>l</code>. It determines the range of values for <code>l</code> in the nested loop.</p> required <code>particle_number</code> <code>int</code> <p>The number of particles in the system.</p> required <p>Returns:</p> Name Type Description <code>idx</code> <code>ndarray</code> <p>A NumPy array <code>idx</code> which contains the computed index lookups.</p> Source code in <code>yasfpy/functions/cpu_numba.py</code> <pre><code>@jit(nopython=True, parallel=True, fastmath=True)\ndef compute_idx_lookups(lmax: int, particle_number: int):\n    \"\"\"\n    The function `compute_idx_lookups` generates an index lookup table for a given `lmax` and\n    `particle_number` using parallel processing.\n\n    Args:\n        lmax (int): The maximum value of the angular momentum quantum number `l`. It determines the range of values for `l` in the nested loop.\n        particle_number (int): The number of particles in the system.\n\n    Returns:\n        idx (np.ndarray): A NumPy array `idx` which contains the computed index lookups.\n    \"\"\"\n    nmax = 2 * lmax * (lmax + 2)\n    idx = np.zeros(nmax * particle_number * 5, dtype=int64).reshape(\n        (nmax * particle_number, 5)\n    )\n\n    # TODO: Needs further testing!\n    # TODO: Make it go brrrr\n    # for i in prange(particle_number * nmax):\n    #     s = i // (2 * lmax * (lmax + 2))\n    #     i_new = i % (2 * lmax * (lmax + 2))\n    #     tau = i_new // (lmax * (lmax + 2)) + 1\n    #     i_new = i_new % (lmax * (lmax + 2))\n    #     l = np.floor(np.sqrt(i_new + 1))\n    #     m = i_new - (l * l + l - 1)\n    #     n = (tau - 1) * lmax * (lmax + 2) + (l - 1) * (l + 1) + l + m\n    #     idx[i, 0] = s\n    #     idx[i, 1] = n\n    #     idx[i, 2] = tau\n    #     idx[i, 3] = l\n    #     idx[i, 4] = m\n\n    for s in prange(particle_number):\n        for tau in range(1, 3):\n            for l in range(1, lmax + 1):\n                for m in range(-l, l + 1):\n                    n = (tau - 1) * lmax * (lmax + 2) + (l - 1) * (l + 1) + l + m\n                    i = n + s * nmax\n                    idx[i, 0] = s\n                    idx[i, 1] = n\n                    idx[i, 2] = tau\n                    idx[i, 3] = l\n                    idx[i, 4] = m\n\n    return idx\n</code></pre>"},{"location":"reference/functions/cpu_numba/#functions.cpu_numba.compute_scattering_cross_section","title":"<code>compute_scattering_cross_section</code>","text":"<p>Calculates the scattering cross section for a given set of input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum angular momentum quantum number. It determines the maximum value of <code>l</code> in the calculations.</p> required <code>particle_number</code> <code>int</code> <p>The number of particles in the system.</p> required <code>idx</code> <code>ndarray</code> <p>A numpy array of shape <code>(jmax, 5)</code>, where <code>jmax</code> is the total number of particle pairs. Each row of <code>idx</code> represents a particle pair and contains the following information: - s (int): The index of the first particle. - n (int): The index of the second particle. - tau (int): The tau value. - l (int): The l value. - m (int): The m value.</p> required <code>sfc</code> <code>ndarray</code> <p>A numpy array of shape <code>(s, n, channels)</code>, where:</p> required <code>translation_table</code> <code>ndarray</code> <p>A 3-dimensional numpy array that stores the translation coefficients used in the computation of the scattering cross section. It has shape <code>(n2, n1, p)</code> where <code>n2</code> and <code>n1</code> are the number of radial functions for the second and first particles, respectively, and <code>p</code> is the order of the Legendre polynomial.</p> required <code>plm</code> <code>ndarray</code> <p>A numpy array representing the associated Legendre polynomials. It has shape <code>(pmax * (pmax + 1) // 2, 2, 2)</code>, where <code>pmax</code> is the maximum value of <code>p</code> in the loop.</p> required <code>sph_h</code> <code>ndarray</code> <p>A numpy array of shape <code>(pmax, s1max, s2max, channels)</code>. It represents the scattering matrix elements for each combination of <code>s1</code>, <code>s2</code>, and <code>p</code>, where <code>p</code> is the order of the Legendre polynomial.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>A numpy array representing the scattering phase function. It has shape <code>(2*lmax+1, channels, channels)</code> and contains complex values. The indices <code>(j, s1, s2)</code> represent the angular momentum index <code>j</code>, and the spin indices <code>s1</code> and <code>s2</code>.</p> required <p>Returns:</p> Name Type Description <code>c_sca_complex</code> <code>ndarray</code> <p>The complex scattering cross section <code>c_sca_complex</code>.</p> Source code in <code>yasfpy/functions/cpu_numba.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True)\ndef compute_scattering_cross_section(\n    lmax: int,\n    particle_number: int,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    translation_table: np.ndarray,\n    plm: np.ndarray,\n    sph_h: np.ndarray,\n    e_j_dm_phi: np.ndarray,\n):\n    \"\"\"Calculates the scattering cross section for a given set of input parameters.\n\n    Args:\n        lmax (int): The maximum angular momentum quantum number. It determines the maximum value of `l` in the calculations.\n        particle_number (int): The number of particles in the system.\n        idx (np.ndarray): A numpy array of shape `(jmax, 5)`, where `jmax` is the total number of particle pairs. Each row of `idx` represents a particle pair and contains the following information:\n            - s (int): The index of the first particle.\n            - n (int): The index of the second particle.\n            - tau (int): The tau value.\n            - l (int): The l value.\n            - m (int): The m value.\n        sfc (np.ndarray): A numpy array of shape `(s, n, channels)`, where:\n        translation_table (np.ndarray): A 3-dimensional numpy array that stores the translation coefficients used in the computation of the scattering cross section. It has shape `(n2, n1, p)` where `n2` and `n1` are the number of radial functions for the second and first particles, respectively, and `p` is the order of the Legendre polynomial.\n        plm (np.ndarray): A numpy array representing the associated Legendre polynomials. It has shape `(pmax * (pmax + 1) // 2, 2, 2)`, where `pmax` is the maximum value of `p` in the loop.\n        sph_h (np.ndarray): A numpy array of shape `(pmax, s1max, s2max, channels)`. It represents the scattering matrix elements for each combination of `s1`, `s2`, and `p`, where `p` is the order of the Legendre polynomial.\n        e_j_dm_phi (np.ndarray): A numpy array representing the scattering phase function. It has shape `(2*lmax+1, channels, channels)` and contains complex values. The indices `(j, s1, s2)` represent the angular momentum index `j`, and the spin indices `s1` and `s2`.\n\n    Returns:\n        c_sca_complex (np.ndarray): The complex scattering cross section `c_sca_complex`.\n    \"\"\"\n    jmax = particle_number * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    c_sca_complex = np.zeros(channels, dtype=complex128)\n\n    for j_idx in prange(jmax * jmax):\n        j1 = j_idx // jmax\n        j2 = j_idx % jmax\n        s1, n1, _, _, m1 = idx[j1, :]\n        s2, n2, _, _, m2 = idx[j2, :]\n\n        delta_m = np.absolute(m1 - m2)\n\n        p_dependent = np.zeros(channels, dtype=complex128)\n        for p in range(delta_m, 2 * lmax + 1):\n            p_dependent += (\n                translation_table[n2, n1, p]\n                * plm[p * (p + 1) // 2 + delta_m, s1, s2]\n                * sph_h[p, s1, s2, :]\n            )\n        p_dependent *= (\n            np.conj(sfc[s1, n1, :])\n            * e_j_dm_phi[m2 - m1 + 2 * lmax, s1, s2]\n            * sfc[s2, n2, :]\n        )\n\n        c_sca_complex += p_dependent\n\n    return c_sca_complex\n</code></pre>"},{"location":"reference/functions/cpu_numba/#functions.cpu_numba.compute_radial_independent_scattered_field_legacy","title":"<code>compute_radial_independent_scattered_field_legacy</code>","text":"<p>Calculates the scattered field for a given set of parameters and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum value of the angular momentum quantum number <code>l</code>. It determines the maximum order of the spherical harmonics used in the computation.</p> required <code>particles_position</code> <code>ndarray</code> <p>An array representing the positions of particles. It has shape <code>(num_particles, 3)</code>, where <code>num_particles</code> is the number of particles and each row represents the x, y, and z coordinates of a particle.</p> required <code>idx</code> <code>ndarray</code> <p>An array containing the indices of the particles. It has shape <code>(jmax, 5)</code> where <code>jmax</code> is the total number of particles. Each row of <code>idx</code> represents a particle and contains the following information:</p> required <code>sfc</code> <code>ndarray</code> <p>A 3-dimensional array representing the scattering form factors. It has dimensions <code>(s, n, w)</code>, where:</p> required <code>k_medium</code> <code>ndarray</code> <p>An array representing the wave number in the medium. It is used in the calculation of the scattered field.</p> required <code>azimuthal_angles</code> <code>ndarray</code> <p>An array of azimuthal angles, representing the angles at which the scattered field is computed.</p> required <code>e_r</code> <code>ndarray</code> <p>An array representing the radial component of the electric field. It has shape <code>(azimuthal_angles.size, 3)</code>, where <code>azimuthal_angles.size</code> is the number of azimuthal angles and 3 represents the three Cartesian components of the electric field.</p> required <code>e_phi</code> <code>ndarray</code> <p>An array representing the electric field component in the azimuthal direction. It has a shape of <code>(azimuthal_angles.size, 3)</code>, where <code>azimuthal_angles.size</code> is the number of azimuthal angles and <code>3</code> represents the three components of the electric field.</p> required <code>e_theta</code> <code>ndarray</code> <p>An array representing the electric field component in the theta direction. It has a shape of <code>(azimuthal_angles.size, 3)</code>, where <code>azimuthal_angles.size</code> is the number of azimuthal angles and <code>3</code> represents the three components of the electric field.</p> required <code>pilm</code> <code>ndarray</code> <p>An array representing the matrix of spherical harmonics coefficients. It has a shape of <code>(lmax+1, lmax+1, azimuthal_angles.size)</code>. Each element <code>pilm[l, m, a]</code> represents the coefficient of the spherical harmonics for a given <code>l</code>, <code>m</code>, and azimuthal angle <code>a</code>.</p> required <code>taulm</code> <code>ndarray</code> <p>An array representing the scattering coefficients for each combination of <code>l</code>, <code>m</code>, and azimuthal angle <code>a</code>. It has a shape of <code>(lmax+1, lmax+1, azimuthal_angles.size)</code>. The values in <code>taulm</code> represent the scattering coefficients.</p> required <p>Returns:</p> Name Type Description <code>e_1_sca</code> <code>ndarray</code> <p>An array of complex numbers representing the scattered field.</p> Source code in <code>yasfpy/functions/cpu_numba.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True)\ndef compute_radial_independent_scattered_field_legacy(\n    lmax: int,\n    particles_position: np.ndarray,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    k_medium: np.ndarray,\n    azimuthal_angles: np.ndarray,\n    e_r: np.ndarray,\n    e_phi: np.ndarray,\n    e_theta: np.ndarray,\n    pilm: np.ndarray,\n    taulm: np.ndarray,\n):\n    \"\"\"Calculates the scattered field for a given set of parameters and returns the result.\n\n    Args:\n        lmax (int): The maximum value of the angular momentum quantum number `l`. It determines the maximum order of the spherical harmonics used in the computation.\n        particles_position (np.ndarray): An array representing the positions of particles. It has shape `(num_particles, 3)`, where `num_particles` is the number of particles and each row represents the x, y, and z coordinates of a particle.\n        idx (np.ndarray): An array containing the indices of the particles. It has shape `(jmax, 5)` where `jmax` is the total number of particles. Each row of `idx` represents a particle and contains the following information:\n        sfc (np.ndarray): A 3-dimensional array representing the scattering form factors. It has dimensions `(s, n, w)`, where:\n        k_medium (np.ndarray): An array representing the wave number in the medium. It is used in the calculation of the scattered field.\n        azimuthal_angles (np.ndarray): An array of azimuthal angles, representing the angles at which the scattered field is computed.\n        e_r (np.ndarray): An array representing the radial component of the electric field. It has shape `(azimuthal_angles.size, 3)`, where `azimuthal_angles.size` is the number of azimuthal angles and 3 represents the three Cartesian components of the electric field.\n        e_phi (np.ndarray): An array representing the electric field component in the azimuthal direction. It has a shape of `(azimuthal_angles.size, 3)`, where `azimuthal_angles.size` is the number of azimuthal angles and `3` represents the three components of the electric field.\n        e_theta (np.ndarray): An array representing the electric field component in the theta direction. It has a shape of `(azimuthal_angles.size, 3)`, where `azimuthal_angles.size` is the number of azimuthal angles and `3` represents the three components of the electric field.\n        pilm (np.ndarray): An array representing the matrix of spherical harmonics coefficients. It has a shape of `(lmax+1, lmax+1, azimuthal_angles.size)`. Each element `pilm[l, m, a]` represents the coefficient of the spherical harmonics for a given `l`, `m`, and azimuthal angle `a`.\n        taulm (np.ndarray): An array representing the scattering coefficients for each combination of `l`, `m`, and azimuthal angle `a`. It has a shape of `(lmax+1, lmax+1, azimuthal_angles.size)`. The values in `taulm` represent the scattering coefficients.\n\n    Returns:\n        e_1_sca (np.ndarray): An array of complex numbers representing the scattered field.\n\n    \"\"\"\n    e_1_sca = np.zeros(\n        azimuthal_angles.size * 3 * k_medium.size, dtype=complex128\n    ).reshape((azimuthal_angles.size, 3, k_medium.size))\n    jmax = particles_position.shape[0] * 2 * lmax * (lmax + 2)\n\n    for global_idx in prange(jmax * azimuthal_angles.size * k_medium.size):\n        w_idx = global_idx % (jmax * k_medium.size)\n        g_idx = global_idx // (jmax * k_medium.size)\n\n        a = g_idx\n\n        w = w_idx % k_medium.size\n        j_idx = w_idx // k_medium.size\n        s, n, tau, l, m = idx[j_idx, :]\n\n        t = (\n            np.power(1j, tau - l - 2)\n            * sfc[s, n, w]\n            / np.sqrt(2 * l * (l + 1))\n            * np.exp(\n                1j\n                * (\n                    m * azimuthal_angles[a]\n                    - k_medium[w] * np.sum(particles_position[s, :] * e_r[a, :])\n                )\n            )\n        )\n\n        if tau == 1:\n            e_1_sca[a, :, w] += t * (\n                e_theta[a, :] * pilm[l, np.abs(m), a] * 1j * m\n                - e_phi[a, :] * taulm[l, np.abs(m), a]\n            )\n        else:\n            e_1_sca[a, :, w] += t * (\n                e_phi[a, :] * pilm[l, np.abs(m), a] * 1j * m\n                + e_theta[a, :] * taulm[l, np.abs(m), a]\n            )\n\n    return e_1_sca\n</code></pre>"},{"location":"reference/functions/cpu_numba/#functions.cpu_numba.compute_electric_field_angle_components","title":"<code>compute_electric_field_angle_components</code>","text":"<p>Calculates the electric field components in the theta and phi directions for given input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum value of the angular momentum quantum number <code>l</code>. It determines the maximum value of <code>l</code> for which the calculations will be performed.</p> required <code>particles_position</code> <code>ndarray</code> <p>The positions of particles. It has shape <code>(num_particles, 3)</code>, where <code>num_particles</code> is the number of particles and each particle has 3 coordinates (x, y, z).</p> required <code>idx</code> <code>ndarray</code> <p>A numpy array of shape <code>(jmax, 5)</code>, where <code>jmax</code> is the total number of particles multiplied by <code>2 * lmax * (lmax + 2)</code>. Each row of <code>idx</code> represents the indices <code>(s, n, tau, l, m)</code>.</p> required <code>sfc</code> <code>ndarray</code> <p>A 3-dimensional numpy array representing the scattering form factors. It has dimensions <code>(s, n, w)</code>.</p> required <code>k_medium</code> <code>ndarray</code> <p>The wave vector in the medium. It is a numpy array that contains the wave vector values for different frequencies or wavelengths.</p> required <code>azimuthal_angles</code> <code>ndarray</code> <p>An array representing the azimuthal angles at which the electric field components are computed. It specifies the angles at which the electric field is measured in the azimuthal direction.</p> required <code>e_r</code> <code>ndarray</code> <p>The unit vector pointing in the direction of the electric field. It is a numpy array of shape <code>(azimuthal_angles.size, 3)</code>, where each row corresponds to a different azimuthal angle and the three columns represent the x, y, and z components.</p> required <code>pilm</code> <code>ndarray</code> <p>A 3-dimensional numpy array of shape <code>(lmax+1, lmax+1, azimuthal_angles.size)</code>. It represents the matrix elements of the electric field expansion coefficients for the theta component. The indices <code>(l, m, a)</code> correspond to the spherical harmonics.</p> required <code>taulm</code> <code>ndarray</code> <p>A numpy array that represents the angular momentum coupling coefficients. It has a shape of <code>(lmax+1, lmax+1, azimuthal_angles.size)</code>. The first dimension represents the value of <code>l</code>, the second dimension represents the value of <code>m</code>, and the third dimension represents the azimuthal angle.</p> required <p>Returns:</p> Name Type Description <code>e_field_theta</code> <code>ndarray</code> <p>The electric field component in the theta direction.</p> <code>e_field_phi</code> <code>ndarray</code> <p>The electric field component in the phi direction.</p> Source code in <code>yasfpy/functions/cpu_numba.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True)\ndef compute_electric_field_angle_components(\n    lmax: int,\n    particles_position: np.ndarray,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    k_medium: np.ndarray,\n    azimuthal_angles: np.ndarray,\n    e_r: np.ndarray,\n    pilm: np.ndarray,\n    taulm: np.ndarray,\n):\n    \"\"\"Calculates the electric field components in the theta and phi directions for given input parameters.\n\n    Args:\n        lmax (int): The maximum value of the angular momentum quantum number `l`. It determines the maximum value of `l` for which the calculations will be performed.\n        particles_position (np.ndarray): The positions of particles. It has shape `(num_particles, 3)`, where `num_particles` is the number of particles and each particle has 3 coordinates (x, y, z).\n        idx (np.ndarray): A numpy array of shape `(jmax, 5)`, where `jmax` is the total number of particles multiplied by `2 * lmax * (lmax + 2)`. Each row of `idx` represents the indices `(s, n, tau, l, m)`.\n        sfc (np.ndarray): A 3-dimensional numpy array representing the scattering form factors. It has dimensions `(s, n, w)`.\n        k_medium (np.ndarray): The wave vector in the medium. It is a numpy array that contains the wave vector values for different frequencies or wavelengths.\n        azimuthal_angles (np.ndarray): An array representing the azimuthal angles at which the electric field components are computed. It specifies the angles at which the electric field is measured in the azimuthal direction.\n        e_r (np.ndarray): The unit vector pointing in the direction of the electric field. It is a numpy array of shape `(azimuthal_angles.size, 3)`, where each row corresponds to a different azimuthal angle and the three columns represent the x, y, and z components.\n        pilm (np.ndarray): A 3-dimensional numpy array of shape `(lmax+1, lmax+1, azimuthal_angles.size)`. It represents the matrix elements of the electric field expansion coefficients for the theta component. The indices `(l, m, a)` correspond to the spherical harmonics.\n        taulm (np.ndarray): A numpy array that represents the angular momentum coupling coefficients. It has a shape of `(lmax+1, lmax+1, azimuthal_angles.size)`. The first dimension represents the value of `l`, the second dimension represents the value of `m`, and the third dimension represents the azimuthal angle.\n\n    Returns:\n        e_field_theta (np.ndarray): The electric field component in the theta direction.\n        e_field_phi (np.ndarray): The electric field component in the phi direction.\n    \"\"\"\n    e_field_theta = np.zeros(\n        azimuthal_angles.size * k_medium.size, dtype=complex128\n    ).reshape((azimuthal_angles.size, k_medium.size))\n    e_field_phi = np.zeros_like(e_field_theta)\n\n    jmax = particles_position.shape[0] * 2 * lmax * (lmax + 2)\n\n    for global_idx in prange(jmax * azimuthal_angles.size * k_medium.size):\n        w_idx = global_idx % (jmax * k_medium.size)\n        g_idx = global_idx // (jmax * k_medium.size)\n\n        a = g_idx\n\n        w = w_idx % k_medium.size\n        j_idx = w_idx // k_medium.size\n        s, n, tau, l, m = idx[j_idx, :]\n\n        t = (\n            np.power(1j, tau - l - 2)\n            * sfc[s, n, w]\n            / np.sqrt(2 * l * (l + 1))\n            * np.exp(\n                1j\n                * (\n                    m * azimuthal_angles[a]\n                    - k_medium[w] * np.sum(particles_position[s, :] * e_r[a, :])\n                )\n            )\n        )\n\n        if tau == 1:\n            e_field_theta[a, w] += t * pilm[l, np.abs(m), a] * 1j * m\n            e_field_phi[a, w] -= t * taulm[l, np.abs(m), a]\n        else:\n            e_field_theta[a, w] += t * taulm[l, np.abs(m), a]\n            e_field_phi[a, w] += t * pilm[l, np.abs(m), a] * 1j * m\n\n    return e_field_theta, e_field_phi\n</code></pre>"},{"location":"reference/functions/cpu_numba/#functions.cpu_numba.compute_polarization_components","title":"<code>compute_polarization_components</code>","text":"<p>Compute the polarization components of electromagnetic fields.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_wavelengths</code> <code>int</code> <p>The number of wavelengths.</p> required <code>number_of_angles</code> <code>int</code> <p>The number of angles.</p> required <code>e_field_theta</code> <code>ndarray</code> <p>The electric field component in the theta direction.</p> required <code>e_field_phi</code> <code>ndarray</code> <p>The electric field component in the phi direction.</p> required <p>Returns:</p> Name Type Description <code>degree_of_polarization_tuple</code> <code>tuple</code> <p>A tuple containing the following polarization components: - I (np.ndarray): The total intensity. - degree_of_polarization (np.ndarray): The degree of polarization. - degree_of_linear_polarization (np.ndarray): The degree of linear polarization. - degree_of_linear_polarization_q (np.ndarray): The degree of linear polarization in the Q direction. - degree_of_linear_polarization_u (np.ndarray): The degree of linear polarization in the U direction. - degree_of_circular_polarization (np.ndarray): The degree of circular polarization.</p> Source code in <code>yasfpy/functions/cpu_numba.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True)\ndef compute_polarization_components(\n    number_of_wavelengths: int,\n    number_of_angles: int,\n    e_field_theta: np.ndarray,\n    e_field_phi: np.ndarray,\n):\n    \"\"\"\n    Compute the polarization components of electromagnetic fields.\n\n    Args:\n        number_of_wavelengths (int): The number of wavelengths.\n        number_of_angles (int): The number of angles.\n        e_field_theta (np.ndarray): The electric field component in the theta direction.\n        e_field_phi (np.ndarray): The electric field component in the phi direction.\n\n    Returns:\n        degree_of_polarization_tuple (tuple): A tuple containing the following polarization components:\n            - I (np.ndarray): The total intensity.\n            - degree_of_polarization (np.ndarray): The degree of polarization.\n            - degree_of_linear_polarization (np.ndarray): The degree of linear polarization.\n            - degree_of_linear_polarization_q (np.ndarray): The degree of linear polarization in the Q direction.\n            - degree_of_linear_polarization_u (np.ndarray): The degree of linear polarization in the U direction.\n            - degree_of_circular_polarization (np.ndarray): The degree of circular polarization.\n    \"\"\"\n    # Stokes components\n    # S = np.zeros(4 * number_of_angles * number_of_wavelengths, dtype=complex128).reshape((4, number_of_angles, number_of_wavelengths))\n    I = np.zeros(number_of_angles * number_of_wavelengths, dtype=float64).reshape(\n        (number_of_angles, number_of_wavelengths)\n    )\n    Q = np.zeros_like(I)\n    U = np.zeros_like(I)\n    V = np.zeros_like(I)\n\n    for global_idx in prange(number_of_angles * number_of_wavelengths):\n        w_idx = global_idx % number_of_wavelengths\n        a_idx = global_idx // number_of_wavelengths\n\n        e_field_theta_abs = (\n            e_field_theta[a_idx, w_idx].real ** 2\n            + e_field_theta[a_idx, w_idx].imag ** 2\n        )\n        e_field_phi_abs = (\n            e_field_phi[a_idx, w_idx].real ** 2 + e_field_phi[a_idx, w_idx].imag ** 2\n        )\n        e_field_angle_interaction = (\n            e_field_theta[a_idx, w_idx] * e_field_phi[a_idx, w_idx].conjugate()\n        )\n\n        I[a_idx, w_idx] = e_field_theta_abs + e_field_phi_abs\n        Q[a_idx, w_idx] = e_field_theta_abs - e_field_phi_abs\n        U[a_idx, w_idx] = -2 * e_field_angle_interaction.real\n        V[a_idx, w_idx] = 2 * e_field_angle_interaction.imag\n\n    degree_of_polarization = np.sqrt(Q**2 + U**2 + V**2) / I\n    degree_of_linear_polarization = np.sqrt(Q**2 + U**2) / I\n    degree_of_linear_polarization_q = -Q / I\n    degree_of_linear_polarization_u = U / I\n    degree_of_circular_polarization = V / I\n\n    return (\n        I,\n        degree_of_polarization,\n        degree_of_linear_polarization,\n        degree_of_linear_polarization_q,\n        degree_of_linear_polarization_u,\n        degree_of_circular_polarization,\n    )\n</code></pre>"},{"location":"reference/functions/cpu_numba/#functions.cpu_numba.compute_radial_independent_scattered_field","title":"<code>compute_radial_independent_scattered_field</code>","text":"<p>Compute the radial independent scattered field.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_wavelengths</code> <code>int</code> <p>The number of wavelengths.</p> required <code>number_of_angles</code> <code>int</code> <p>The number of angles.</p> required <code>e_phi</code> <code>ndarray</code> <p>The electric field in the phi direction.</p> required <code>e_theta</code> <code>ndarray</code> <p>The electric field in the theta direction.</p> required <code>e_field_theta</code> <code>ndarray</code> <p>The electric field theta component.</p> required <code>e_field_phi</code> <code>ndarray</code> <p>The electric field phi component.</p> required <p>Returns:</p> Name Type Description <code>e_1_sca</code> <code>ndarray</code> <p>The computed radial independent scattered field.</p> Source code in <code>yasfpy/functions/cpu_numba.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True)\ndef compute_radial_independent_scattered_field(\n    number_of_wavelengths: int,\n    number_of_angles: int,\n    e_phi: np.ndarray,\n    e_theta: np.ndarray,\n    e_field_theta: np.ndarray,\n    e_field_phi: np.ndarray,\n):\n    \"\"\"\n    Compute the radial independent scattered field.\n\n    Args:\n        number_of_wavelengths (int): The number of wavelengths.\n        number_of_angles (int): The number of angles.\n        e_phi (np.ndarray): The electric field in the phi direction.\n        e_theta (np.ndarray): The electric field in the theta direction.\n        e_field_theta (np.ndarray): The electric field theta component.\n        e_field_phi (np.ndarray): The electric field phi component.\n\n    Returns:\n        e_1_sca (np.ndarray): The computed radial independent scattered field.\n    \"\"\"\n    e_1_sca = np.zeros(\n        number_of_angles * 3 * number_of_wavelengths, dtype=complex128\n    ).reshape((number_of_angles, 3, number_of_wavelengths))\n\n    for global_idx in prange(number_of_angles * number_of_wavelengths):\n        w = global_idx % number_of_wavelengths\n        a = global_idx // number_of_wavelengths\n\n        e_1_sca[a, :, w] = (\n            e_field_theta[a, w] * e_theta[a, :] + e_field_phi[a, w] * e_phi[a, :]\n        )\n\n    return e_1_sca\n</code></pre>"},{"location":"reference/functions/cpu_numba/#functions.cpu_numba.compute_lookup_tables","title":"<code>compute_lookup_tables</code>","text":"<p>Compute lookup tables for spherical computations.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics.</p> required <code>size_parameter</code> <code>ndarray</code> <p>Array of size parameters.</p> required <code>phi</code> <code>ndarray</code> <p>Array of azimuthal angles.</p> required <code>cosine_theta</code> <code>ndarray</code> <p>Array of cosine of polar angles.</p> required <p>Returns:</p> Name Type Description <code>spherical_bessel</code> <code>ndarray</code> <p>Array of spherical Bessel functions.</p> <code>spherical_hankel</code> <code>ndarray</code> <p>Array of spherical Hankel functions.</p> <code>e_j_dm_phi</code> <code>ndarray</code> <p>Array of exponential terms.</p> <code>p_lm</code> <code>ndarray</code> <p>Array of associated Legendre polynomials.</p> Source code in <code>yasfpy/functions/cpu_numba.py</code> <pre><code>@jit(parallel=True, forceobj=True)\ndef compute_lookup_tables(\n    lmax: int, size_parameter: np.ndarray, phi: np.ndarray, cosine_theta: np.ndarray\n):\n    \"\"\"\n    Compute lookup tables for spherical computations.\n\n    Args:\n        lmax (int): The maximum degree of the spherical harmonics.\n        size_parameter (np.ndarray): Array of size parameters.\n        phi (np.ndarray): Array of azimuthal angles.\n        cosine_theta (np.ndarray): Array of cosine of polar angles.\n\n    Returns:\n        spherical_bessel (np.ndarray): Array of spherical Bessel functions.\n        spherical_hankel (np.ndarray): Array of spherical Hankel functions.\n        e_j_dm_phi (np.ndarray): Array of exponential terms.\n        p_lm (np.ndarray): Array of associated Legendre polynomials.\n    \"\"\"\n    spherical_hankel = np.zeros(\n        (2 * lmax + 1) * np.prod(size_parameter.shape), dtype=complex\n    ).reshape((2 * lmax + 1,) + size_parameter.shape)\n    spherical_bessel = np.zeros_like(spherical_hankel)\n    e_j_dm_phi = np.zeros(\n        (4 * lmax + 1) * np.prod(size_parameter.shape[:2]), dtype=complex\n    ).reshape((4 * lmax + 1,) + size_parameter.shape[:2])\n    p_lm = np.zeros(\n        (lmax + 1) * (2 * lmax + 1) * np.prod(size_parameter.shape[:2])\n    ).reshape(((lmax + 1) * (2 * lmax + 1),) + size_parameter.shape[:2])\n\n    for p in prange(2 * lmax + 1):\n        spherical_hankel[p, :, :, :] = np.sqrt(\n            np.divide(\n                np.pi / 2,\n                size_parameter,\n                out=np.zeros_like(size_parameter),\n                where=size_parameter != 0,\n            )\n        ) * hankel1(p + 1 / 2, size_parameter)\n        spherical_bessel[p, :, :, :] = spherical_jn(p, size_parameter)\n        e_j_dm_phi[p, :, :] = np.exp(1j * (p - 2 * lmax) * phi)\n        e_j_dm_phi[p + 2 * lmax, :, :] = np.exp(1j * p * phi)\n        for absdm in range(p + 1):\n            cml = np.sqrt(\n                (2 * p + 1) / 2 / np.prod(np.arange(p - absdm + 1, p + absdm + 1))\n            )\n            p_lm[p * (p + 1) // 2 + absdm, :, :] = (\n                cml * np.power(-1.0, absdm) * lpmv(absdm, p, cosine_theta)\n            )\n\n    return spherical_bessel, spherical_hankel, e_j_dm_phi, p_lm\n</code></pre>"},{"location":"reference/functions/cpu_numba/#functions.cpu_numba.compute_field","title":"<code>compute_field</code>","text":"<p>Compute the field using the given parameters and coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics.</p> required <code>idx</code> <code>ndarray</code> <p>The index array containing the values of s, n, tau, l, and m.</p> required <code>size_parameter</code> <code>ndarray</code> <p>The size parameter array.</p> required <code>sph_h</code> <code>ndarray</code> <p>The spherical harmonics array.</p> required <code>derivative</code> <code>ndarray</code> <p>The derivative array.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>The e_j_dm_phi array.</p> required <code>p_lm</code> <code>ndarray</code> <p>The p_lm array.</p> required <code>pi_lm</code> <code>ndarray</code> <p>The pi_lm array.</p> required <code>tau_lm</code> <code>ndarray</code> <p>The tau_lm array.</p> required <code>e_r</code> <code>ndarray</code> <p>The e_r array.</p> required <code>e_theta</code> <code>ndarray</code> <p>The e_theta array.</p> required <code>e_phi</code> <code>ndarray</code> <p>The e_phi array.</p> required <code>scattered_field_coefficients</code> <code>ndarray</code> <p>The scattered field coefficients array. Defaults to None.</p> <code>None</code> <code>initial_field_coefficients</code> <code>ndarray</code> <p>The initial field coefficients array. Defaults to None.</p> <code>None</code> <code>scatter_to_internal</code> <code>ndarray</code> <p>The scatter to internal array. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>field</code> <code>ndarray</code> <p>The computed field array.</p> Source code in <code>yasfpy/functions/cpu_numba.py</code> <pre><code>@jit(nopython=True, parallel=True, nogil=True, fastmath=True, cache=True)\ndef compute_field(\n    lmax: int,\n    idx: np.ndarray,\n    size_parameter: np.ndarray,\n    sph_h: np.ndarray,\n    derivative: np.ndarray,\n    e_j_dm_phi: np.ndarray,\n    p_lm: np.ndarray,\n    pi_lm: np.ndarray,\n    tau_lm: np.ndarray,\n    e_r: np.ndarray,\n    e_theta: np.ndarray,\n    e_phi: np.ndarray,\n    scattered_field_coefficients: np.ndarray = None,\n    initial_field_coefficients: np.ndarray = None,\n    scatter_to_internal: np.ndarray = None,\n):\n    \"\"\"\n    Compute the field using the given parameters and coefficients.\n\n    Parameters:\n        lmax (int): The maximum degree of the spherical harmonics.\n        idx (np.ndarray): The index array containing the values of s, n, tau, l, and m.\n        size_parameter (np.ndarray): The size parameter array.\n        sph_h (np.ndarray): The spherical harmonics array.\n        derivative (np.ndarray): The derivative array.\n        e_j_dm_phi (np.ndarray): The e_j_dm_phi array.\n        p_lm (np.ndarray): The p_lm array.\n        pi_lm (np.ndarray): The pi_lm array.\n        tau_lm (np.ndarray): The tau_lm array.\n        e_r (np.ndarray): The e_r array.\n        e_theta (np.ndarray): The e_theta array.\n        e_phi (np.ndarray): The e_phi array.\n        scattered_field_coefficients (np.ndarray, optional): The scattered field coefficients array. Defaults to None.\n        initial_field_coefficients (np.ndarray, optional): The initial field coefficients array. Defaults to None.\n        scatter_to_internal (np.ndarray, optional): The scatter to internal array. Defaults to None.\n\n    Returns:\n        field (np.ndarray): The computed field array.\n    \"\"\"\n    jmax = sph_h.shape[1] * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    field = np.zeros(channels * sph_h.shape[2] * 3, dtype=complex128).reshape(\n        (channels, sph_h.shape[2], 3)\n    )\n\n    if (scattered_field_coefficients is None) and (initial_field_coefficients is None):\n        print(\n            \"At least one, scattered field or initial field coefficients, need to be given.\"\n        )\n        print(\"Returning a zero array\")\n        return field\n\n    for w_idx in prange(2 * lmax * (lmax + 2) * np.prod(np.array(sph_h.shape[1:]))):\n        w = w_idx % channels\n        j_idx = w_idx // channels\n        sampling_idx = j_idx // jmax\n        j_idx = j_idx % jmax\n        s, n, tau, l, m = idx[j_idx, :]\n\n        invariant = (\n            1 / np.sqrt(2 * (l + 1) * l) * e_j_dm_phi[m + 2 * lmax, s, sampling_idx]\n        )\n        # Calculate M\n        if tau == 1:\n            c_term_1 = (\n                1j\n                * m\n                * pi_lm[l, np.abs(m), s, sampling_idx]\n                * e_theta[s, sampling_idx, :]\n            )\n            c_term_2 = tau_lm[l, np.abs(m), s, sampling_idx] * e_phi[s, sampling_idx, :]\n            c_term = sph_h[l, s, sampling_idx, w] * (c_term_1 - c_term_2)\n\n            field[w, sampling_idx, :] += (\n                scattered_field_coefficients[s, n, w] * invariant * c_term\n            )\n        # Calculate N\n        else:\n            p_term = (\n                l\n                * (l + 1)\n                / size_parameter[s, sampling_idx, w]\n                * sph_h[l, s, sampling_idx, w]\n                * p_lm[l, np.abs(m), s, sampling_idx]\n                * e_r[s, sampling_idx, :]\n            )\n            #   p_term = l * (l + 1) / size_parameter[s, sampling_idx, w]\n            #   p_term *= sph_h[l, s, sampling_idx, w]\n            #   p_term *= p_lm[l, np.abs(m), s, sampling_idx]\n            #   p_term *= e_r[s, sampling_idx, :]\n\n            b_term_1 = (\n                derivative[l, s, sampling_idx, w] / size_parameter[s, sampling_idx, w]\n            )\n            b_term_2 = (\n                tau_lm[l, np.abs(m), s, sampling_idx] * e_theta[s, sampling_idx, :]\n            )\n            b_term_3 = (\n                1j\n                * m\n                * pi_lm[l, np.abs(m), s, sampling_idx]\n                * e_phi[s, sampling_idx, :]\n            )\n            b_term = b_term_1 * (b_term_2 + b_term_3)\n\n            field[w, sampling_idx, :] += (\n                scattered_field_coefficients[s, n, w] * invariant * (p_term + b_term)\n            )\n\n    return field\n</code></pre>"},{"location":"reference/functions/cuda_numba/","title":"Cuda Numba","text":""},{"location":"reference/functions/cuda_numba/#functions.cuda_numba.particle_interaction_gpu","title":"<code>particle_interaction_gpu</code>","text":"<p>Perform particle interaction calculations on the GPU.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>Maximum angular momentum quantum number.</p> required <code>particle_number</code> <code>int</code> <p>Number of particles.</p> required <code>idx</code> <code>ndarray</code> <p>Array containing particle indices.</p> required <code>x</code> <code>ndarray</code> <p>Array of particle positions.</p> required <code>wx_real</code> <code>ndarray</code> <p>Array to store the real part of the result.</p> required <code>wx_imag</code> <code>ndarray</code> <p>Array to store the imaginary part of the result.</p> required <code>translation_table</code> <code>ndarray</code> <p>Array containing translation table.</p> required <code>plm</code> <code>ndarray</code> <p>Array containing associated Legendre polynomials.</p> required <code>sph_h</code> <code>ndarray</code> <p>Array containing spherical harmonics.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>Additional parameter for the calculation.</p> required Todo <p>Implement data batching for GPUs with smaller memory</p> Source code in <code>yasfpy/functions/cuda_numba.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef particle_interaction_gpu(\n    lmax: int,\n    particle_number: int,\n    idx: np.ndarray,\n    x: np.ndarray,\n    wx_real: np.ndarray,\n    wx_imag: np.ndarray,\n    translation_table: np.ndarray,\n    plm: np.ndarray,\n    sph_h: np.ndarray,\n    e_j_dm_phi,\n):\n    \"\"\"\n    Perform particle interaction calculations on the GPU.\n\n    Args:\n        lmax (int): Maximum angular momentum quantum number.\n        particle_number (int): Number of particles.\n        idx (np.ndarray): Array containing particle indices.\n        x (np.ndarray): Array of particle positions.\n        wx_real (np.ndarray): Array to store the real part of the result.\n        wx_imag (np.ndarray): Array to store the imaginary part of the result.\n        translation_table (np.ndarray): Array containing translation table.\n        plm (np.ndarray): Array containing associated Legendre polynomials.\n        sph_h (np.ndarray): Array containing spherical harmonics.\n        e_j_dm_phi (np.ndarray): Additional parameter for the calculation.\n\n    Todo:\n        Implement data batching for GPUs with smaller memory\n    \"\"\"\n    j1, j2, w = cuda.grid(3)\n\n    jmax = particle_number * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    if (j1 &gt;= jmax) or (j2 &gt;= jmax) or (w &gt;= channels):\n        return\n\n    s1, n1, tau1, l1, m1 = idx[j1, :]\n    s2, n2, tau2, l2, m2 = idx[j2, :]\n\n    if s1 == s2:\n        return\n\n    delta_tau = abs(tau1 - tau2)\n    delta_l = abs(l1 - l2)\n    delta_m = abs(m1 - m2)\n\n    p_dependent = complex(0)\n    for p in range(max(delta_m, delta_l + delta_tau), l1 + l2 + 1):\n        p_dependent += (\n            translation_table[n2, n1, p]\n            * plm[p * (p + 1) // 2 + delta_m, s1, s2]\n            * sph_h[p, s1, s2, w]\n        )\n    p_dependent *= e_j_dm_phi[m2 - m1 + 2 * lmax, s1, s2] * x[j2]\n\n    # atomic.add performs the += operation in sync\n    cuda.atomic.add(wx_real, (j1, w), p_dependent.real)\n    cuda.atomic.add(wx_imag, (j1, w), p_dependent.imag)\n</code></pre>"},{"location":"reference/functions/cuda_numba/#functions.cuda_numba.compute_scattering_cross_section_gpu","title":"<code>compute_scattering_cross_section_gpu</code>","text":"<p>Compute the scattering cross section on the GPU using CUDA.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics expansion.</p> required <code>particle_number</code> <code>int</code> <p>The number of particles.</p> required <code>idx</code> <code>ndarray</code> <p>The index array.</p> required <code>sfc</code> <code>ndarray</code> <p>The scattering form factor array.</p> required <code>translation_table</code> <code>ndarray</code> <p>The translation table array.</p> required <code>plm</code> <code>ndarray</code> <p>The associated Legendre polynomials array.</p> required <code>sph_h</code> <code>ndarray</code> <p>The spherical harmonics array.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>The phase factor array.</p> required <code>c_sca_real</code> <code>ndarray</code> <p>The real part of the scattering cross section array.</p> required <code>c_sca_imag</code> <code>ndarray</code> <p>The imaginary part of the scattering cross section array.</p> required Source code in <code>yasfpy/functions/cuda_numba.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef compute_scattering_cross_section_gpu(\n    lmax: int,\n    particle_number: int,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    translation_table: np.ndarray,\n    plm: np.ndarray,\n    sph_h: np.ndarray,\n    e_j_dm_phi: np.ndarray,\n    c_sca_real: np.ndarray,\n    c_sca_imag: np.ndarray,\n):\n    \"\"\"\n    Compute the scattering cross section on the GPU using CUDA.\n\n    Args:\n        lmax (int): The maximum degree of the spherical harmonics expansion.\n        particle_number (int): The number of particles.\n        idx (np.ndarray): The index array.\n        sfc (np.ndarray): The scattering form factor array.\n        translation_table (np.ndarray): The translation table array.\n        plm (np.ndarray): The associated Legendre polynomials array.\n        sph_h (np.ndarray): The spherical harmonics array.\n        e_j_dm_phi (np.ndarray): The phase factor array.\n        c_sca_real (np.ndarray): The real part of the scattering cross section array.\n        c_sca_imag (np.ndarray): The imaginary part of the scattering cross section array.\n    \"\"\"\n    jmax = particle_number * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    j1, j2, w = cuda.grid(3)\n\n    if (j1 &gt;= jmax) or (j2 &gt;= jmax) or (w &gt;= channels):\n        return\n\n    s1, n1, _, _, m1 = idx[j1, :]\n    s2, n2, _, _, m2 = idx[j2, :]\n\n    delta_m = abs(m1 - m2)\n\n    p_dependent = complex(0)\n    # for p in range(delta_m, 2 * lmax + 1):\n    for p in range(delta_m, m1 + m2 + 1):\n        p_dependent += (\n            # translation_table[n2, n1, p]\n            translation_table[n1, n2, p]\n            * plm[p * (p + 1) // 2 + delta_m, s1, s2]\n            * sph_h[p, s1, s2, w]\n        )\n    p_dependent *= (\n        sfc[s1, n1, w].conjugate()\n        * e_j_dm_phi[m1 - m2 + 2 * lmax, s1, s2]\n        * sfc[s2, n2, w]\n    )\n\n    # atomic.add performs the += operation in sync\n    cuda.atomic.add(c_sca_real, (j1, w), p_dependent.real)\n    cuda.atomic.add(c_sca_imag, (j1, w), p_dependent.imag)\n</code></pre>"},{"location":"reference/functions/cuda_numba/#functions.cuda_numba.compute_radial_independent_scattered_field_gpu","title":"<code>compute_radial_independent_scattered_field_gpu</code>","text":"<p>Compute the radial independent scattered field using GPU acceleration.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics expansion.</p> required <code>particles_position</code> <code>ndarray</code> <p>Array of particle positions.</p> required <code>idx</code> <code>ndarray</code> <p>Array of indices for particle properties.</p> required <code>sfc</code> <code>ndarray</code> <p>Array of scattering form factors.</p> required <code>k_medium</code> <code>ndarray</code> <p>Array of wave numbers in the medium.</p> required <code>azimuthal_angles</code> <code>ndarray</code> <p>Array of azimuthal angles.</p> required <code>e_r</code> <code>ndarray</code> <p>Array of radial electric field components.</p> required <code>e_phi</code> <code>ndarray</code> <p>Array of azimuthal electric field components.</p> required <code>e_theta</code> <code>ndarray</code> <p>Array of polar electric field components.</p> required <code>pilm</code> <code>ndarray</code> <p>Array of associated Legendre polynomials.</p> required <code>taulm</code> <code>ndarray</code> <p>Array of tau coefficients.</p> required <code>e_1_sca_real</code> <code>ndarray</code> <p>Array of real parts of the scattered electric field.</p> required <code>e_1_sca_imag</code> <code>ndarray</code> <p>Array of imaginary parts of the scattered electric field.</p> required Source code in <code>yasfpy/functions/cuda_numba.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef compute_radial_independent_scattered_field_gpu(\n    lmax: int,\n    particles_position: np.ndarray,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    k_medium: np.ndarray,\n    azimuthal_angles: np.ndarray,\n    e_r: np.ndarray,\n    e_phi: np.ndarray,\n    e_theta: np.ndarray,\n    pilm: np.ndarray,\n    taulm: np.ndarray,\n    e_1_sca_real: np.ndarray,\n    e_1_sca_imag: np.ndarray,\n):\n    \"\"\"\n    Compute the radial independent scattered field using GPU acceleration.\n\n    Args:\n        lmax (int): The maximum degree of the spherical harmonics expansion.\n        particles_position (np.ndarray): Array of particle positions.\n        idx (np.ndarray): Array of indices for particle properties.\n        sfc (np.ndarray): Array of scattering form factors.\n        k_medium (np.ndarray): Array of wave numbers in the medium.\n        azimuthal_angles (np.ndarray): Array of azimuthal angles.\n        e_r (np.ndarray): Array of radial electric field components.\n        e_phi (np.ndarray): Array of azimuthal electric field components.\n        e_theta (np.ndarray): Array of polar electric field components.\n        pilm (np.ndarray): Array of associated Legendre polynomials.\n        taulm (np.ndarray): Array of tau coefficients.\n        e_1_sca_real (np.ndarray): Array of real parts of the scattered electric field.\n        e_1_sca_imag (np.ndarray): Array of imaginary parts of the scattered electric field.\n    \"\"\"\n    j_idx, a_idx, w_idx = cuda.grid(3)\n\n    jmax = particles_position.shape[0] * 2 * lmax * (lmax + 2)\n\n    if (j_idx &gt;= jmax) or (a_idx &gt;= azimuthal_angles.size) or (w_idx &gt;= k_medium.size):\n        return\n\n    s, n, tau, l, m = idx[j_idx, :]\n\n    # Temporary variable\n    # If tau = 1 -&gt; 1j**(tau-1) = 1, if tau = 2 -&gt; 1j**(tau-1) = 1j\n    # 1j**(-l-1) = (-1j)**(l+1) =&gt; both lead to the coefficient 1j**(tau-l-2)\n    # k * &lt;particle_position, e_r&gt; is the phase shift due to the distance and relative position\n    t = (\n        1j ** (tau - l - 2)\n        * sfc[s, n, w_idx]\n        / sqrt(2 * l * (l + 1))\n        * exp(\n            1j\n            * (\n                m * azimuthal_angles[a_idx]\n                - k_medium[w_idx]\n                * (\n                    particles_position[s, 0] * e_r[a_idx, 0]\n                    + particles_position[s, 1] * e_r[a_idx, 1]\n                    + particles_position[s, 2] * e_r[a_idx, 2]\n                )\n            )\n        )\n    )\n\n    for c in range(3):\n        if tau == 1:\n            e_1_sca = t * (\n                e_theta[a_idx, c] * pilm[l, abs(m), a_idx] * 1j * m\n                - e_phi[a_idx, c] * taulm[l, abs(m), a_idx]\n            )\n        else:\n            e_1_sca = t * (\n                e_phi[a_idx, c] * pilm[l, abs(m), a_idx] * 1j * m\n                + e_theta[a_idx, c] * taulm[l, abs(m), a_idx]\n            )\n\n        cuda.atomic.add(e_1_sca_real, (a_idx, c, w_idx), e_1_sca.real)\n        cuda.atomic.add(e_1_sca_imag, (a_idx, c, w_idx), e_1_sca.imag)\n</code></pre>"},{"location":"reference/functions/cuda_numba/#functions.cuda_numba.compute_electric_field_angle_components_gpu","title":"<code>compute_electric_field_angle_components_gpu</code>","text":"<p>Compute the electric field angle components on the GPU.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum angular momentum quantum number.</p> required <code>particles_position</code> <code>ndarray</code> <p>Array of particle positions.</p> required <code>idx</code> <code>ndarray</code> <p>Array of indices.</p> required <code>sfc</code> <code>ndarray</code> <p>Array of scattering form factors.</p> required <code>k_medium</code> <code>ndarray</code> <p>Array of medium wavevectors.</p> required <code>azimuthal_angles</code> <code>ndarray</code> <p>Array of azimuthal angles.</p> required <code>e_r</code> <code>ndarray</code> <p>Array of radial unit vectors.</p> required <code>pilm</code> <code>ndarray</code> <p>Array of associated Legendre polynomials.</p> required <code>taulm</code> <code>ndarray</code> <p>Array of tau coefficients.</p> required <code>e_field_theta_real</code> <code>ndarray</code> <p>Array of real parts of electric field theta component.</p> required <code>e_field_theta_imag</code> <code>ndarray</code> <p>Array of imaginary parts of electric field theta component.</p> required <code>e_field_phi_real</code> <code>ndarray</code> <p>Array of real parts of electric field phi component.</p> required <code>e_field_phi_imag</code> <code>ndarray</code> <p>Array of imaginary parts of electric field phi component.</p> required Source code in <code>yasfpy/functions/cuda_numba.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef compute_electric_field_angle_components_gpu(\n    lmax: int,\n    particles_position: np.ndarray,\n    idx: np.ndarray,\n    sfc: np.ndarray,\n    k_medium: np.ndarray,\n    azimuthal_angles: np.ndarray,\n    e_r: np.ndarray,\n    pilm: np.ndarray,\n    taulm: np.ndarray,\n    e_field_theta_real: np.ndarray,\n    e_field_theta_imag: np.ndarray,\n    e_field_phi_real: np.ndarray,\n    e_field_phi_imag: np.ndarray,\n):\n    \"\"\"\n    Compute the electric field angle components on the GPU.\n\n    Args:\n        lmax (int): The maximum angular momentum quantum number.\n        particles_position (np.ndarray): Array of particle positions.\n        idx (np.ndarray): Array of indices.\n        sfc (np.ndarray): Array of scattering form factors.\n        k_medium (np.ndarray): Array of medium wavevectors.\n        azimuthal_angles (np.ndarray): Array of azimuthal angles.\n        e_r (np.ndarray): Array of radial unit vectors.\n        pilm (np.ndarray): Array of associated Legendre polynomials.\n        taulm (np.ndarray): Array of tau coefficients.\n        e_field_theta_real (np.ndarray): Array of real parts of electric field theta component.\n        e_field_theta_imag (np.ndarray): Array of imaginary parts of electric field theta component.\n        e_field_phi_real (np.ndarray): Array of real parts of electric field phi component.\n        e_field_phi_imag (np.ndarray): Array of imaginary parts of electric field phi component.\n    \"\"\"\n    j_idx, a_idx, w_idx = cuda.grid(3)\n    jmax = particles_position.shape[0] * 2 * lmax * (lmax + 2)\n    if (j_idx &gt;= jmax) or (a_idx &gt;= azimuthal_angles.size) or (w_idx &gt;= k_medium.size):\n        return\n\n    s, n, tau, l, m = idx[j_idx, :]\n\n    t = (\n        1j ** (tau - l - 2)\n        * sfc[s, n, w_idx]\n        / sqrt(2 * l * (l + 1))\n        * exp(\n            1j\n            * (\n                m * azimuthal_angles[a_idx]\n                - k_medium[w_idx]\n                * (\n                    particles_position[s, 0] * e_r[a_idx, 0]\n                    + particles_position[s, 1] * e_r[a_idx, 1]\n                    + particles_position[s, 2] * e_r[a_idx, 2]\n                )\n            )\n        )\n    )\n\n    if tau == 1:\n        e_field_theta = t * pilm[l, abs(m), a_idx] * 1j * m\n        e_field_phi = -t * taulm[l, abs(m), a_idx]\n    else:\n        e_field_theta = t * taulm[l, abs(m), a_idx]\n        e_field_phi = t * pilm[l, abs(m), a_idx] * 1j * m\n\n    cuda.atomic.add(e_field_theta_real, (a_idx, w_idx), e_field_theta.real)\n    cuda.atomic.add(e_field_theta_imag, (a_idx, w_idx), e_field_theta.imag)\n    cuda.atomic.add(e_field_phi_real, (a_idx, w_idx), e_field_phi.real)\n    cuda.atomic.add(e_field_phi_imag, (a_idx, w_idx), e_field_phi.imag)\n</code></pre>"},{"location":"reference/functions/cuda_numba/#functions.cuda_numba.compute_polarization_components_gpu","title":"<code>compute_polarization_components_gpu</code>","text":"<p>Compute the polarization components using GPU acceleration.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_wavelengths</code> <code>int</code> <p>Number of wavelengths.</p> required <code>number_of_angles</code> <code>int</code> <p>Number of angles.</p> required <code>e_field_theta_real</code> <code>ndarray</code> <p>Real part of the electric field in the theta direction.</p> required <code>e_field_theta_imag</code> <code>ndarray</code> <p>Imaginary part of the electric field in the theta direction.</p> required <code>e_field_phi_real</code> <code>ndarray</code> <p>Real part of the electric field in the phi direction.</p> required <code>e_field_phi_imag</code> <code>ndarray</code> <p>Imaginary part of the electric field in the phi direction.</p> required <code>intensity</code> <code>ndarray</code> <p>Array to store the intensity component.</p> required <code>degree_of_polarization</code> <code>ndarray</code> <p>Array to store the degree of polarization component.</p> required <code>degree_of_linear_polarization</code> <code>ndarray</code> <p>Array to store the degree of linear polarization component.</p> required <code>degree_of_linear_polarization_q</code> <code>ndarray</code> <p>Array to store the degree of linear polarization (Q) component.</p> required <code>degree_of_linear_polarization_u</code> <code>ndarray</code> <p>Array to store the degree of linear polarization (U) component.</p> required <code>degree_of_circular_polarization</code> <code>ndarray</code> <p>Array to store the degree of circular polarization component.</p> required Source code in <code>yasfpy/functions/cuda_numba.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef compute_polarization_components_gpu(\n    number_of_wavelengths: int,\n    number_of_angles: int,\n    e_field_theta_real: np.ndarray,\n    e_field_theta_imag: np.ndarray,\n    e_field_phi_real: np.ndarray,\n    e_field_phi_imag: np.ndarray,\n    intensity: np.ndarray,\n    degree_of_polarization: np.ndarray,\n    degree_of_linear_polarization: np.ndarray,\n    degree_of_linear_polarization_q: np.ndarray,\n    degree_of_linear_polarization_u: np.ndarray,\n    degree_of_circular_polarization: np.ndarray,\n):\n    \"\"\"\n    Compute the polarization components using GPU acceleration.\n\n    Args:\n        number_of_wavelengths (int): Number of wavelengths.\n        number_of_angles (int): Number of angles.\n        e_field_theta_real (np.ndarray): Real part of the electric field in the theta direction.\n        e_field_theta_imag (np.ndarray): Imaginary part of the electric field in the theta direction.\n        e_field_phi_real (np.ndarray): Real part of the electric field in the phi direction.\n        e_field_phi_imag (np.ndarray): Imaginary part of the electric field in the phi direction.\n        intensity (np.ndarray): Array to store the intensity component.\n        degree_of_polarization (np.ndarray): Array to store the degree of polarization component.\n        degree_of_linear_polarization (np.ndarray): Array to store the degree of linear polarization component.\n        degree_of_linear_polarization_q (np.ndarray): Array to store the degree of linear polarization (Q) component.\n        degree_of_linear_polarization_u (np.ndarray): Array to store the degree of linear polarization (U) component.\n        degree_of_circular_polarization (np.ndarray): Array to store the degree of circular polarization component.\n    \"\"\"\n    a_idx, w_idx = cuda.grid(2)\n    if (w_idx &gt;= number_of_wavelengths) or (a_idx &gt;= number_of_angles):\n        return\n\n    # Jones vector components (1,2,4)\n    e_field_theta_abs = (\n        e_field_theta_real[a_idx, w_idx] ** 2 + e_field_theta_imag[a_idx, w_idx] ** 2\n    )\n    e_field_phi_abs = (\n        e_field_phi_real[a_idx, w_idx] ** 2 + e_field_phi_imag[a_idx, w_idx] ** 2\n    )\n    e_field_angle_interaction_real = (\n        e_field_theta_real[a_idx, w_idx] * e_field_phi_real[a_idx, w_idx]\n        + e_field_theta_imag[a_idx, w_idx] * e_field_phi_imag[a_idx, w_idx]\n    )\n    e_field_angle_interaction_imag = (\n        e_field_theta_imag[a_idx, w_idx] * e_field_phi_real[a_idx, w_idx]\n        - e_field_theta_real[a_idx, w_idx] * e_field_phi_imag[a_idx, w_idx]\n    )\n\n    # Stokes components S = (I, Q, U, V)\n    I = e_field_theta_abs + e_field_phi_abs\n    Q = e_field_theta_abs - e_field_phi_abs\n    U = -2 * e_field_angle_interaction_real\n    V = 2 * e_field_angle_interaction_imag\n\n    intensity[a_idx, w_idx] = I\n    degree_of_polarization[a_idx, w_idx] = sqrt(Q**2 + U**2 + V**2).real / I\n    degree_of_linear_polarization[a_idx, w_idx] = sqrt(Q**2 + U**2).real / I\n    degree_of_linear_polarization_q[a_idx, w_idx] = -Q.real / I\n    degree_of_linear_polarization_u[a_idx, w_idx] = U.real / I\n    degree_of_circular_polarization[a_idx, w_idx] = V / I\n</code></pre>"},{"location":"reference/functions/cuda_numba/#functions.cuda_numba.compute_field_gpu","title":"<code>compute_field_gpu</code>","text":"<p>Compute the field on the GPU using CUDA.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>Maximum degree of the spherical harmonics.</p> required <code>idx</code> <code>ndarray</code> <p>Array of indices.</p> required <code>size_parameter</code> <code>ndarray</code> <p>Array of size parameters.</p> required <code>sph_h</code> <code>ndarray</code> <p>Array of spherical harmonics.</p> required <code>derivative</code> <code>ndarray</code> <p>Array of derivatives.</p> required <code>e_j_dm_phi</code> <code>ndarray</code> <p>Array of phi-dependent terms.</p> required <code>p_lm</code> <code>ndarray</code> <p>Array of Legendre polynomials.</p> required <code>pi_lm</code> <code>ndarray</code> <p>Array of pi-dependent terms.</p> required <code>tau_lm</code> <code>ndarray</code> <p>Array of tau-dependent terms.</p> required <code>e_r</code> <code>ndarray</code> <p>Array of r-dependent terms.</p> required <code>e_theta</code> <code>ndarray</code> <p>Array of theta-dependent terms.</p> required <code>e_phi</code> <code>ndarray</code> <p>Array of phi-dependent terms.</p> required <code>scattered_field_coefficients</code> <code>ndarray</code> <p>Array of scattered field coefficients.</p> required <code>field_real</code> <code>ndarray</code> <p>Array to store the real part of the field.</p> required <code>field_imag</code> <code>ndarray</code> <p>Array to store the imaginary part of the field.</p> required Source code in <code>yasfpy/functions/cuda_numba.py</code> <pre><code>@cuda.jit(fastmath=True)\ndef compute_field_gpu(\n    lmax: int,\n    idx: np.ndarray,\n    size_parameter: np.ndarray,\n    sph_h: np.ndarray,\n    derivative: np.ndarray,\n    e_j_dm_phi: np.ndarray,\n    p_lm: np.ndarray,\n    pi_lm: np.ndarray,\n    tau_lm: np.ndarray,\n    e_r: np.ndarray,\n    e_theta: np.ndarray,\n    e_phi: np.ndarray,\n    scattered_field_coefficients: np.ndarray,\n    field_real: np.ndarray,\n    field_imag: np.ndarray,\n):  # , initial_field_coefficients: np.ndarray, scatter_to_internal: np.ndarray):\n    \"\"\"\n    Compute the field on the GPU using CUDA.\n\n    Args:\n        lmax (int): Maximum degree of the spherical harmonics.\n        idx (np.ndarray): Array of indices.\n        size_parameter (np.ndarray): Array of size parameters.\n        sph_h (np.ndarray): Array of spherical harmonics.\n        derivative (np.ndarray): Array of derivatives.\n        e_j_dm_phi (np.ndarray): Array of phi-dependent terms.\n        p_lm (np.ndarray): Array of Legendre polynomials.\n        pi_lm (np.ndarray): Array of pi-dependent terms.\n        tau_lm (np.ndarray): Array of tau-dependent terms.\n        e_r (np.ndarray): Array of r-dependent terms.\n        e_theta (np.ndarray): Array of theta-dependent terms.\n        e_phi (np.ndarray): Array of phi-dependent terms.\n        scattered_field_coefficients (np.ndarray): Array of scattered field coefficients.\n        field_real (np.ndarray): Array to store the real part of the field.\n        field_imag (np.ndarray): Array to store the imaginary part of the field.\n    \"\"\"\n    jmax = sph_h.shape[1] * 2 * lmax * (lmax + 2)\n    channels = sph_h.shape[-1]\n\n    sampling_idx, j_idx, w = cuda.grid(3)\n\n    if (sampling_idx &gt;= sph_h.shape[2]) or (j_idx &gt;= jmax) or (w &gt;= channels):\n        return\n\n    particle_idx, n, tau, l, m = idx[j_idx, :]\n\n    invariant = (\n        1 / sqrt(2 * (l + 1) * l) * e_j_dm_phi[m + 2 * lmax, particle_idx, sampling_idx]\n    )\n\n    for c in range(3):\n        term = scattered_field_coefficients[particle_idx, n, w] * invariant\n\n        # Calculate M\n        if tau == 1:\n            c_term_1 = (\n                pi_lm[l, abs(m), particle_idx, sampling_idx]\n                * e_theta[particle_idx, sampling_idx, c]\n                * 1j\n                * m\n            )\n            c_term_2 = (\n                tau_lm[l, abs(m), particle_idx, sampling_idx]\n                * e_phi[particle_idx, sampling_idx, c]\n            )\n            c_term = sph_h[l, particle_idx, sampling_idx, w] * (c_term_1 - c_term_2)\n\n            term *= c_term\n\n        # Calculate N\n        else:\n            p_term = (\n                l\n                * (l + 1)\n                / size_parameter[particle_idx, sampling_idx, w]\n                * sph_h[l, particle_idx, sampling_idx, w]\n            )\n            p_term *= (\n                p_lm[l, abs(m), particle_idx, sampling_idx]\n                * e_r[particle_idx, sampling_idx, c]\n            )\n\n            b_term_1 = (\n                derivative[l, particle_idx, sampling_idx, w]\n                / size_parameter[particle_idx, sampling_idx, w]\n            )\n            b_term_2 = (\n                tau_lm[l, abs(m), particle_idx, sampling_idx]\n                * e_theta[particle_idx, sampling_idx, c]\n            )\n            b_term_3 = (\n                pi_lm[l, abs(m), particle_idx, sampling_idx]\n                * e_phi[particle_idx, sampling_idx, c]\n                * 1j\n                * m\n            )\n            b_term = b_term_1 * (b_term_2 + b_term_3)\n\n            term *= p_term + b_term\n\n        cuda.atomic.add(field_real, (w, sampling_idx, c), term.real)\n        cuda.atomic.add(field_imag, (w, sampling_idx, c), term.imag)\n</code></pre>"},{"location":"reference/functions/legendre_normalized_trigon/","title":"Legendre Normalized Trigon","text":""},{"location":"reference/functions/legendre_normalized_trigon/#functions.legendre_normalized_trigon.legendre_normalized_trigon","title":"<code>legendre_normalized_trigon</code>","text":"<p>Compute the normalized Legendre polynomials of the first kind for trigonometric arguments.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the Legendre polynomials.</p> required <code>x</code> <code>ndarray</code> <p>The input array of x-coordinates.</p> required <code>y</code> <code>ndarray</code> <p>The input array of y-coordinates. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>plm</code> <code>ndarray</code> <p>The array of computed Legendre polynomials.</p> Note <p>Base on the celes implementation of legendre_normalized_trigon.m</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lmax = 2\n&gt;&gt;&gt; x = np.array([0, np.pi/4, np.pi/2])\n&gt;&gt;&gt; y = np.array([0, 1, 0])\n&gt;&gt;&gt; result = legendre_normalized_trigon(lmax, x, y)\n&gt;&gt;&gt; print(result)\narray([[[ 0.70710678,  0.        ,  0.        ],\n        [ 0.        ,  0.        ,  0.        ],\n        [ 0.        ,  0.        ,  0.        ]],\n       [[ 0.        ,  0.        ,  0.        ],\n        [ 0.        ,  0.70710678,  0.        ],\n        [ 0.        ,  0.        ,  0.        ]],\n       [[ 0.        ,  0.        ,  0.        ],\n        [ 0.        ,  0.        ,  0.        ],\n        [ 0.        ,  0.        ,  0.70710678]]])\n</code></pre> Source code in <code>yasfpy/functions/legendre_normalized_trigon.py</code> <pre><code>def legendre_normalized_trigon(lmax, x: np.ndarray, y: np.ndarray = None):\n    \"\"\"\n    Compute the normalized Legendre polynomials of the first kind for trigonometric arguments.\n\n    Args:\n        lmax (int): The maximum degree of the Legendre polynomials.\n        x (np.ndarray): The input array of x-coordinates.\n        y (np.ndarray, optional): The input array of y-coordinates. Defaults to None.\n\n    Returns:\n        plm (np.ndarray): The array of computed Legendre polynomials.\n\n    Note:\n        Base on the celes implementation of [legendre_normalized_trigon.m](https://github.com/disordered-photonics/celes/blob/master/src/mathematics/legendre_normalized_trigon.m){:target=\"_blank\"}\n\n    Examples:\n        &gt;&gt;&gt; lmax = 2\n        &gt;&gt;&gt; x = np.array([0, np.pi/4, np.pi/2])\n        &gt;&gt;&gt; y = np.array([0, 1, 0])\n        &gt;&gt;&gt; result = legendre_normalized_trigon(lmax, x, y)\n        &gt;&gt;&gt; print(result)\n        array([[[ 0.70710678,  0.        ,  0.        ],\n                [ 0.        ,  0.        ,  0.        ],\n                [ 0.        ,  0.        ,  0.        ]],\n               [[ 0.        ,  0.        ,  0.        ],\n                [ 0.        ,  0.70710678,  0.        ],\n                [ 0.        ,  0.        ,  0.        ]],\n               [[ 0.        ,  0.        ,  0.        ],\n                [ 0.        ,  0.        ,  0.        ],\n                [ 0.        ,  0.        ,  0.70710678]]])\n    \"\"\"\n    #   if not(isinstance(x, np.ndarray) or np.isscalar(x) or isinstance(x, list)):\n    #     return legendre_normalized_trigon_legacy(x, y, lmax)\n\n    #   if np.isscalar(x):\n    #     x = np.array([x])\n    #   elif isinstance(x, list):\n    #     x = np.array(x)\n    size = x.shape\n    if y is None:\n        x = np.ravel(x)\n        ct = np.cos(x)\n        st = np.sin(x)\n    else:\n        ct = x.ravel()\n        st = y.ravel()\n\n    plm = np.zeros((lmax + 1, lmax + 1, ct.size)) * np.nan\n\n    plm[0, 0, :] = np.sqrt(1 / 2) * np.ones_like(ct)\n    plm[1, 0, :] = np.sqrt(3 / 2) * ct\n\n    for l in range(1, lmax):\n        plm[l + 1, 0, :] = (\n            1 / (l + 1) * np.sqrt((2 * l + 1) * (2 * l + 3)) * plm[l, 0, :] * ct\n            - l / (l + 1) * np.sqrt((2 * l + 3) / (2 * l - 1)) * plm[l - 1, 0, :]\n        )\n\n    for m in range(1, lmax + 1):\n        plm[m - 1, m, :] = np.zeros_like(ct)\n        plm[m, m, :] = (\n            np.sqrt((2 * m + 1) / 2 / np.math.factorial(2 * m))\n            * np.prod(np.arange(1, 2 * m, 2))\n            * np.power(st, m)\n        )\n        for l in range(m, lmax):\n            plm[l + 1, m, :] = (\n                np.sqrt((2 * l + 1) * (2 * l + 3) / (l + 1 - m) / (l + 1 + m))\n                * ct\n                * plm[l, m, :]\n                - np.sqrt(\n                    (2 * l + 3)\n                    * (l - m)\n                    * (l + m)\n                    / (2 * l - 1)\n                    / (l + 1 - m)\n                    / (l + 1 + m)\n                )\n                * plm[l - 1, m, :]\n            )\n\n    plm = np.reshape(plm, np.concatenate(([lmax + 1, lmax + 1], size)))\n\n    return plm\n</code></pre>"},{"location":"reference/functions/legendre_normalized_trigon/#functions.legendre_normalized_trigon.legendre_normalized_trigon_legacy","title":"<code>legendre_normalized_trigon_legacy</code>","text":"<p>Calculate the normalized Legendre polynomials for trigonometric functions.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or Symbol</code> <p>The input variable x.</p> required <code>y</code> <code>float or Symbol</code> <p>The input variable y. Defaults to None.</p> <code>None</code> <code>lmax</code> <code>int</code> <p>The maximum degree of the Legendre polynomials. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>plm</code> <code>ndarray</code> <p>The matrix of Legendre polynomials.</p> Source code in <code>yasfpy/functions/legendre_normalized_trigon.py</code> <pre><code>def legendre_normalized_trigon_legacy(x, y=None, lmax=4):\n    \"\"\"\n    Calculate the normalized Legendre polynomials for trigonometric functions.\n\n    Args:\n        x (float or sympy.core.symbol.Symbol): The input variable x.\n        y (float or sympy.core.symbol.Symbol, optional): The input variable y. Defaults to None.\n        lmax (int, optional): The maximum degree of the Legendre polynomials. Defaults to 4.\n\n    Returns:\n        plm (numpy.ndarray): The matrix of Legendre polynomials.\n\n    \"\"\"\n    import sympy as sym\n\n    plm = sym.zeros(lmax + 1, lmax + 1)\n    if y is None:\n        ct = sym.cos(x)\n        st = sym.sin(x)\n    elif isinstance(x, sym.core.symbol.Symbol) and isinstance(\n        y, sym.core.symbol.Symbol\n    ):\n        ct = x\n        st = y\n    else:\n        ct = sym.Symbol(\"ct\")\n        st = sym.Symbol(\"st\")\n\n    plm[0, 0] = np.sqrt(1 / 2)\n    plm[1, 0] = np.sqrt(3 / 2) * ct\n\n    for l in range(1, lmax):\n        plm[l + 1, 0] = (\n            1 / (l + 1) * np.sqrt((2 * l + 1) * (2 * l + 3)) * plm[l, 0] * ct\n            - l / (l + 1) * np.sqrt((2 * l + 3) / (2 * l - 1)) * plm[l - 1, 0]\n        )\n\n    for m in range(1, lmax + 1):\n        plm[m - 1, m] = np.zeros_like(ct)\n        plm[m, m] = (\n            np.sqrt((2 * m + 1) / 2 / np.math.factorial(2 * m))\n            * np.prod(np.arange(1, 2 * m, 2))\n            * st**m\n        )\n        for l in range(m, lmax):\n            plm[l + 1, m] = (\n                np.sqrt((2 * l + 1) * (2 * l + 3) / (l + 1 - m) / (l + 1 + m))\n                * ct\n                * plm[l, m]\n                - np.sqrt(\n                    (2 * l + 3)\n                    * (l - m)\n                    * (l + m)\n                    / (2 * l - 1)\n                    / (l + 1 - m)\n                    / (l + 1 + m)\n                )\n                * plm[l - 1, m]\n            )\n\n    return plm\n</code></pre>"},{"location":"reference/functions/material_handler/","title":"Material Handler","text":""},{"location":"reference/functions/material_handler/#functions.material_handler.HASH_TYPE","title":"<code>HASH_TYPE = 'sha256'</code>  <code>module-attribute</code>","text":""},{"location":"reference/functions/material_handler/#functions.material_handler.material_handler","title":"<code>material_handler</code>","text":"<p>Handles the processing of material data from various sources.</p> <p>Parameters:</p> Name Type Description Default <code>links</code> <code>str or list</code> <p>The link(s) to the material data source(s).</p> required <code>cache</code> <code>bool</code> <p>cache the downloaded file using sha256 string</p> <code>True</code> <code>local</code> <code>bool</code> <p>load locally cached files if available</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the processed material data and information.</p> Source code in <code>yasfpy/functions/material_handler.py</code> <pre><code>def material_handler(links, cache: bool = True, local: bool = True):\n    \"\"\"\n    Handles the processing of material data from various sources.\n\n    Args:\n        links (str or list): The link(s) to the material data source(s).\n        cache (bool): cache the downloaded file using sha256 string\n        local (bool): load locally cached files if available\n\n    Returns:\n        (dict): A dictionary containing the processed material data and information.\n\n    \"\"\"\n    if not isinstance(links, list):\n        links = [links]\n\n    data_path = Path(f\"{files(__package__) / 'data'}\")\n    if not os.path.exists(data_path):\n        os.makedirs(data_path)\n\n    data = dict(ref_idx=pd.DataFrame(columns=[\"wavelength\", \"n\", \"k\"]), material=None)\n    for link in links:\n        link = link.strip()\n        if link[:4] == \"http\":\n            is_cached = False\n            h = hashlib.new(HASH_TYPE)\n            h.update(link.encode(\"utf-8\"))\n            cache_file_name = os.path.join(data_path, f\"{h.hexdigest()}.csv\")\n            material_file_name = os.path.join(data_path, f\"{h.hexdigest()}.txt\")\n            if os.path.isfile(cache_file_name):\n                df = pd.read_csv(cache_file_name)\n                material = \"NaN\"\n                with open(material_file_name, \"r\") as fh:\n                    material = fh.read()\n                is_cached = True\n                # print(f\"Reading {link} from cache: {cache_file_name}.\")\n            elif \"refractiveindex.info\" in link:\n                df, material = handle_refractiveindex_info(link)\n                # data[\"ref_idx\"] = pd.concat([data[\"ref_idx\"], df])\n                # data[\"material\"] = material\n            elif \"eodg.atm.ox.ac.uk\" in link:\n                df, material = handle_eodg(link)\n                # data[\"ref_idx\"] = pd.concat([data[\"ref_idx\"], df])\n                # data[\"material\"] = material\n            else:\n                print(f\"No matching handler found for {link}\")\n                continue\n            data[\"ref_idx\"] = pd.concat([data[\"ref_idx\"], df])\n            data[\"material\"] = material\n\n            if not is_cached:\n                # print(f\"{link} was not cached. Not caching at {cache_file_name}.\")\n                df.to_csv(cache_file_name, index=False)\n                with open(material_file_name, \"w\") as fh:\n                    fh.write(material)\n        else:\n            if \".csv\" in link:\n                df, material = handle_csv(link)\n                data[\"ref_idx\"] = pd.concat([data[\"ref_idx\"], df])\n                data[\"material\"] = material\n            else:\n                print(\"No matching handler found for file type\")\n    data[\"ref_idx\"] = data[\"ref_idx\"].sort_values(by=[\"wavelength\"])\n    return data\n</code></pre>"},{"location":"reference/functions/material_handler/#functions.material_handler.handle_refractiveindex_info","title":"<code>handle_refractiveindex_info</code>","text":"<p>Retrieves refractive index data from a given URL and processes it.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to retrieve the refractive index data from.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the processed data as a pandas DataFrame and the material name.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the data retrieval fails.</p> Source code in <code>yasfpy/functions/material_handler.py</code> <pre><code>def handle_refractiveindex_info(url):\n    \"\"\"\n    Retrieves refractive index data from a given URL and processes it.\n\n    Args:\n        url (str): The URL to retrieve the refractive index data from.\n\n    Returns:\n        (tuple): A tuple containing the processed data as a pandas DataFrame and the material name.\n\n    Raises:\n        Exception: If the data retrieval fails.\n\n    \"\"\"\n    url_split = url.replace(\"=\", \"/\").split(\"/\")\n    material = unquote(url_split[-2])\n\n    if np.any([(\"data_csv\" in part) or (\"data_txt\" in part) for part in url_split]):\n        print(\"Please use the [Full database record] option for refractiveindex.info!\")\n        print(\"Reverting url:\")\n        print(f\" from: {url}\")\n        url_split[3] = \"database\"\n        url = \"/\".join(url_split)\n        print(f\" to:   {url}\")\n\n    # req = urllib.request.Request(url)\n    # with urllib.request.urlopen(req) as resp:\n    resp = req.get(url)\n    if resp.status_code &gt;= 400:\n        raise Exception(f\"Failed to retrieve data from {url}\")\n    # data = resp.read()\n    # data = data.decode(\"utf-8\")\n    data = resp.text\n    data_yml = yaml.safe_load(data)\n    header_yml = [\"wavelength\", \"n\", \"k\"]\n    data = pd.DataFrame(columns=[\"wavelength\", \"n\", \"k\"])\n    for line in data_yml[\"DATA\"]:\n        df = None\n        if \"tabulated\" in line[\"type\"].lower():\n            # elif line['type'].lower()[-2:] == ' n':\n            #   header_yml=['wavelength', 'n']\n            if line[\"type\"].lower()[-2:] == \" k\":\n                header_yml = [\"wavelength\", \"k\", \"n\"]\n            df = pd.read_csv(\n                io.StringIO(line[\"data\"]),\n                delim_whitespace=True,\n                header=None,\n                names=header_yml,\n            )\n        elif \"formula\" in line[\"type\"].lower():\n            if line[\"type\"].lower() == \"formula 1\":\n                wavelengths = [float(c) for c in line[\"wavelength_range\"].split()]\n                wavelengths = np.arange(wavelengths[0], wavelengths[1], 0.1)\n                coefficients = np.array(\n                    [float(c) for c in line[\"coefficients\"].split()]\n                )\n                ref_idx = lambda x: np.sqrt(\n                    1\n                    + np.sum(\n                        [\n                            coefficients[i] * x**2 / (x**2 - coefficients[i + 1] ** 2)\n                            for i in range(1, len(coefficients), 2)\n                        ],\n                        axis=0,\n                    )\n                )\n                df = pd.DataFrame(columns=[\"wavelength\", \"n\", \"k\"])\n                df[\"wavelength\"] = wavelengths\n                df[\"n\"] = ref_idx(wavelengths)\n\n        if df is not None:\n            df = df.fillna(0)\n            data = pd.concat([data, df])\n\n    return data, material\n</code></pre>"},{"location":"reference/functions/material_handler/#functions.material_handler.handle_eodg","title":"<code>handle_eodg</code>","text":"<p>Handles the EODG material data retrieval from a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the EODG material data.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the retrieved material data and the material name.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the data retrieval from the URL fails.</p> Source code in <code>yasfpy/functions/material_handler.py</code> <pre><code>def handle_eodg(url):\n    \"\"\"\n    Handles the EODG material data retrieval from a given URL.\n\n    Args:\n        url (str): The URL of the EODG material data.\n\n    Returns:\n        (tuple): A tuple containing the retrieved material data and the material name.\n\n    Raises:\n        Exception: If the data retrieval from the URL fails.\n    \"\"\"\n    url_split = url.split(\"/\")\n    material = unquote(url_split[6])\n\n    resp = req.get(url)\n    if resp.status_code &gt;= 400:\n        raise Exception(f\"Failed to retrieve data from {url}\")\n    data = resp.text\n    data_format = [\n        s.lower() for s in re.search(r\"#FORMAT=(.*)\\n\", data).group(1).split()\n    ]\n    header_yml = [\"wavelength\", \"n\", \"k\"]\n    if \"n\" not in data_format:\n        header_yml = [\"wavelength\", \"k\", \"n\"]\n\n    data = re.sub(r\"^#.*\\n\", \"\", data, flags=re.MULTILINE)\n    data = pd.read_csv(\n        io.StringIO(data), delim_whitespace=True, header=None, names=header_yml\n    )\n    data = data.fillna(0)\n    if \"wavn\" in data_format:\n        data[\"wavelength\"] = 1e4 / data[\"wavelength\"]\n        data = data.iloc[::-1]\n\n    return data, material\n</code></pre>"},{"location":"reference/functions/material_handler/#functions.material_handler.handle_csv","title":"<code>handle_csv</code>","text":"<p>Read a CSV file containing material data and extract the material name and data.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the CSV file.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the material data as a pandas DataFrame and the material name.</p> Source code in <code>yasfpy/functions/material_handler.py</code> <pre><code>def handle_csv(path):\n    \"\"\"\n    Read a CSV file containing material data and extract the material name and data.\n\n    Args:\n        path (str): The path to the CSV file.\n\n    Returns:\n        (tuple): A tuple containing the material data as a pandas DataFrame and the material name.\n    \"\"\"\n    name = re.split(r\"\\._-\", path)\n    material = unquote(name[0])\n    data = pd.read_csv(\n        path, delim_whitespace=False, header=0, names=[\"wavelength\", \"n\", \"k\"]\n    )\n    return data, material\n</code></pre>"},{"location":"reference/functions/misc/","title":"Misc","text":""},{"location":"reference/functions/misc/#functions.misc.jmult_max","title":"<code>jmult_max</code>","text":"<p>Calculate the maximum value of jmult.</p> <p>Parameters: num_part (int): The number of particles. lmax (int): The maximum value of l.</p> <p>Returns:</p> Type Description <code>int</code> <p>The maximum value of jmult.</p> Source code in <code>yasfpy/functions/misc.py</code> <pre><code>def jmult_max(num_part, lmax):\n    \"\"\"\n    Calculate the maximum value of jmult.\n\n    Parameters:\n    num_part (int): The number of particles.\n    lmax (int): The maximum value of l.\n\n    Returns:\n        (int): The maximum value of jmult.\n    \"\"\"\n    return num_part * 2 * lmax * (lmax + 2)\n</code></pre>"},{"location":"reference/functions/misc/#functions.misc.multi2single_index","title":"<code>multi2single_index</code>","text":"<p>Converts the multi-index (j_s, tau, l, m) to a single index.</p> <p>Parameters:</p> Name Type Description Default <code>j_s</code> <code>int</code> <p>Particle index.</p> required <code>tau</code> <code>int</code> <p>Polarization value (1 or 2).</p> required <code>l</code> <code>int</code> <p>The value of l (between 0 and lmax).</p> required <code>m</code> <code>int</code> <p>The value of m (between -l and l).</p> required <code>lmax</code> <code>int</code> <p>Cutoff value for the field expansion.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The single index corresponding to the multi-index (j_s, tau, l, m).</p> Source code in <code>yasfpy/functions/misc.py</code> <pre><code>def multi2single_index(j_s, tau, l, m, lmax):\n    \"\"\"\n    Converts the multi-index (j_s, tau, l, m) to a single index.\n\n    Args:\n        j_s (int): Particle index.\n        tau (int): Polarization value (1 or 2).\n        l (int): The value of l (between 0 and lmax).\n        m (int): The value of m (between -l and l).\n        lmax (int): Cutoff value for the field expansion.\n\n    Returns:\n        (int): The single index corresponding to the multi-index (j_s, tau, l, m).\n    \"\"\"\n    return (\n        j_s * 2 * lmax * (lmax + 2)\n        + (tau - 1) * lmax * (lmax + 2)\n        + (l - 1) * (l + 1)\n        + m\n        + l\n    )\n</code></pre>"},{"location":"reference/functions/misc/#functions.misc.single_index2multi","title":"<code>single_index2multi</code>","text":"<p>Convert a single index to multi-indices (j_s, tau, l, m) for spherical harmonics.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The single index.</p> required <code>lmax</code> <code>int</code> <p>Cutoff value for the field expansion.</p> required <p>Returns:</p> Name Type Description <code>j_s</code> <code>int</code> <p>Particle index.</p> <code>tau</code> <code>int</code> <p>Polarization value (1 or 2).</p> <code>l</code> <code>float</code> <p>The value of l (between 0 and lmax).</p> <code>m</code> <code>int</code> <p>The value of m (between -l and l).</p> Source code in <code>yasfpy/functions/misc.py</code> <pre><code>@nb.njit(nogil=True, fastmath=True)\ndef single_index2multi(idx, lmax):\n    \"\"\"\n    Convert a single index to multi-indices (j_s, tau, l, m) for spherical harmonics.\n\n    Args:\n        idx (int): The single index.\n        lmax (int): Cutoff value for the field expansion.\n\n    Returns:\n        j_s (int): Particle index.\n        tau (int): Polarization value (1 or 2).\n        l (float): The value of l (between 0 and lmax).\n        m (int): The value of m (between -l and l).\n    \"\"\"\n    j_s = idx // (2 * lmax * (lmax + 2))\n    idx_new = idx % (2 * lmax * (lmax + 2))\n    tau = idx_new // (lmax * (lmax + 2)) + 1\n    idx_new = idx_new % (lmax * (lmax + 2))\n    l = np.floor(np.sqrt(idx_new + 1))\n    m = idx_new - (l * l + l - 1)\n    return j_s, tau, l, m\n</code></pre>"},{"location":"reference/functions/misc/#functions.misc.transformation_coefficients","title":"<code>transformation_coefficients</code>","text":"<p>Calculate the transformation coefficients for spherical harmonics.</p> <p>Parameters:</p> Name Type Description Default <code>pilm</code> <code>ndarray</code> <p>Array of spherical harmonics.</p> required <code>taulm</code> <code>ndarray</code> <p>Array of spherical harmonics.</p> required <code>tau</code> <code>int</code> <p>Polarization state.</p> required <code>l</code> <code>int</code> <p>Degree of the spherical harmonics.</p> required <code>m</code> <code>int</code> <p>Order of the spherical harmonics.</p> required <code>pol</code> <code>int</code> <p>Polarization state.</p> required <code>dagger</code> <code>bool</code> <p>Whether to apply the dagger operation. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>The transformation coefficient.</p> Source code in <code>yasfpy/functions/misc.py</code> <pre><code>def transformation_coefficients(pilm, taulm, tau, l, m, pol, dagger: bool = False):\n    \"\"\"\n    Calculate the transformation coefficients for spherical harmonics.\n\n    Args:\n        pilm (ndarray): Array of spherical harmonics.\n        taulm (ndarray): Array of spherical harmonics.\n        tau (int): Polarization state.\n        l (int): Degree of the spherical harmonics.\n        m (int): Order of the spherical harmonics.\n        pol (int): Polarization state.\n        dagger (bool, optional): Whether to apply the dagger operation. Defaults to False.\n\n    Returns:\n        (float): The transformation coefficient.\n\n    \"\"\"\n    ifac = 1j\n    if dagger:\n        ifac *= -1\n\n    # Polarized light\n    if np.any(np.equal(pol, [1, 2])):\n        if tau == pol:\n            spher_fun = taulm[l, np.abs(m)]\n        else:\n            spher_fun = m * pilm[l, np.abs(m)]\n\n        return (\n            -1\n            / np.power(ifac, l + 1)\n            / np.sqrt(2 * l * (l + 1))\n            * (ifac * (pol == 1) + (pol == 2))\n            * spher_fun\n        )\n\n    # Unpolarized light\n    return (\n        -1\n        / np.power(ifac, l + 1)\n        / np.sqrt(2 * l * (l + 1))\n        * (ifac + 1)\n        * (taulm[l, np.abs(m)] + m * pilm[l, np.abs(m)])\n        / 2\n    )\n</code></pre>"},{"location":"reference/functions/misc/#functions.misc.mutual_lookup","title":"<code>mutual_lookup</code>","text":"<p>Calculate mutual lookup tables for scattering calculations.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics expansion.</p> required <code>positions_1</code> <code>ndarray</code> <p>The positions of the first set of particles.</p> required <code>positions_2</code> <code>ndarray</code> <p>The positions of the second set of particles.</p> required <code>refractive_index</code> <code>ndarray</code> <p>The refractive indices of the particles.</p> required <code>derivatives</code> <code>bool</code> <p>Whether to calculate the derivatives of the lookup tables. Defaults to False.</p> <code>False</code> <code>parallel</code> <code>bool</code> <p>Whether to use parallel computation. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>spherical_bessel</code> <code>ndarray</code> <p>The spherical Bessel functions.</p> <code>spherical_hankel</code> <code>ndarray</code> <p>The spherical Hankel functions.</p> <code>e_j_dm_phi</code> <code>ndarray</code> <p>The exponential term in the scattering calculation.</p> <code>p_lm</code> <code>ndarray</code> <p>The normalized Legendre polynomials.</p> <code>e_r</code> <code>ndarray</code> <p>The unit vectors in the radial direction.</p> <code>e_theta</code> <code>ndarray</code> <p>The unit vectors in the polar direction.</p> <code>e_phi</code> <code>ndarray</code> <p>The unit vectors in the azimuthal direction.</p> <code>cosine_theta</code> <code>ndarray</code> <p>The cosine of the polar angle.</p> <code>sine_theta</code> <code>ndarray</code> <p>The sine of the polar angle.</p> <code>size_parameter</code> <code>ndarray</code> <p>The size parameter of the particles.</p> <code>spherical_hankel_derivative</code> <code>ndarray</code> <p>The derivative of the spherical Hankel functions.</p> Source code in <code>yasfpy/functions/misc.py</code> <pre><code>def mutual_lookup(\n    lmax: int,\n    positions_1: np.ndarray,\n    positions_2: np.ndarray,\n    refractive_index: np.ndarray,\n    derivatives: bool = False,\n    parallel: bool = False,\n):\n    \"\"\"\n    Calculate mutual lookup tables for scattering calculations.\n\n    Args:\n        lmax (int): The maximum degree of the spherical harmonics expansion.\n        positions_1 (np.ndarray): The positions of the first set of particles.\n        positions_2 (np.ndarray): The positions of the second set of particles.\n        refractive_index (np.ndarray): The refractive indices of the particles.\n        derivatives (bool, optional): Whether to calculate the derivatives of the lookup tables. Defaults to False.\n        parallel (bool, optional): Whether to use parallel computation. Defaults to False.\n\n    Returns:\n        spherical_bessel (np.ndarray): The spherical Bessel functions.\n        spherical_hankel (np.ndarray): The spherical Hankel functions.\n        e_j_dm_phi (np.ndarray): The exponential term in the scattering calculation.\n        p_lm (np.ndarray): The normalized Legendre polynomials.\n        e_r (np.ndarray): The unit vectors in the radial direction.\n        e_theta (np.ndarray): The unit vectors in the polar direction.\n        e_phi (np.ndarray): The unit vectors in the azimuthal direction.\n        cosine_theta (np.ndarray): The cosine of the polar angle.\n        sine_theta (np.ndarray): The sine of the polar angle.\n        size_parameter (np.ndarray): The size parameter of the particles.\n        spherical_hankel_derivative (np.ndarray): The derivative of the spherical Hankel functions.\n    \"\"\"\n    differences = positions_1[:, np.newaxis, :] - positions_2[np.newaxis, :, :]\n    distances = np.sqrt(np.sum(differences**2, axis=2))\n    distances = distances[:, :, np.newaxis]\n    e_r = np.divide(\n        differences, distances, out=np.zeros_like(differences), where=distances != 0\n    )\n    cosine_theta = e_r[:, :, 2]\n    # cosine_theta = np.divide(\n    #   differences[:, :, 2],\n    #   distances,\n    #   out = np.zeros_like(distances),\n    #   where = distances != 0\n    # )\n    # correct possible rounding errors\n    cosine_theta[cosine_theta &lt; -1] = -1\n    cosine_theta[cosine_theta &gt; 1] = 1\n    sine_theta = np.sqrt(1 - cosine_theta**2)\n    phi = np.arctan2(differences[:, :, 1], differences[:, :, 0])\n    e_theta = np.stack(\n        [cosine_theta * np.cos(phi), cosine_theta * np.sin(phi), -sine_theta], axis=-1\n    )\n    e_phi = np.stack([-np.sin(phi), np.cos(phi), np.zeros_like(phi)], axis=-1)\n\n    size_parameter = distances * np.array(refractive_index)[np.newaxis, np.newaxis, :]\n\n    if parallel:\n        from yasfpy.functions.cpu_numba import compute_lookup_tables\n\n        spherical_bessel, spherical_hankel, e_j_dm_phi, p_lm = compute_lookup_tables(\n            lmax, size_parameter, phi, cosine_theta\n        )\n    else:\n        p_range = np.arange(2 * lmax + 1)\n        p_range = p_range[:, np.newaxis, np.newaxis, np.newaxis]\n        size_parameter_extended = size_parameter[np.newaxis, :, :, :]\n        spherical_hankel = np.sqrt(\n            np.divide(\n                np.pi / 2,\n                size_parameter_extended,\n                out=np.zeros_like(size_parameter_extended),\n                where=size_parameter_extended != 0,\n            )\n        ) * hankel1(p_range + 1 / 2, size_parameter_extended)\n        spherical_bessel = spherical_jn(p_range, size_parameter_extended)\n\n        if derivatives:\n            spherical_hankel_lower = np.sqrt(\n                np.divide(\n                    np.pi / 2,\n                    size_parameter_extended,\n                    out=np.zeros_like(size_parameter_extended),\n                    where=size_parameter_extended != 0,\n                )\n            ) * hankel1(-1 / 2, size_parameter_extended)\n            spherical_hankel_lower = np.vstack(\n                (spherical_hankel_lower, spherical_hankel[:-1, :, :, :])\n            )\n            spherical_hankel_derivative = (\n                size_parameter_extended * spherical_hankel_lower\n                - p_range * spherical_hankel\n            )\n\n            # p_range = np.arange(2 * lmax + 2) - 1\n            # p_range = p_range[:, np.newaxis, np.newaxis, np.newaxis]\n            # spherical_hankel = np.sqrt(np.divide(np.pi / 2, size_parameter_extended, out = np.zeros_like(size_parameter_extended), where = size_parameter_extended != 0)) * hankel1(p_range + 1/2, size_parameter_extended)\n            # spherical_hankel_derivative = size_parameter_extended * spherical_hankel[:-1, :, :, :] - p_range[1:, :, :, :] * spherical_hankel[1:, :, :, :]\n\n            p_lm = legendre_normalized_trigon(lmax, cosine_theta, sine_theta)\n        else:\n            spherical_hankel_derivative = None\n\n            p_lm = np.zeros(\n                (lmax + 1) * (2 * lmax + 1) * np.prod(size_parameter.shape[:2])\n            ).reshape(((lmax + 1) * (2 * lmax + 1),) + size_parameter.shape[:2])\n            for p in range(2 * lmax + 1):\n                for absdm in range(p + 1):\n                    cml = np.sqrt(\n                        (2 * p + 1)\n                        / 2\n                        * np.prod(1 / np.arange(p - absdm + 1, p + absdm + 1))\n                    )\n                    p_lm[p * (p + 1) // 2 + absdm, :, :] = (\n                        cml * np.power(-1.0, absdm) * lpmv(absdm, p, cosine_theta)\n                    )\n\n        phi = phi[np.newaxis, :, :]\n        p_range = np.arange(-2 * lmax, 2 * lmax + 1)\n        p_range = p_range[:, np.newaxis, np.newaxis]\n        e_j_dm_phi = np.exp(1j * p_range * phi)\n\n    return (\n        spherical_bessel,\n        spherical_hankel,\n        e_j_dm_phi,\n        p_lm,\n        e_r,\n        e_theta,\n        e_phi,\n        cosine_theta,\n        sine_theta,\n        size_parameter,\n        spherical_hankel_derivative,\n    )\n</code></pre>"},{"location":"reference/functions/misc/#functions.misc.generate_refractive_index_table","title":"<code>generate_refractive_index_table</code>","text":"<p>The function <code>generate_refractive_index_table</code> takes a list of URLs, retrieves data from each URL using the <code>material_handler</code> function, and returns a list of the retrieved data.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list</code> <p>A list of URLs representing different materials.</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>list</code> <p>A list of data. Each element in the list corresponds to a URL in the input list, and the data is obtained by calling the <code>material_handler</code> function on each URL.</p> Source code in <code>yasfpy/functions/misc.py</code> <pre><code>def generate_refractive_index_table(urls: list) -&gt; list:\n    \"\"\"The function `generate_refractive_index_table` takes a list of URLs, retrieves data from each\n    URL using the `material_handler` function, and returns a list of the retrieved data.\n\n    Args:\n        urls (list): A list of URLs representing different materials.\n\n    Returns:\n        data (list): A list of data. Each element in the list corresponds to a URL in the input list,\n            and the data is obtained by calling the `material_handler` function on each URL.\n\n    \"\"\"\n    # data = [None] * len(urls)\n    # for k, url in enumerate(urls):\n    # data[k] = material_handler(url)\n    data = []\n    for url in urls:\n        handle = Handler(url=url)\n        data.append(dict(ref_idx=handle.nk))\n\n    return data\n</code></pre>"},{"location":"reference/functions/spherical_functions_trigon/","title":"Spherical Functions Trigon","text":""},{"location":"reference/functions/spherical_functions_trigon/#functions.spherical_functions_trigon.spherical_functions_trigon","title":"<code>spherical_functions_trigon</code>","text":"<p>Compute spherical functions using trigonometric functions.</p> <p>Parameters:</p> Name Type Description Default <code>lmax</code> <code>int</code> <p>The maximum degree of the spherical harmonics.</p> required <code>theta</code> <code>ndarray or float</code> <p>The polar angle(s) in radians.</p> required <code>st</code> <code>ndarray or float</code> <p>The sine of the polar angle(s). If not provided, it will be computed from theta.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>pilm</code> <code>ndarray</code> <p>The associated Legendre functions.</p> <code>taulm</code> <code>ndarray</code> <p>The derivative of the associated Legendre functions.</p> Source code in <code>yasfpy/functions/spherical_functions_trigon.py</code> <pre><code>def spherical_functions_trigon(lmax, theta, st=None):\n    \"\"\"\n    Compute spherical functions using trigonometric functions.\n\n    Args:\n        lmax (int): The maximum degree of the spherical harmonics.\n        theta (numpy.ndarray or float): The polar angle(s) in radians.\n        st (numpy.ndarray or float, optional): The sine of the polar angle(s). If not provided, it will be computed from theta.\n\n    Returns:\n        pilm (numpy.ndarray): The associated Legendre functions.\n        taulm (numpy.ndarray): The derivative of the associated Legendre functions.\n\n    \"\"\"\n    size = np.array([1])\n    if isinstance(theta, np.ndarray):\n        size = theta.shape\n\n    if st is None:\n        ct = np.cos(theta)\n        st = np.sin(theta)\n    else:\n        ct = np.array(theta)\n        st = np.array(st)\n\n    ct = ct.ravel()\n    st = st.ravel()\n\n    plm = np.zeros((lmax + 1, lmax + 1, ct.shape[0])) * np.nan\n    pilm = np.zeros(plm.shape) * np.nan\n    taulm = np.zeros(plm.shape) * np.nan\n    pprimel0 = np.zeros((lmax + 1, ct.shape[0])) * np.nan\n\n    plm[0, 0, :] = np.sqrt(1 / 2) * np.ones_like(ct)\n    plm[1, 0, :] = np.sqrt(3 / 2) * ct\n\n    pilm[0, 0, :] = np.zeros_like(ct)\n    pilm[1, 0, :] = np.zeros_like(ct)\n\n    pprimel0[0, :] = np.zeros_like(ct)\n    pprimel0[1, :] = np.sqrt(3) * plm[0, 0, :]\n\n    taulm[0, 0, :] = -st * pprimel0[0, :]\n    taulm[1, 0, :] = -st * pprimel0[1, :]\n\n    for l in range(1, lmax):\n        plm[l + 1, 0, :] = (\n            1 / (l + 1) * np.sqrt((2 * l + 1) * (2 * l + 3)) * ct * plm[l, 0, :]\n            - l / (l + 1) * np.sqrt((2 * l + 3) / (2 * l - 1)) * plm[l - 1, 0, :]\n        )\n        pilm[l + 1, 0, :] = np.zeros_like(ct)\n        pprimel0[l + 1, :] = np.sqrt((2 * l + 3) / (2 * l + 1)) * (\n            (l + 1) * plm[l, 0, :] + ct * pprimel0[l, :]\n        )\n        taulm[l + 1, 0, :] = -st * pprimel0[l + 1, :]\n\n    for m in range(1, lmax + 1):\n        plm[m - 1, m, :] = np.zeros_like(ct)\n        pilm[m - 1, m, :] = np.zeros_like(ct)\n        coeff = np.sqrt((2 * m + 1) / 2 / math.factorial(2 * m)) * np.prod(\n            np.arange(1, 2 * m, 2)\n        )\n        plm[m, m, :] = coeff * np.power(st, m)\n        pilm[m, m, :] = coeff * np.power(st, m - 1)\n        taulm[m, m, :] = m * ct * pilm[m, m, :]\n        for l in range(m, lmax):\n            coeff1 = np.sqrt((2 * l + 1) * (2 * l + 3) / (l + 1 - m) / (l + 1 + m)) * ct\n            coeff2 = np.sqrt(\n                (2 * l + 3)\n                * (l - m)\n                * (l + m)\n                / (2 * l - 1)\n                / (l + 1 - m)\n                / (l + 1 + m)\n            )\n            plm[l + 1, m, :] = coeff1 * plm[l, m, :] - coeff2 * plm[l - 1, m, :]\n            pilm[l + 1, m, :] = coeff1 * pilm[l, m, :] - coeff2 * pilm[l - 1, m, :]\n            taulm[l + 1, m, :] = (l + 1) * ct * pilm[l + 1, m, :] - (\n                l + 1 + m\n            ) * np.sqrt((2 * l + 3) * (l + 1 - m) / (2 * l + 1) / (l + 1 + m)) * pilm[\n                l, m, :\n            ]\n\n    pilm = np.reshape(pilm, np.concatenate(([lmax + 1, lmax + 1], size)))\n    taulm = np.reshape(taulm, np.concatenate(([lmax + 1, lmax + 1], size)))\n    return pilm, taulm\n</code></pre>"},{"location":"reference/functions/t_entry/","title":"T Entry","text":""},{"location":"reference/functions/t_entry/#functions.t_entry.t_entry","title":"<code>t_entry</code>","text":"<p>Computes an entry in the T Matrix for a given k, l, and tau</p> <p>Parameters:</p> Name Type Description Default <code>tau</code> <code>float</code> <p>The value of tau.</p> required <code>l</code> <code>int</code> <p>The value of l.</p> required <code>k_medium</code> <code>float</code> <p>The value of k_medium.</p> required <code>k_sphere</code> <code>float</code> <p>The value of k_sphere.</p> required <code>radius</code> <code>float</code> <p>The value of radius.</p> required <code>field_type</code> <code>str</code> <p>The type of field. Defaults to \"scattered\".</p> <code>'scattered'</code> <p>Returns:</p> Type Description <code>float</code> <p>The computed entry in the T Matrix.</p> Note <p>scipy.special has also derivative function. Why is it not the same?</p> <p>Now:      <code>djx  = x *  spherical_jn(l-1, x)  - l * jx</code> Possible: <code>djx  = spherical_jn(l, x, derivative=True)</code></p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid field type is provided.</p> Source code in <code>yasfpy/functions/t_entry.py</code> <pre><code>def t_entry(tau, l, k_medium, k_sphere, radius, field_type=\"scattered\"):\n    \"\"\"\n    Computes an entry in the T Matrix for a given k, l, and tau\n\n    Args:\n        tau (float): The value of tau.\n        l (int): The value of l.\n        k_medium (float): The value of k_medium.\n        k_sphere (float): The value of k_sphere.\n        radius (float): The value of radius.\n        field_type (str, optional): The type of field. Defaults to \"scattered\".\n\n    Returns:\n        (float): The computed entry in the T Matrix.\n\n    Note:\n        [scipy.special](https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.spherical_jn.html#scipy.special.spherical_jn){:target=\"_blank\"}\n        has also derivative function. Why is it not the same?\n\n        Now:      `djx  = x *  spherical_jn(l-1, x)  - l * jx`&lt;br&gt;\n        Possible: `djx  = spherical_jn(l, x, derivative=True)`\n\n    Raises:\n        ValueError: If an invalid field type is provided.\n\n    \"\"\"\n    m = k_sphere / k_medium\n    x = k_medium * radius\n    mx = k_sphere * radius\n\n    jx = spherical_jn(l, x)\n    jmx = spherical_jn(l, mx)\n    hx = spherical_jn(l, x) + 1j * spherical_yn(l, x)\n\n    djx = x * spherical_jn(l - 1, x) - l * jx\n    djmx = mx * spherical_jn(l - 1, mx) - l * jmx\n    dhx = x * (spherical_jn(l - 1, x) + 1j * spherical_yn(l - 1, x)) - l * hx\n\n    # if (field_type, tau) == (\"scattered\", 1):\n    #     return -(jmx * djx - jx * djmx) / (jmx * dhx - hx * djmx)  # -b\n    # if (field_type, tau) == (\"scattered\", 2):\n    #     return -(m**2 * jmx * djx - jx * djmx) / (m**2 * jmx * dhx - hx * djmx)  # -a\n    # if (field_type, tau) == (\"internal\", 1):\n    #     return (jx * dhx - hx * djx) / (jmx * dhx - hx * djmx)  # c\n    # if (field_type, tau) == (\"internal\", 2):\n    #     return (m * jx * dhx - m * hx * djx) / (m**2 * jmx * dhx - hx * djmx)  # d\n    # if (field_type, tau) == (\"ratio\", 1):\n    #     return (jx * dhx - hx * djx) / -(jmx * djx - jx * djmx)  # c / -b\n    # if (field_type, tau) == (\"ratio\", 2):\n    #     return (m * jx * dhx - m * hx * djx) / -(m**2 * jmx * djx - jx * djmx)  # d / -a\n    match (field_type, tau):\n        case (\"scattered\", 1):\n            return -(jmx * djx - jx * djmx) / (jmx * dhx - hx * djmx)  # -b\n        case (\"scattered\", 2):\n            return -(m**2 * jmx * djx - jx * djmx) / (\n                m**2 * jmx * dhx - hx * djmx\n            )  # -a\n        case (\"internal\", 1):\n            return (jx * dhx - hx * djx) / (jmx * dhx - hx * djmx)  # c\n        case (\"internal\", 2):\n            return (m * jx * dhx - m * hx * djx) / (m**2 * jmx * dhx - hx * djmx)  # d\n        case (\"ratio\", 1):\n            return (jx * dhx - hx * djx) / -(jmx * djx - jx * djmx)  # c / -b\n        case (\"ratio\", 2):\n            return (m * jx * dhx - m * hx * djx) / -(\n                m**2 * jmx * djx - jx * djmx\n            )  # d / -a\n        case _:\n            raise ValueError(\"Not a valid field type provided. Returning None!\")\n</code></pre>"},{"location":"testing/","title":"Unit tests","text":"<p>Testing is done using the built-in library <code>unittest</code>. To run all test files in the folder <code>tests/</code>, execute in the project root folder:</p> <pre><code>python -m unittest\n</code></pre>"},{"location":"testing/#coverage-report","title":"Coverage report","text":"<p>Install the <code>coverage</code> package:</p> <pre><code>pip install coverage\n</code></pre> <p>The command <code>coverage run</code> will replace any <code>python</code> command. To get a coverage report on the unit tests, run the following command:</p> <pre><code>coverage run -m unittest\n</code></pre> <p>To report this to codacy, the <code>.coverage</code> file needs to be translated to the cobertura xml standard:</p> <pre><code>coverage xml -o cobertura.xml\n</code></pre> <p>Before submitting the report, provide an API key using an environmental variable <code>export CODACY_PROJECT_TOKEN=xxxxxxxxxxxxxxxxxxxxx</code>. Now the report can be submitted to codacy using:</p> <pre><code>bash &lt;(curl -Ls https://coverage.codacy.com/get.sh)\n</code></pre>"}]}